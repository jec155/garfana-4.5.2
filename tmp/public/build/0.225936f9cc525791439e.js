webpackJsonp([0],{

/***/ 1304:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
  __webpack_require__(1394),
  __webpack_require__(1542),
  __webpack_require__(1325),
  __webpack_require__(1401),
  __webpack_require__(1411),
  __webpack_require__(1362),
  __webpack_require__(1543),
  __webpack_require__(1549),
  __webpack_require__(1551),
  __webpack_require__(1558),
], __WEBPACK_AMD_DEFINE_RESULT__ = function () {}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ 1305:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_app_features_panel_panel_ctrl__ = __webpack_require__(1313);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_app_features_panel_metrics_panel_ctrl__ = __webpack_require__(1426);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_app_features_panel_query_ctrl__ = __webpack_require__(1327);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_app_features_alerting_alert_tab_ctrl__ = __webpack_require__(1428);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_app_features_plugins_plugin_loader__ = __webpack_require__(1316);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "PanelCtrl", function() { return __WEBPACK_IMPORTED_MODULE_0_app_features_panel_panel_ctrl__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "MetricsPanelCtrl", function() { return __WEBPACK_IMPORTED_MODULE_1_app_features_panel_metrics_panel_ctrl__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "QueryCtrl", function() { return __WEBPACK_IMPORTED_MODULE_2_app_features_panel_query_ctrl__["QueryCtrl"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "alertTab", function() { return __WEBPACK_IMPORTED_MODULE_3_app_features_alerting_alert_tab_ctrl__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "loadPluginCss", function() { return __WEBPACK_IMPORTED_MODULE_4_app_features_plugins_plugin_loader__["loadPluginCss"]; });








/***/ }),

/***/ 1306:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "variableTypes", function() { return variableTypes; });
/* harmony export (immutable) */ __webpack_exports__["containsVariable"] = containsVariable;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_app_core_utils_kbn__ = __webpack_require__(464);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_app_core_utils_model_utils__ = __webpack_require__(477);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "assignModelProperties", function() { return __WEBPACK_IMPORTED_MODULE_1_app_core_utils_model_utils__["a"]; });


var variableTypes = {};

function containsVariable() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    var variableName = args[args.length - 1];
    var str = args[0] || '';
    for (var i = 1; i < args.length - 1; i++) {
        str += ' ' + args[i] || '';
    }
    variableName = __WEBPACK_IMPORTED_MODULE_0_app_core_utils_kbn__["default"].regexEscape(variableName);
    var findVarRegex = new RegExp('\\$(' + variableName + ')(?:\\W|$)|\\[\\[(' + variableName + ')\\]\\]', 'g');
    var match = findVarRegex.exec(str);
    return match !== null;
}


/***/ }),

/***/ 1307:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_app_core_components_query_part_query_part__ = __webpack_require__(1308);
///<reference path="../../headers/common.d.ts" />


var alertQueryDef = new __WEBPACK_IMPORTED_MODULE_1_app_core_components_query_part_query_part__["b" /* QueryPartDef */]({
    type: 'query',
    params: [
        { name: "queryRefId", type: 'string', dynamicLookup: true },
        { name: "from", type: "string", options: ['1s', '10s', '1m', '5m', '10m', '15m', '1h', '24h', '48h'] },
        { name: "to", type: "string", options: ['now'] },
    ],
    defaultParams: ['#A', '15m', 'now', 'avg']
});
var conditionTypes = [
    { text: 'Query', value: 'query' },
];
var alertStateSortScore = {
    alerting: 1,
    no_data: 2,
    pending: 3,
    ok: 4,
    paused: 5,
};
var evalFunctions = [
    { text: 'IS ABOVE', value: 'gt' },
    { text: 'IS BELOW', value: 'lt' },
    { text: 'IS OUTSIDE RANGE', value: 'outside_range' },
    { text: 'IS WITHIN RANGE', value: 'within_range' },
    { text: 'HAS NO VALUE', value: 'no_value' }
];
var evalOperators = [
    { text: 'OR', value: 'or' },
    { text: 'AND', value: 'and' },
];
var reducerTypes = [
    { text: 'avg()', value: 'avg' },
    { text: 'min()', value: 'min' },
    { text: 'max()', value: 'max' },
    { text: 'sum()', value: 'sum' },
    { text: 'count()', value: 'count' },
    { text: 'last()', value: 'last' },
    { text: 'median()', value: 'median' },
    { text: 'diff()', value: 'diff' },
    { text: 'percent_diff()', value: 'percent_diff' },
    { text: 'count_non_null()', value: 'count_non_null' },
];
var noDataModes = [
    { text: 'Alerting', value: 'alerting' },
    { text: 'No Data', value: 'no_data' },
    { text: 'Keep Last State', value: 'keep_state' },
    { text: 'Ok', value: 'ok' },
];
var executionErrorModes = [
    { text: 'Alerting', value: 'alerting' },
    { text: 'Keep Last State', value: 'keep_state' },
];
function createReducerPart(model) {
    var def = new __WEBPACK_IMPORTED_MODULE_1_app_core_components_query_part_query_part__["b" /* QueryPartDef */]({ type: model.type, defaultParams: [] });
    return new __WEBPACK_IMPORTED_MODULE_1_app_core_components_query_part_query_part__["a" /* QueryPart */](model, def);
}
function getStateDisplayModel(state) {
    switch (state) {
        case 'ok': {
            return {
                text: 'OK',
                iconClass: 'icon-gf icon-gf-online',
                stateClass: 'alert-state-ok'
            };
        }
        case 'alerting': {
            return {
                text: 'ALERTING',
                iconClass: 'icon-gf icon-gf-critical',
                stateClass: 'alert-state-critical'
            };
        }
        case 'no_data': {
            return {
                text: 'NO DATA',
                iconClass: "fa fa-question",
                stateClass: 'alert-state-warning'
            };
        }
        case 'paused': {
            return {
                text: 'PAUSED',
                iconClass: "fa fa-pause",
                stateClass: 'alert-state-paused'
            };
        }
        case 'pending': {
            return {
                text: 'PENDING',
                iconClass: "fa fa-exclamation",
                stateClass: 'alert-state-warning'
            };
        }
    }
    throw { message: 'Unknown alert state' };
}
function joinEvalMatches(matches, separator) {
    return __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.reduce(matches, function (res, ev) {
        if (ev.metric !== undefined && ev.value !== undefined) {
            res.push(ev.metric + '=' + ev.value);
        }
        // For backwards compatibility . Should be be able to remove this after ~2017-06-01
        if (ev.Metric !== undefined && ev.Value !== undefined) {
            res.push(ev.Metric + '=' + ev.Value);
        }
        return res;
    }, []).join(separator);
}
function getAlertAnnotationInfo(ah) {
    // backward compatability, can be removed in grafana 5.x
    // old way stored evalMatches in data property directly,
    // new way stores it in evalMatches property on new data object
    if (__WEBPACK_IMPORTED_MODULE_0_lodash___default.a.isArray(ah.data)) {
        return joinEvalMatches(ah.data, ', ');
    }
    else if (__WEBPACK_IMPORTED_MODULE_0_lodash___default.a.isArray(ah.data.evalMatches)) {
        return joinEvalMatches(ah.data.evalMatches, ', ');
    }
    if (ah.data.error) {
        return "Error: " + ah.data.error;
    }
    if (ah.data.noData || ah.data.no_data) {
        return "No Data";
    }
    return "";
}
/* harmony default export */ __webpack_exports__["a"] = ({
    alertQueryDef: alertQueryDef,
    getStateDisplayModel: getStateDisplayModel,
    conditionTypes: conditionTypes,
    evalFunctions: evalFunctions,
    evalOperators: evalOperators,
    noDataModes: noDataModes,
    executionErrorModes: executionErrorModes,
    reducerTypes: reducerTypes,
    createReducerPart: createReducerPart,
    getAlertAnnotationInfo: getAlertAnnotationInfo,
    alertStateSortScore: alertStateSortScore,
});


/***/ }),

/***/ 1308:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return QueryPartDef; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return QueryPart; });
/* harmony export (immutable) */ __webpack_exports__["c"] = functionRenderer;
/* harmony export (immutable) */ __webpack_exports__["d"] = suffixRenderer;
/* unused harmony export identityRenderer */
/* unused harmony export quotedIdentityRenderer */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_lodash__);
///<reference path="../../../headers/common.d.ts" />

var QueryPartDef = /** @class */ (function () {
    function QueryPartDef(options) {
        this.type = options.type;
        this.params = options.params;
        this.defaultParams = options.defaultParams;
        this.renderer = options.renderer;
        this.category = options.category;
        this.addStrategy = options.addStrategy;
    }
    return QueryPartDef;
}());

var QueryPart = /** @class */ (function () {
    function QueryPart(part, def) {
        this.part = part;
        this.def = def;
        if (!this.def) {
            throw { message: 'Could not find query part ' + part.type };
        }
        part.params = part.params || __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.clone(this.def.defaultParams);
        this.params = part.params;
        this.updateText();
    }
    QueryPart.prototype.render = function (innerExpr) {
        return this.def.renderer(this, innerExpr);
    };
    QueryPart.prototype.hasMultipleParamsInString = function (strValue, index) {
        if (strValue.indexOf(',') === -1) {
            return false;
        }
        return this.def.params[index + 1] && this.def.params[index + 1].optional;
    };
    QueryPart.prototype.updateParam = function (strValue, index) {
        var _this = this;
        // handle optional parameters
        // if string contains ',' and next param is optional, split and update both
        if (this.hasMultipleParamsInString(strValue, index)) {
            __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.each(strValue.split(','), function (partVal, idx) {
                _this.updateParam(partVal.trim(), idx);
            });
            return;
        }
        if (strValue === '' && this.def.params[index].optional) {
            this.params.splice(index, 1);
        }
        else {
            this.params[index] = strValue;
        }
        this.part.params = this.params;
        this.updateText();
    };
    QueryPart.prototype.updateText = function () {
        if (this.params.length === 0) {
            this.text = this.def.type + '()';
            return;
        }
        var text = this.def.type + '(';
        text += this.params.join(', ');
        text += ')';
        this.text = text;
    };
    return QueryPart;
}());

function functionRenderer(part, innerExpr) {
    var str = part.def.type + '(';
    var parameters = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.map(part.params, function (value, index) {
        var paramType = part.def.params[index];
        if (paramType.type === 'time') {
            if (value === 'auto') {
                value = '$__interval';
            }
        }
        if (paramType.quote === 'single') {
            return "'" + value + "'";
        }
        else if (paramType.quote === 'double') {
            return '"' + value + '"';
        }
        return value;
    });
    if (innerExpr) {
        parameters.unshift(innerExpr);
    }
    return str + parameters.join(', ') + ')';
}
function suffixRenderer(part, innerExpr) {
    return innerExpr + ' ' + part.params[0];
}
function identityRenderer(part, innerExpr) {
    return part.params[0];
}
function quotedIdentityRenderer(part, innerExpr) {
    return '"' + part.params[0] + '"';
}


/***/ }),

/***/ 1309:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_app_core_utils_kbn__ = __webpack_require__(464);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_lodash__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_lodash__);


function matchSeriesOverride(aliasOrRegex, seriesAlias) {
    if (!aliasOrRegex) {
        return false;
    }
    if (aliasOrRegex[0] === '/') {
        var regex = __WEBPACK_IMPORTED_MODULE_0_app_core_utils_kbn__["default"].stringToJsRegex(aliasOrRegex);
        return seriesAlias.match(regex) != null;
    }
    return aliasOrRegex === seriesAlias;
}
function translateFillOption(fill) {
    return fill === 0 ? 0.001 : fill / 10;
}
var TimeSeries = /** @class */ (function () {
    function TimeSeries(opts) {
        this.datapoints = opts.datapoints;
        this.label = opts.alias;
        this.id = opts.alias;
        this.alias = opts.alias;
        this.aliasEscaped = __WEBPACK_IMPORTED_MODULE_1_lodash___default.a.escape(opts.alias);
        this.color = opts.color;
        this.valueFormater = __WEBPACK_IMPORTED_MODULE_0_app_core_utils_kbn__["default"].valueFormats.none;
        this.stats = {};
        this.legend = true;
        this.unit = opts.unit;
        this.hasMsResolution = this.isMsResolutionNeeded();
    }
    TimeSeries.prototype.applySeriesOverrides = function (overrides) {
        this.lines = {};
        this.dashes = {
            dashLength: []
        };
        this.points = {};
        this.bars = {};
        this.yaxis = 1;
        this.zindex = 0;
        this.nullPointMode = null;
        delete this.stack;
        for (var i = 0; i < overrides.length; i++) {
            var override = overrides[i];
            if (!matchSeriesOverride(override.alias, this.alias)) {
                continue;
            }
            if (override.lines !== void 0) {
                this.lines.show = override.lines;
            }
            if (override.dashes !== void 0) {
                this.dashes.show = override.dashes;
                this.lines.lineWidth = 0;
            }
            if (override.points !== void 0) {
                this.points.show = override.points;
            }
            if (override.bars !== void 0) {
                this.bars.show = override.bars;
            }
            if (override.fill !== void 0) {
                this.lines.fill = translateFillOption(override.fill);
            }
            if (override.stack !== void 0) {
                this.stack = override.stack;
            }
            if (override.linewidth !== void 0) {
                this.lines.lineWidth = this.dashes.show ? 0 : override.linewidth;
                this.dashes.lineWidth = override.linewidth;
            }
            if (override.dashLength !== void 0) {
                this.dashes.dashLength[0] = override.dashLength;
            }
            if (override.spaceLength !== void 0) {
                this.dashes.dashLength[1] = override.spaceLength;
            }
            if (override.nullPointMode !== void 0) {
                this.nullPointMode = override.nullPointMode;
            }
            if (override.pointradius !== void 0) {
                this.points.radius = override.pointradius;
            }
            if (override.steppedLine !== void 0) {
                this.lines.steps = override.steppedLine;
            }
            if (override.zindex !== void 0) {
                this.zindex = override.zindex;
            }
            if (override.fillBelowTo !== void 0) {
                this.fillBelowTo = override.fillBelowTo;
            }
            if (override.color !== void 0) {
                this.color = override.color;
            }
            if (override.transform !== void 0) {
                this.transform = override.transform;
            }
            if (override.legend !== void 0) {
                this.legend = override.legend;
            }
            if (override.yaxis !== void 0) {
                this.yaxis = override.yaxis;
            }
        }
    };
    TimeSeries.prototype.getFlotPairs = function (fillStyle) {
        var result = [];
        this.stats.total = 0;
        this.stats.max = -Number.MAX_VALUE;
        this.stats.min = Number.MAX_VALUE;
        this.stats.logmin = Number.MAX_VALUE;
        this.stats.avg = null;
        this.stats.current = null;
        this.stats.first = null;
        this.stats.delta = 0;
        this.stats.diff = null;
        this.stats.range = null;
        this.stats.timeStep = Number.MAX_VALUE;
        this.allIsNull = true;
        this.allIsZero = true;
        var ignoreNulls = fillStyle === 'connected';
        var nullAsZero = fillStyle === 'null as zero';
        var currentTime;
        var currentValue;
        var nonNulls = 0;
        var previousTime;
        var previousValue = 0;
        var previousDeltaUp = true;
        for (var i = 0; i < this.datapoints.length; i++) {
            currentValue = this.datapoints[i][0];
            currentTime = this.datapoints[i][1];
            // Due to missing values we could have different timeStep all along the series
            // so we have to find the minimum one (could occur with aggregators such as ZimSum)
            if (previousTime !== undefined) {
                var timeStep = currentTime - previousTime;
                if (timeStep < this.stats.timeStep) {
                    this.stats.timeStep = timeStep;
                }
            }
            previousTime = currentTime;
            if (currentValue === null) {
                if (ignoreNulls) {
                    continue;
                }
                if (nullAsZero) {
                    currentValue = 0;
                }
            }
            if (currentValue !== null) {
                if (__WEBPACK_IMPORTED_MODULE_1_lodash___default.a.isNumber(currentValue)) {
                    this.stats.total += currentValue;
                    this.allIsNull = false;
                    nonNulls++;
                }
                if (currentValue > this.stats.max) {
                    this.stats.max = currentValue;
                }
                if (currentValue < this.stats.min) {
                    this.stats.min = currentValue;
                }
                if (this.stats.first === null) {
                    this.stats.first = currentValue;
                }
                else {
                    if (previousValue > currentValue) {
                        previousDeltaUp = false;
                        if (i === this.datapoints.length - 1) {
                            this.stats.delta += currentValue;
                        }
                    }
                    else {
                        if (previousDeltaUp) {
                            this.stats.delta += currentValue - previousValue; // normal increment
                        }
                        else {
                            this.stats.delta += currentValue; // account for counter reset
                        }
                        previousDeltaUp = true;
                    }
                }
                previousValue = currentValue;
                if (currentValue < this.stats.logmin && currentValue > 0) {
                    this.stats.logmin = currentValue;
                }
                if (currentValue !== 0) {
                    this.allIsZero = false;
                }
            }
            result.push([currentTime, currentValue]);
        }
        if (this.stats.max === -Number.MAX_VALUE) {
            this.stats.max = null;
        }
        if (this.stats.min === Number.MAX_VALUE) {
            this.stats.min = null;
        }
        if (result.length && !this.allIsNull) {
            this.stats.avg = (this.stats.total / nonNulls);
            this.stats.current = result[result.length - 1][1];
            if (this.stats.current === null && result.length > 1) {
                this.stats.current = result[result.length - 2][1];
            }
        }
        if (this.stats.max !== null && this.stats.min !== null) {
            this.stats.range = this.stats.max - this.stats.min;
        }
        if (this.stats.current !== null && this.stats.first !== null) {
            this.stats.diff = this.stats.current - this.stats.first;
        }
        this.stats.count = result.length;
        return result;
    };
    TimeSeries.prototype.updateLegendValues = function (formater, decimals, scaledDecimals) {
        this.valueFormater = formater;
        this.decimals = decimals;
        this.scaledDecimals = scaledDecimals;
    };
    TimeSeries.prototype.formatValue = function (value) {
        if (!__WEBPACK_IMPORTED_MODULE_1_lodash___default.a.isFinite(value)) {
            value = null; // Prevent NaN formatting
        }
        return this.valueFormater(value, this.decimals, this.scaledDecimals);
    };
    TimeSeries.prototype.isMsResolutionNeeded = function () {
        for (var i = 0; i < this.datapoints.length; i++) {
            if (this.datapoints[i][1] !== null) {
                var timestamp = this.datapoints[i][1].toString();
                if (timestamp.length === 13 && (timestamp % 1000) !== 0) {
                    return true;
                }
            }
        }
        return false;
    };
    TimeSeries.prototype.hideFromLegend = function (options) {
        if (options.hideEmpty && this.allIsNull) {
            return true;
        }
        // ignore series excluded via override
        if (!this.legend) {
            return true;
        }
        // ignore zero series
        if (options.hideZero && this.allIsZero) {
            return true;
        }
        return false;
    };
    return TimeSeries;
}());
/* harmony default export */ __webpack_exports__["a"] = (TimeSeries);


/***/ }),

/***/ 1310:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
var TableModel = /** @class */ (function () {
    function TableModel() {
        this.columns = [];
        this.columnMap = {};
        this.rows = [];
        this.type = 'table';
    }
    TableModel.prototype.sort = function (options) {
        if (options.col === null || this.columns.length <= options.col) {
            return;
        }
        this.rows.sort(function (a, b) {
            a = a[options.col];
            b = b[options.col];
            if (a < b) {
                return -1;
            }
            if (a > b) {
                return 1;
            }
            return 0;
        });
        this.columns[options.col].sort = true;
        if (options.desc) {
            this.rows.reverse();
            this.columns[options.col].desc = true;
        }
        else {
            this.columns[options.col].desc = false;
        }
    };
    TableModel.prototype.addColumn = function (col) {
        if (!this.columnMap[col.text]) {
            this.columns.push(col);
            this.columnMap[col.text] = col;
        }
    };
    return TableModel;
}());
/* harmony default export */ __webpack_exports__["default"] = (TableModel);


/***/ }),

/***/ 1311:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "metricAggTypes", function() { return metricAggTypes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bucketAggTypes", function() { return bucketAggTypes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "orderByOptions", function() { return orderByOptions; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "orderOptions", function() { return orderOptions; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sizeOptions", function() { return sizeOptions; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extendedStats", function() { return extendedStats; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "intervalOptions", function() { return intervalOptions; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "movingAvgModelOptions", function() { return movingAvgModelOptions; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pipelineOptions", function() { return pipelineOptions; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "movingAvgModelSettings", function() { return movingAvgModelSettings; });
/* harmony export (immutable) */ __webpack_exports__["getMetricAggTypes"] = getMetricAggTypes;
/* harmony export (immutable) */ __webpack_exports__["getPipelineOptions"] = getPipelineOptions;
/* harmony export (immutable) */ __webpack_exports__["isPipelineAgg"] = isPipelineAgg;
/* harmony export (immutable) */ __webpack_exports__["getPipelineAggOptions"] = getPipelineAggOptions;
/* harmony export (immutable) */ __webpack_exports__["getMovingAvgSettings"] = getMovingAvgSettings;
/* harmony export (immutable) */ __webpack_exports__["getOrderByOptions"] = getOrderByOptions;
/* harmony export (immutable) */ __webpack_exports__["describeOrder"] = describeOrder;
/* harmony export (immutable) */ __webpack_exports__["describeMetric"] = describeMetric;
/* harmony export (immutable) */ __webpack_exports__["describeOrderBy"] = describeOrderBy;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_lodash__);
///<reference path="../../../headers/common.d.ts" />

var metricAggTypes = [
    { text: "Count", value: 'count', requiresField: false },
    { text: "Average", value: 'avg', requiresField: true, supportsInlineScript: true, supportsMissing: true },
    { text: "Sum", value: 'sum', requiresField: true, supportsInlineScript: true, supportsMissing: true },
    { text: "Max", value: 'max', requiresField: true, supportsInlineScript: true, supportsMissing: true },
    { text: "Min", value: 'min', requiresField: true, supportsInlineScript: true, supportsMissing: true },
    { text: "Extended Stats", value: 'extended_stats', requiresField: true, supportsMissing: true, supportsInlineScript: true },
    { text: "Percentiles", value: 'percentiles', requiresField: true, supportsMissing: true, supportsInlineScript: true },
    { text: "Unique Count", value: "cardinality", requiresField: true, supportsMissing: true },
    { text: "Moving Average", value: 'moving_avg', requiresField: false, isPipelineAgg: true, minVersion: 2 },
    { text: "Derivative", value: 'derivative', requiresField: false, isPipelineAgg: true, minVersion: 2 },
    { text: "Raw Document", value: "raw_document", requiresField: false }
];
var bucketAggTypes = [
    { text: "Terms", value: 'terms', requiresField: true },
    { text: "Filters", value: 'filters' },
    { text: "Geo Hash Grid", value: 'geohash_grid', requiresField: true },
    { text: "Date Histogram", value: 'date_histogram', requiresField: true },
    { text: "Histogram", value: 'histogram', requiresField: true },
];
var orderByOptions = [
    { text: "Doc Count", value: '_count' },
    { text: "Term value", value: '_term' },
];
var orderOptions = [
    { text: "Top", value: 'desc' },
    { text: "Bottom", value: 'asc' },
];
var sizeOptions = [
    { text: "No limit", value: '0' },
    { text: "1", value: '1' },
    { text: "2", value: '2' },
    { text: "3", value: '3' },
    { text: "5", value: '5' },
    { text: "10", value: '10' },
    { text: "15", value: '15' },
    { text: "20", value: '20' },
];
var extendedStats = [
    { text: 'Avg', value: 'avg' },
    { text: 'Min', value: 'min' },
    { text: 'Max', value: 'max' },
    { text: 'Sum', value: 'sum' },
    { text: 'Count', value: 'count' },
    { text: 'Std Dev', value: 'std_deviation' },
    { text: 'Std Dev Upper', value: 'std_deviation_bounds_upper' },
    { text: 'Std Dev Lower', value: 'std_deviation_bounds_lower' },
];
var intervalOptions = [
    { text: 'auto', value: 'auto' },
    { text: '10s', value: '10s' },
    { text: '1m', value: '1m' },
    { text: '5m', value: '5m' },
    { text: '10m', value: '10m' },
    { text: '20m', value: '20m' },
    { text: '1h', value: '1h' },
    { text: '1d', value: '1d' },
];
var movingAvgModelOptions = [
    { text: 'Simple', value: 'simple' },
    { text: 'Linear', value: 'linear' },
    { text: 'Exponentially Weighted', value: 'ewma' },
    { text: 'Holt Linear', value: 'holt' },
    { text: 'Holt Winters', value: 'holt_winters' },
];
var pipelineOptions = {
    'moving_avg': [
        { text: 'window', default: 5 },
        { text: 'model', default: 'simple' },
        { text: 'predict', default: undefined },
        { text: 'minimize', default: false },
    ],
    'derivative': [
        { text: 'unit', default: undefined },
    ]
};
var movingAvgModelSettings = {
    'simple': [],
    'linear': [],
    'ewma': [
        { text: "Alpha", value: "alpha", default: undefined }
    ],
    'holt': [
        { text: "Alpha", value: "alpha", default: undefined },
        { text: "Beta", value: "beta", default: undefined },
    ],
    'holt_winters': [
        { text: "Alpha", value: "alpha", default: undefined },
        { text: "Beta", value: "beta", default: undefined },
        { text: "Gamma", value: "gamma", default: undefined },
        { text: "Period", value: "period", default: undefined },
        { text: "Pad", value: "pad", default: undefined, isCheckbox: true },
    ],
};
function getMetricAggTypes(esVersion) {
    return __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.filter(metricAggTypes, function (f) {
        if (f.minVersion) {
            return f.minVersion <= esVersion;
        }
        else {
            return true;
        }
    });
}
function getPipelineOptions(metric) {
    if (!isPipelineAgg(metric.type)) {
        return [];
    }
    return pipelineOptions[metric.type];
}
function isPipelineAgg(metricType) {
    if (metricType) {
        var po = pipelineOptions[metricType];
        return po !== null && po !== undefined;
    }
    return false;
}
function getPipelineAggOptions(targets) {
    var result = [];
    __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.each(targets.metrics, function (metric) {
        if (!isPipelineAgg(metric.type)) {
            result.push({ text: describeMetric(metric), value: metric.id });
        }
    });
    return result;
}
function getMovingAvgSettings(model, filtered) {
    var filteredResult = [];
    if (filtered) {
        __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.each(movingAvgModelSettings[model], function (setting) {
            if (!(setting.isCheckbox)) {
                filteredResult.push(setting);
            }
        });
        return filteredResult;
    }
    return movingAvgModelSettings[model];
}
function getOrderByOptions(target) {
    var metricRefs = [];
    __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.each(target.metrics, function (metric) {
        if (metric.type !== 'count') {
            metricRefs.push({ text: describeMetric(metric), value: metric.id });
        }
    });
    return orderByOptions.concat(metricRefs);
}
function describeOrder(order) {
    var def = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.find(orderOptions, { value: order });
    return def.text;
}
function describeMetric(metric) {
    var def = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.find(metricAggTypes, { value: metric.type });
    return def.text + ' ' + metric.field;
}
function describeOrderBy(orderBy, target) {
    var def = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.find(orderByOptions, { value: orderBy });
    if (def) {
        return def.text;
    }
    var metric = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.find(target.metrics, { id: orderBy });
    if (metric) {
        return describeMetric(metric);
    }
    else {
        return "metric not found";
    }
}


/***/ }),

/***/ 1312:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ImpressionsStore", function() { return ImpressionsStore; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "impressions", function() { return impressions; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_app_core_store__ = __webpack_require__(206);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_lodash__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_app_core_config__ = __webpack_require__(27);



var ImpressionsStore = /** @class */ (function () {
    function ImpressionsStore() {
    }
    ImpressionsStore.prototype.addDashboardImpression = function (dashboardId) {
        var impressionsKey = this.impressionKey(__WEBPACK_IMPORTED_MODULE_2_app_core_config__["default"]);
        var impressions = [];
        if (__WEBPACK_IMPORTED_MODULE_0_app_core_store__["a" /* default */].exists(impressionsKey)) {
            impressions = JSON.parse(__WEBPACK_IMPORTED_MODULE_0_app_core_store__["a" /* default */].get(impressionsKey));
            if (!__WEBPACK_IMPORTED_MODULE_1_lodash___default.a.isArray(impressions)) {
                impressions = [];
            }
        }
        impressions = impressions.filter(function (imp) {
            return dashboardId !== imp;
        });
        impressions.unshift(dashboardId);
        if (impressions.length > 50) {
            impressions.pop();
        }
        __WEBPACK_IMPORTED_MODULE_0_app_core_store__["a" /* default */].set(impressionsKey, JSON.stringify(impressions));
    };
    ImpressionsStore.prototype.getDashboardOpened = function () {
        var impressions = __WEBPACK_IMPORTED_MODULE_0_app_core_store__["a" /* default */].get(this.impressionKey(__WEBPACK_IMPORTED_MODULE_2_app_core_config__["default"])) || "[]";
        impressions = JSON.parse(impressions);
        impressions = __WEBPACK_IMPORTED_MODULE_1_lodash___default.a.filter(impressions, function (el) {
            return __WEBPACK_IMPORTED_MODULE_1_lodash___default.a.isNumber(el);
        });
        return impressions;
    };
    ImpressionsStore.prototype.impressionKey = function (config) {
        return "dashboard_impressions-" + config.bootData.user.orgId;
    };
    return ImpressionsStore;
}());

var impressions = new ImpressionsStore();



/***/ }),

/***/ 1313:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return PanelCtrl; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_app_core_config__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_lodash__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_jquery__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_jquery___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_jquery__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_app_core_profiler__ = __webpack_require__(475);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_remarkable__ = __webpack_require__(469);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_remarkable___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_remarkable__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_app_core_core__ = __webpack_require__(465);





var TITLE_HEIGHT = 25;
var EMPTY_TITLE_HEIGHT = 9;
var PANEL_PADDING = 5;
var PANEL_BORDER = 2;

var PanelCtrl = /** @class */ (function () {
    function PanelCtrl($scope, $injector) {
        var _this = this;
        this.$injector = $injector;
        this.$scope = $scope;
        this.$timeout = $injector.get('$timeout');
        this.editorTabIndex = 0;
        this.events = new __WEBPACK_IMPORTED_MODULE_5_app_core_core__["Emitter"]();
        this.timing = {};
        var plugin = __WEBPACK_IMPORTED_MODULE_0_app_core_config__["default"].panels[this.panel.type];
        if (plugin) {
            this.pluginId = plugin.id;
            this.pluginName = plugin.name;
        }
        $scope.$on("refresh", function () { return _this.refresh(); });
        $scope.$on("render", function () { return _this.render(); });
        $scope.$on("$destroy", function () {
            _this.events.emit('panel-teardown');
            _this.events.removeAllListeners();
        });
        // we should do something interesting
        // with newly added panels
        if (this.panel.isNew) {
            delete this.panel.isNew;
        }
    }
    PanelCtrl.prototype.init = function () {
        this.calculatePanelHeight();
        this.publishAppEvent('panel-initialized', { scope: this.$scope });
        this.events.emit('panel-initialized');
    };
    PanelCtrl.prototype.renderingCompleted = function () {
        __WEBPACK_IMPORTED_MODULE_3_app_core_profiler__["a" /* profiler */].renderingCompleted(this.panel.id, this.timing);
    };
    PanelCtrl.prototype.refresh = function () {
        this.events.emit('refresh', null);
    };
    PanelCtrl.prototype.publishAppEvent = function (evtName, evt) {
        this.$scope.$root.appEvent(evtName, evt);
    };
    PanelCtrl.prototype.changeView = function (fullscreen, edit) {
        this.publishAppEvent('panel-change-view', {
            fullscreen: fullscreen, edit: edit, panelId: this.panel.id
        });
    };
    PanelCtrl.prototype.viewPanel = function () {
        this.changeView(true, false);
    };
    PanelCtrl.prototype.editPanel = function () {
        this.changeView(true, true);
    };
    PanelCtrl.prototype.exitFullscreen = function () {
        this.changeView(false, false);
    };
    PanelCtrl.prototype.initEditMode = function () {
        var _this = this;
        this.editorTabs = [];
        this.addEditorTab('General', 'public/app/partials/panelgeneral.html');
        this.editModeInitiated = true;
        this.events.emit('init-edit-mode', null);
        var urlTab = (this.$injector.get('$routeParams').tab || '').toLowerCase();
        if (urlTab) {
            this.editorTabs.forEach(function (tab, i) {
                if (tab.title.toLowerCase() === urlTab) {
                    _this.editorTabIndex = i;
                }
            });
        }
    };
    PanelCtrl.prototype.changeTab = function (newIndex) {
        this.editorTabIndex = newIndex;
        var route = this.$injector.get('$route');
        route.current.params.tab = this.editorTabs[newIndex].title.toLowerCase();
        route.updateParams();
    };
    PanelCtrl.prototype.addEditorTab = function (title, directiveFn, index) {
        var editorTab = { title: title, directiveFn: directiveFn };
        if (__WEBPACK_IMPORTED_MODULE_1_lodash___default.a.isString(directiveFn)) {
            editorTab.directiveFn = function () {
                return { templateUrl: directiveFn };
            };
        }
        if (index) {
            this.editorTabs.splice(index, 0, editorTab);
        }
        else {
            this.editorTabs.push(editorTab);
        }
    };
    PanelCtrl.prototype.getMenu = function () {
        var menu = [];
        menu.push({ text: 'View', click: 'ctrl.viewPanel(); dismiss();' });
        menu.push({ text: 'Edit', click: 'ctrl.editPanel(); dismiss();', role: 'Editor' });
        if (!this.fullscreen) {
            menu.push({ text: 'Duplicate', click: 'ctrl.duplicate()', role: 'Editor' });
        }
        menu.push({ text: 'Share', click: 'ctrl.sharePanel(); dismiss();' });
        return menu;
    };
    PanelCtrl.prototype.getExtendedMenu = function () {
        var actions = [{ text: 'Panel JSON', click: 'ctrl.editPanelJson(); dismiss();' }];
        this.events.emit('init-panel-actions', actions);
        return actions;
    };
    PanelCtrl.prototype.otherPanelInFullscreenMode = function () {
        return this.dashboard.meta.fullscreen && !this.fullscreen;
    };
    PanelCtrl.prototype.calculatePanelHeight = function () {
        if (this.fullscreen) {
            var docHeight = __WEBPACK_IMPORTED_MODULE_2_jquery___default()(window).height();
            var editHeight = Math.floor(docHeight * 0.4);
            var fullscreenHeight = Math.floor(docHeight * 0.8);
            this.containerHeight = this.editMode ? editHeight : fullscreenHeight;
        }
        else {
            this.containerHeight = this.panel.height || this.row.height;
            if (__WEBPACK_IMPORTED_MODULE_1_lodash___default.a.isString(this.containerHeight)) {
                this.containerHeight = parseInt(this.containerHeight.replace('px', ''), 10);
            }
        }
        this.height = this.containerHeight - (PANEL_BORDER + PANEL_PADDING + (this.panel.title ? TITLE_HEIGHT : EMPTY_TITLE_HEIGHT));
    };
    PanelCtrl.prototype.render = function (payload) {
        // ignore if other panel is in fullscreen mode
        if (this.otherPanelInFullscreenMode()) {
            return;
        }
        this.calculatePanelHeight();
        this.timing.renderStart = new Date().getTime();
        this.events.emit('render', payload);
    };
    PanelCtrl.prototype.duplicate = function () {
        var _this = this;
        this.dashboard.duplicatePanel(this.panel, this.row);
        this.$timeout(function () {
            _this.$scope.$root.$broadcast('render');
        });
    };
    PanelCtrl.prototype.updateColumnSpan = function (span) {
        var _this = this;
        this.panel.span = Math.min(Math.max(Math.floor(this.panel.span + span), 1), 12);
        this.row.panelSpanChanged();
        this.$timeout(function () {
            _this.render();
        });
    };
    PanelCtrl.prototype.removePanel = function () {
        this.row.removePanel(this.panel);
    };
    PanelCtrl.prototype.editPanelJson = function () {
        this.publishAppEvent('show-json-editor', {
            object: this.panel,
            updateHandler: this.replacePanel.bind(this)
        });
    };
    PanelCtrl.prototype.replacePanel = function (newPanel, oldPanel) {
        var _this = this;
        var index = __WEBPACK_IMPORTED_MODULE_1_lodash___default.a.indexOf(this.row.panels, oldPanel);
        this.row.panels.splice(index, 1);
        // adding it back needs to be done in next digest
        this.$timeout(function () {
            newPanel.id = oldPanel.id;
            newPanel.span = oldPanel.span;
            _this.row.panels.splice(index, 0, newPanel);
        });
    };
    PanelCtrl.prototype.sharePanel = function () {
        var shareScope = this.$scope.$new();
        shareScope.panel = this.panel;
        shareScope.dashboard = this.dashboard;
        this.publishAppEvent('show-modal', {
            src: 'public/app/features/dashboard/partials/shareModal.html',
            scope: shareScope
        });
    };
    PanelCtrl.prototype.getInfoMode = function () {
        if (this.error) {
            return 'error';
        }
        if (!!this.panel.description) {
            return 'info';
        }
        if (this.panel.links && this.panel.links.length) {
            return 'links';
        }
        return '';
    };
    PanelCtrl.prototype.getInfoContent = function (options) {
        var markdown = this.panel.description;
        if (options.mode === 'tooltip') {
            markdown = this.error || this.panel.description;
        }
        var linkSrv = this.$injector.get('linkSrv');
        var templateSrv = this.$injector.get('templateSrv');
        var interpolatedMarkdown = templateSrv.replace(markdown, this.panel.scopedVars);
        var html = '<div class="markdown-html">';
        html += new __WEBPACK_IMPORTED_MODULE_4_remarkable___default.a().render(interpolatedMarkdown);
        if (this.panel.links && this.panel.links.length > 0) {
            html += '<ul>';
            for (var _i = 0, _a = this.panel.links; _i < _a.length; _i++) {
                var link = _a[_i];
                var info = linkSrv.getPanelLinkAnchorInfo(link, this.panel.scopedVars);
                html += '<li><a class="panel-menu-link" href="' + info.href + '" target="' + info.target + '">' + info.title + '</a></li>';
            }
            html += '</ul>';
        }
        return html + '</div>';
    };
    PanelCtrl.prototype.openInspector = function () {
        var modalScope = this.$scope.$new();
        modalScope.panel = this.panel;
        modalScope.dashboard = this.dashboard;
        modalScope.panelInfoHtml = this.getInfoContent({ mode: 'inspector' });
        modalScope.inspector = __WEBPACK_IMPORTED_MODULE_2_jquery___default.a.extend(true, {}, this.inspector);
        this.publishAppEvent('show-modal', {
            src: 'public/app/features/dashboard/partials/inspector.html',
            scope: modalScope
        });
    };
    return PanelCtrl;
}());



/***/ }),

/***/ 1314:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (immutable) */ __webpack_exports__["tickStep"] = tickStep;
/* harmony export (immutable) */ __webpack_exports__["getScaledDecimals"] = getScaledDecimals;
/* harmony export (immutable) */ __webpack_exports__["getFlotTickSize"] = getFlotTickSize;
/**
 * Calculate tick step.
 * Implementation from d3-array (ticks.js)
 * https://github.com/d3/d3-array/blob/master/src/ticks.js
 * @param start Start value
 * @param stop End value
 * @param count Ticks count
 */
function tickStep(start, stop, count) {
    var e10 = Math.sqrt(50), e5 = Math.sqrt(10), e2 = Math.sqrt(2);
    var step0 = Math.abs(stop - start) / Math.max(0, count), step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)), error = step0 / step1;
    if (error >= e10) {
        step1 *= 10;
    }
    else if (error >= e5) {
        step1 *= 5;
    }
    else if (error >= e2) {
        step1 *= 2;
    }
    return stop < start ? -step1 : step1;
}
function getScaledDecimals(decimals, tick_size) {
    return decimals - Math.floor(Math.log(tick_size) / Math.LN10);
}
/**
 * Calculate tick size based on min and max values, number of ticks and precision.
 * @param min           Axis minimum
 * @param max           Axis maximum
 * @param noTicks       Number of ticks
 * @param tickDecimals  Tick decimal precision
 */
function getFlotTickSize(min, max, noTicks, tickDecimals) {
    var delta = (max - min) / noTicks, dec = -Math.floor(Math.log(delta) / Math.LN10), maxDec = tickDecimals;
    var magn = Math.pow(10, -dec), norm = delta / magn, // norm is between 1.0 and 10.0
    size;
    if (norm < 1.5) {
        size = 1;
    }
    else if (norm < 3) {
        size = 2;
        // special case for 2.5, requires an extra decimal
        if (norm > 2.25 && (maxDec == null || dec + 1 <= maxDec)) {
            size = 2.5;
            ++dec;
        }
    }
    else if (norm < 7.5) {
        size = 5;
    }
    else {
        size = 10;
    }
    size *= magn;
    return size;
}


/***/ }),

/***/ 1315:
/***/ (function(module, exports) {

/* Javascript plotting library for jQuery, version 0.8.3.

Copyright (c) 2007-2014 IOLA and Ole Laursen.
Licensed under the MIT license.

*/

// first an inline dependency, jquery.colorhelpers.js, we inline it here
// for convenience

/* Plugin for jQuery for working with colors.
 *
 * Version 1.1.
 *
 * Inspiration from jQuery color animation plugin by John Resig.
 *
 * Released under the MIT license by Ole Laursen, October 2009.
 *
 * Examples:
 *
 *   $.color.parse("#fff").scale('rgb', 0.25).add('a', -0.5).toString()
 *   var c = $.color.extract($("#mydiv"), 'background-color');
 *   console.log(c.r, c.g, c.b, c.a);
 *   $.color.make(100, 50, 25, 0.4).toString() // returns "rgba(100,50,25,0.4)"
 *
 * Note that .scale() and .add() return the same modified object
 * instead of making a new one.
 *
 * V. 1.1: Fix error handling so e.g. parsing an empty string does
 * produce a color rather than just crashing.
 */
(function($){$.color={};$.color.make=function(r,g,b,a){var o={};o.r=r||0;o.g=g||0;o.b=b||0;o.a=a!=null?a:1;o.add=function(c,d){for(var i=0;i<c.length;++i)o[c.charAt(i)]+=d;return o.normalize()};o.scale=function(c,f){for(var i=0;i<c.length;++i)o[c.charAt(i)]*=f;return o.normalize()};o.toString=function(){if(o.a>=1){return"rgb("+[o.r,o.g,o.b].join(",")+")"}else{return"rgba("+[o.r,o.g,o.b,o.a].join(",")+")"}};o.normalize=function(){function clamp(min,value,max){return value<min?min:value>max?max:value}o.r=clamp(0,parseInt(o.r),255);o.g=clamp(0,parseInt(o.g),255);o.b=clamp(0,parseInt(o.b),255);o.a=clamp(0,o.a,1);return o};o.clone=function(){return $.color.make(o.r,o.b,o.g,o.a)};return o.normalize()};$.color.extract=function(elem,css){var c;do{c=elem.css(css).toLowerCase();if(c!=""&&c!="transparent")break;elem=elem.parent()}while(elem.length&&!$.nodeName(elem.get(0),"body"));if(c=="rgba(0, 0, 0, 0)")c="transparent";return $.color.parse(c)};$.color.parse=function(str){var res,m=$.color.make;if(res=/rgb\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*\)/.exec(str))return m(parseInt(res[1],10),parseInt(res[2],10),parseInt(res[3],10));if(res=/rgba\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]+(?:\.[0-9]+)?)\s*\)/.exec(str))return m(parseInt(res[1],10),parseInt(res[2],10),parseInt(res[3],10),parseFloat(res[4]));if(res=/rgb\(\s*([0-9]+(?:\.[0-9]+)?)\%\s*,\s*([0-9]+(?:\.[0-9]+)?)\%\s*,\s*([0-9]+(?:\.[0-9]+)?)\%\s*\)/.exec(str))return m(parseFloat(res[1])*2.55,parseFloat(res[2])*2.55,parseFloat(res[3])*2.55);if(res=/rgba\(\s*([0-9]+(?:\.[0-9]+)?)\%\s*,\s*([0-9]+(?:\.[0-9]+)?)\%\s*,\s*([0-9]+(?:\.[0-9]+)?)\%\s*,\s*([0-9]+(?:\.[0-9]+)?)\s*\)/.exec(str))return m(parseFloat(res[1])*2.55,parseFloat(res[2])*2.55,parseFloat(res[3])*2.55,parseFloat(res[4]));if(res=/#([a-fA-F0-9]{2})([a-fA-F0-9]{2})([a-fA-F0-9]{2})/.exec(str))return m(parseInt(res[1],16),parseInt(res[2],16),parseInt(res[3],16));if(res=/#([a-fA-F0-9])([a-fA-F0-9])([a-fA-F0-9])/.exec(str))return m(parseInt(res[1]+res[1],16),parseInt(res[2]+res[2],16),parseInt(res[3]+res[3],16));var name=$.trim(str).toLowerCase();if(name=="transparent")return m(255,255,255,0);else{res=lookupColors[name]||[0,0,0];return m(res[0],res[1],res[2])}};var lookupColors={aqua:[0,255,255],azure:[240,255,255],beige:[245,245,220],black:[0,0,0],blue:[0,0,255],brown:[165,42,42],cyan:[0,255,255],darkblue:[0,0,139],darkcyan:[0,139,139],darkgrey:[169,169,169],darkgreen:[0,100,0],darkkhaki:[189,183,107],darkmagenta:[139,0,139],darkolivegreen:[85,107,47],darkorange:[255,140,0],darkorchid:[153,50,204],darkred:[139,0,0],darksalmon:[233,150,122],darkviolet:[148,0,211],fuchsia:[255,0,255],gold:[255,215,0],green:[0,128,0],indigo:[75,0,130],khaki:[240,230,140],lightblue:[173,216,230],lightcyan:[224,255,255],lightgreen:[144,238,144],lightgrey:[211,211,211],lightpink:[255,182,193],lightyellow:[255,255,224],lime:[0,255,0],magenta:[255,0,255],maroon:[128,0,0],navy:[0,0,128],olive:[128,128,0],orange:[255,165,0],pink:[255,192,203],purple:[128,0,128],violet:[128,0,128],red:[255,0,0],silver:[192,192,192],white:[255,255,255],yellow:[255,255,0]}})(jQuery);

// the actual Flot code
(function($) {

	// Cache the prototype hasOwnProperty for faster access

	var hasOwnProperty = Object.prototype.hasOwnProperty;

    // A shim to provide 'detach' to jQuery versions prior to 1.4.  Using a DOM
    // operation produces the same effect as detach, i.e. removing the element
    // without touching its jQuery data.

    // Do not merge this into Flot 0.9, since it requires jQuery 1.4.4+.

    if (!$.fn.detach) {
        $.fn.detach = function() {
            return this.each(function() {
                if (this.parentNode) {
                    this.parentNode.removeChild( this );
                }
            });
        };
    }

	///////////////////////////////////////////////////////////////////////////
	// The Canvas object is a wrapper around an HTML5 <canvas> tag.
	//
	// @constructor
	// @param {string} cls List of classes to apply to the canvas.
	// @param {element} container Element onto which to append the canvas.
	//
	// Requiring a container is a little iffy, but unfortunately canvas
	// operations don't work unless the canvas is attached to the DOM.

	function Canvas(cls, container) {

		var element = container.children("." + cls)[0];

		if (element == null) {

			element = document.createElement("canvas");
			element.className = cls;

			$(element).css({ direction: "ltr", position: "absolute", left: 0, top: 0 })
				.appendTo(container);

			// If HTML5 Canvas isn't available, fall back to [Ex|Flash]canvas

			if (!element.getContext) {
				if (window.G_vmlCanvasManager) {
					element = window.G_vmlCanvasManager.initElement(element);
				} else {
					throw new Error("Canvas is not available. If you're using IE with a fall-back such as Excanvas, then there's either a mistake in your conditional include, or the page has no DOCTYPE and is rendering in Quirks Mode.");
				}
			}
		}

		this.element = element;

		var context = this.context = element.getContext("2d");

		// Determine the screen's ratio of physical to device-independent
		// pixels.  This is the ratio between the canvas width that the browser
		// advertises and the number of pixels actually present in that space.

		// The iPhone 4, for example, has a device-independent width of 320px,
		// but its screen is actually 640px wide.  It therefore has a pixel
		// ratio of 2, while most normal devices have a ratio of 1.

		var devicePixelRatio = window.devicePixelRatio || 1,
			backingStoreRatio =
				context.webkitBackingStorePixelRatio ||
				context.mozBackingStorePixelRatio ||
				context.msBackingStorePixelRatio ||
				context.oBackingStorePixelRatio ||
				context.backingStorePixelRatio || 1;

		this.pixelRatio = devicePixelRatio / backingStoreRatio;

		// Size the canvas to match the internal dimensions of its container

		this.resize(container.width(), container.height());

		// Collection of HTML div layers for text overlaid onto the canvas

		this.textContainer = null;
		this.text = {};

		// Cache of text fragments and metrics, so we can avoid expensively
		// re-calculating them when the plot is re-rendered in a loop.

		this._textCache = {};
		this._textSizeCache = window.flotTextSizeCache = window.flotTextSizeCache || {};
	}

	// Resizes the canvas to the given dimensions.
	//
	// @param {number} width New width of the canvas, in pixels.
	// @param {number} width New height of the canvas, in pixels.

	Canvas.prototype.resize = function(width, height) {

		if (width <= 0 || height <= 0) {
			throw new Error("Invalid dimensions for plot, width = " + width + ", height = " + height);
		}

		var element = this.element,
			context = this.context,
			pixelRatio = this.pixelRatio;

		// Resize the canvas, increasing its density based on the display's
		// pixel ratio; basically giving it more pixels without increasing the
		// size of its element, to take advantage of the fact that retina
		// displays have that many more pixels in the same advertised space.

		// Resizing should reset the state (excanvas seems to be buggy though)

		if (this.width != width) {
			element.width = width * pixelRatio;
			element.style.width = width + "px";
			this.width = width;
		}

		if (this.height != height) {
			element.height = height * pixelRatio;
			element.style.height = height + "px";
			this.height = height;
		}

		// Save the context, so we can reset in case we get replotted.  The
		// restore ensure that we're really back at the initial state, and
		// should be safe even if we haven't saved the initial state yet.

		context.restore();
		context.save();

		// Scale the coordinate space to match the display density; so even though we
		// may have twice as many pixels, we still want lines and other drawing to
		// appear at the same size; the extra pixels will just make them crisper.

		context.scale(pixelRatio, pixelRatio);
	};

	// Clears the entire canvas area, not including any overlaid HTML text

	Canvas.prototype.clear = function() {
		this.context.clearRect(0, 0, this.width, this.height);
	};

	// Finishes rendering the canvas, including managing the text overlay.

	Canvas.prototype.render = function() {

		var cache = this._textCache;

		// For each text layer, add elements marked as active that haven't
		// already been rendered, and remove those that are no longer active.

		for (var layerKey in cache) {
			if (hasOwnProperty.call(cache, layerKey)) {

				var layer = this.getTextLayer(layerKey),
					layerCache = cache[layerKey];

				layer.hide();

				for (var styleKey in layerCache) {
					if (hasOwnProperty.call(layerCache, styleKey)) {
						var styleCache = layerCache[styleKey];
						for (var key in styleCache) {
							if (hasOwnProperty.call(styleCache, key)) {

								var positions = styleCache[key].positions;

								for (var i = 0, position; position = positions[i]; i++) {
									if (position.active) {
										if (!position.rendered) {
											layer.append(position.element);
											position.rendered = true;
										}
									} else {
										positions.splice(i--, 1);
										if (position.rendered) {
											position.element.detach();
										}
									}
								}

								if (positions.length == 0) {
									delete styleCache[key];
								}
							}
						}
					}
				}

				layer.show();
			}
		}
	};

	// Creates (if necessary) and returns the text overlay container.
	//
	// @param {string} classes String of space-separated CSS classes used to
	//     uniquely identify the text layer.
	// @return {object} The jQuery-wrapped text-layer div.

	Canvas.prototype.getTextLayer = function(classes) {

		var layer = this.text[classes];

		// Create the text layer if it doesn't exist

		if (layer == null) {

			// Create the text layer container, if it doesn't exist

			if (this.textContainer == null) {
				this.textContainer = $("<div class='flot-text flot-temp-elem'></div>")
					.css({
						position: "absolute",
						top: 0,
						left: 0,
						bottom: 0,
						right: 0,
						'font-size': "smaller",
						color: "#545454"
					})
					.insertAfter(this.element);
			}

			layer = this.text[classes] = $("<div></div>")
				.addClass(classes)
				.css({
					position: "absolute",
					top: 0,
					left: 0,
					bottom: 0,
					right: 0
				})
				.appendTo(this.textContainer);
		}

		return layer;
	};

	// Creates (if necessary) and returns a text info object.
	//
	// The object looks like this:
	//
	// {
	//     width: Width of the text's wrapper div.
	//     height: Height of the text's wrapper div.
	//     element: The jQuery-wrapped HTML div containing the text.
	//     positions: Array of positions at which this text is drawn.
	// }
	//
	// The positions array contains objects that look like this:
	//
	// {
	//     active: Flag indicating whether the text should be visible.
	//     rendered: Flag indicating whether the text is currently visible.
	//     element: The jQuery-wrapped HTML div containing the text.
	//     x: X coordinate at which to draw the text.
	//     y: Y coordinate at which to draw the text.
	// }
	//
	// Each position after the first receives a clone of the original element.
	//
	// The idea is that that the width, height, and general 'identity' of the
	// text is constant no matter where it is placed; the placements are a
	// secondary property.
	//
	// Canvas maintains a cache of recently-used text info objects; getTextInfo
	// either returns the cached element or creates a new entry.
	//
	// @param {string} layer A string of space-separated CSS classes uniquely
	//     identifying the layer containing this text.
	// @param {string} text Text string to retrieve info for.
	// @param {(string|object)=} font Either a string of space-separated CSS
	//     classes or a font-spec object, defining the text's font and style.
	// @param {number=} angle Angle at which to rotate the text, in degrees.
	//     Angle is currently unused, it will be implemented in the future.
	// @param {number=} width Maximum width of the text before it wraps.
	// @return {object} a text info object.

	Canvas.prototype.getTextInfo = function(layer, text, font, angle, width) {

		var textStyle, layerCache, styleCache, info;

		// Cast the value to a string, in case we were given a number or such

		text = "" + text;

		// If the font is a font-spec object, generate a CSS font definition

		if (typeof font === "object") {
			textStyle = font.style + " " + font.variant + " " + font.weight + " " + font.size + "px/" + font.lineHeight + "px " + font.family;
		} else {
			textStyle = font;
		}

		// Retrieve (or create) the cache for the text's layer and styles

		layerCache = this._textCache[layer];

		if (layerCache == null) {
			layerCache = this._textCache[layer] = {};
		}

		styleCache = layerCache[textStyle];

		if (styleCache == null) {
			styleCache = layerCache[textStyle] = {};
		}

		info = styleCache[text];

		// If we can't find a matching element in our cache, create a new one

		if (info == null) {

			var element = $("<div></div>").html(text)
				.css({
					position: "absolute",
					'max-width': width,
					top: -9999
				})
				.appendTo(this.getTextLayer(layer));

			if (typeof font === "object") {
				element.css({
					font: textStyle,
					color: font.color
				});
			} else if (typeof font === "string") {
				element.addClass(font);
			}

      info = styleCache[text] = { element: element, positions: [] };

      var size = this._textSizeCache[text];
			if (size) {
        info.width = size.width;
        info.height = size.height;
			} else {
        info.width = element.outerWidth(true);
        info.height = element.outerHeight(true);
        this._textSizeCache[text] = { width: info.width, height: info.height };
			}
			element.detach();
		}

		return info;
	};

	// Adds a text string to the canvas text overlay.
	//
	// The text isn't drawn immediately; it is marked as rendering, which will
	// result in its addition to the canvas on the next render pass.
	//
	// @param {string} layer A string of space-separated CSS classes uniquely
	//     identifying the layer containing this text.
	// @param {number} x X coordinate at which to draw the text.
	// @param {number} y Y coordinate at which to draw the text.
	// @param {string} text Text string to draw.
	// @param {(string|object)=} font Either a string of space-separated CSS
	//     classes or a font-spec object, defining the text's font and style.
	// @param {number=} angle Angle at which to rotate the text, in degrees.
	//     Angle is currently unused, it will be implemented in the future.
	// @param {number=} width Maximum width of the text before it wraps.
	// @param {string=} halign Horizontal alignment of the text; either "left",
	//     "center" or "right".
	// @param {string=} valign Vertical alignment of the text; either "top",
	//     "middle" or "bottom".

	Canvas.prototype.addText = function(layer, x, y, text, font, angle, width, halign, valign) {

		var info = this.getTextInfo(layer, text, font, angle, width),
			positions = info.positions;

		// Tweak the div's position to match the text's alignment

		if (halign == "center") {
			x -= info.width / 2;
		} else if (halign == "right") {
			x -= info.width;
		}

		if (valign == "middle") {
			y -= info.height / 2;
		} else if (valign == "bottom") {
			y -= info.height;
		}

		// Determine whether this text already exists at this position.
		// If so, mark it for inclusion in the next render pass.

		for (var i = 0, position; position = positions[i]; i++) {
			if (position.x == x && position.y == y) {
				position.active = true;
				return;
			}
		}

		// If the text doesn't exist at this position, create a new entry

		// For the very first position we'll re-use the original element,
		// while for subsequent ones we'll clone it.

		position = {
			active: true,
			rendered: false,
			element: positions.length ? info.element.clone() : info.element,
			x: x,
			y: y
		};

		positions.push(position);

		// Move the element to its final position within the container

		position.element.css({
			top: Math.round(y),
			left: Math.round(x),
			'text-align': halign	// In case the text wraps
		});
	};

	// Removes one or more text strings from the canvas text overlay.
	//
	// If no parameters are given, all text within the layer is removed.
	//
	// Note that the text is not immediately removed; it is simply marked as
	// inactive, which will result in its removal on the next render pass.
	// This avoids the performance penalty for 'clear and redraw' behavior,
	// where we potentially get rid of all text on a layer, but will likely
	// add back most or all of it later, as when redrawing axes, for example.
	//
	// @param {string} layer A string of space-separated CSS classes uniquely
	//     identifying the layer containing this text.
	// @param {number=} x X coordinate of the text.
	// @param {number=} y Y coordinate of the text.
	// @param {string=} text Text string to remove.
	// @param {(string|object)=} font Either a string of space-separated CSS
	//     classes or a font-spec object, defining the text's font and style.
	// @param {number=} angle Angle at which the text is rotated, in degrees.
	//     Angle is currently unused, it will be implemented in the future.

	Canvas.prototype.removeText = function(layer, x, y, text, font, angle) {
		if (text == null) {
			var layerCache = this._textCache[layer];
			if (layerCache != null) {
				for (var styleKey in layerCache) {
					if (hasOwnProperty.call(layerCache, styleKey)) {
						var styleCache = layerCache[styleKey];
						for (var key in styleCache) {
							if (hasOwnProperty.call(styleCache, key)) {
								var positions = styleCache[key].positions;
								for (var i = 0, position; position = positions[i]; i++) {
									position.active = false;
								}
							}
						}
					}
				}
			}
		} else {
			var positions = this.getTextInfo(layer, text, font, angle).positions;
			for (var i = 0, position; position = positions[i]; i++) {
				if (position.x == x && position.y == y) {
					position.active = false;
				}
			}
		}
	};

	///////////////////////////////////////////////////////////////////////////
	// The top-level container for the entire plot.

    function Plot(placeholder, data_, options_, plugins) {
        // data is on the form:
        //   [ series1, series2 ... ]
        // where series is either just the data as [ [x1, y1], [x2, y2], ... ]
        // or { data: [ [x1, y1], [x2, y2], ... ], label: "some label", ... }

        var series = [],
            options = {
                // the color theme used for graphs
                colors: ["#edc240", "#afd8f8", "#cb4b4b", "#4da74d", "#9440ed"],
                legend: {
                    show: true,
                    noColumns: 1, // number of colums in legend table
                    labelFormatter: null, // fn: string -> string
                    labelBoxBorderColor: "#ccc", // border color for the little label boxes
                    container: null, // container (as jQuery object) to put legend in, null means default on top of graph
                    position: "ne", // position of default legend container within plot
                    margin: 5, // distance from grid edge to default legend container within plot
                    backgroundColor: null, // null means auto-detect
                    backgroundOpacity: 0.85, // set to 0 to avoid background
                    sorted: null    // default to no legend sorting
                },
                xaxis: {
                    show: null, // null = auto-detect, true = always, false = never
                    position: "bottom", // or "top"
                    mode: null, // null or "time"
                    font: null, // null (derived from CSS in placeholder) or object like { size: 11, lineHeight: 13, style: "italic", weight: "bold", family: "sans-serif", variant: "small-caps" }
                    color: null, // base color, labels, ticks
                    tickColor: null, // possibly different color of ticks, e.g. "rgba(0,0,0,0.15)"
                    transform: null, // null or f: number -> number to transform axis
                    inverseTransform: null, // if transform is set, this should be the inverse function
                    min: null, // min. value to show, null means set automatically
                    max: null, // max. value to show, null means set automatically
                    autoscaleMargin: null, // margin in % to add if auto-setting min/max
                    ticks: null, // either [1, 3] or [[1, "a"], 3] or (fn: axis info -> ticks) or app. number of ticks for auto-ticks
                    tickFormatter: null, // fn: number -> string
                    labelWidth: null, // size of tick labels in pixels
                    labelHeight: null,
                    reserveSpace: null, // whether to reserve space even if axis isn't shown
                    tickLength: null, // size in pixels of ticks, or "full" for whole line
                    alignTicksWithAxis: null, // axis number or null for no sync
                    tickDecimals: null, // no. of decimals, null means auto
                    tickSize: null, // number or [number, "unit"]
                    minTickSize: null // number or [number, "unit"]
                },
                yaxis: {
                    autoscaleMargin: 0.02,
                    position: "left" // or "right"
                },
                xaxes: [],
                yaxes: [],
                series: {
                    points: {
                        show: false,
                        radius: 3,
                        lineWidth: 2, // in pixels
                        fill: true,
                        fillColor: "#ffffff",
                        symbol: "circle" // or callback
                    },
                    lines: {
                        // we don't put in show: false so we can see
                        // whether lines were actively disabled
                        lineWidth: 2, // in pixels
                        fill: false,
                        fillColor: null,
                        steps: false
                        // Omit 'zero', so we can later default its value to
                        // match that of the 'fill' option.
                    },
                    bars: {
                        show: false,
                        lineWidth: 2, // in pixels
                        barWidth: 1, // in units of the x axis
                        fill: true,
                        fillColor: null,
                        align: "left", // "left", "right", or "center"
                        horizontal: false,
                        zero: true
                    },
                    shadowSize: 3,
                    highlightColor: null
                },
                grid: {
                    show: true,
                    aboveData: false,
                    color: "#545454", // primary color used for outline and labels
                    backgroundColor: null, // null for transparent, else color
                    borderColor: null, // set if different from the grid color
                    tickColor: null, // color for the ticks, e.g. "rgba(0,0,0,0.15)"
                    margin: 0, // distance from the canvas edge to the grid
                    labelMargin: 5, // in pixels
                    eventSectionHeight: 0, // space for event section
                    axisMargin: 8, // in pixels
                    borderWidth: 2, // in pixels
                    minBorderMargin: null, // in pixels, null means taken from points radius
                    markings: null, // array of ranges or fn: axes -> array of ranges
                    markingsColor: "#f4f4f4",
                    markingsLineWidth: 2,
                    // interactive stuff
                    clickable: false,
                    hoverable: false,
                    autoHighlight: true, // highlight in case mouse is near
                    mouseActiveRadius: 10 // how far the mouse can be away to activate an item
                },
                interaction: {
                    redrawOverlayInterval: 1000/60 // time between updates, -1 means in same flow
                },
                hooks: {}
            },
        surface = null,     // the canvas for the plot itself
        overlay = null,     // canvas for interactive stuff on top of plot
        eventHolder = null, // jQuery object that events should be bound to
        ctx = null, octx = null,
        xaxes = [], yaxes = [],
        plotOffset = { left: 0, right: 0, top: 0, bottom: 0},
        plotWidth = 0, plotHeight = 0,
        hooks = {
            processOptions: [],
            processRawData: [],
            processDatapoints: [],
            processOffset: [],
            drawBackground: [],
            drawSeries: [],
            draw: [],
            bindEvents: [],
            drawOverlay: [],
            shutdown: []
        },
        plot = this;

        // public functions
        plot.setData = setData;
        plot.setupGrid = setupGrid;
        plot.draw = draw;
        plot.getPlaceholder = function() { return placeholder; };
        plot.getCanvas = function() { return surface.element; };
        plot.getPlotOffset = function() { return plotOffset; };
        plot.width = function () { return plotWidth; };
        plot.height = function () { return plotHeight; };
        plot.offset = function () {
            var o = eventHolder.offset();
            o.left += plotOffset.left;
            o.top += plotOffset.top;
            return o;
        };
        plot.getData = function () { return series; };
        plot.getAxes = function () {
            var res = {}, i;
            $.each(xaxes.concat(yaxes), function (_, axis) {
                if (axis)
                    res[axis.direction + (axis.n != 1 ? axis.n : "") + "axis"] = axis;
            });
            return res;
        };
        plot.getXAxes = function () { return xaxes; };
        plot.getYAxes = function () { return yaxes; };
        plot.c2p = canvasToAxisCoords;
        plot.p2c = axisToCanvasCoords;
        plot.getOptions = function () { return options; };
        plot.highlight = highlight;
        plot.unhighlight = unhighlight;
        plot.triggerRedrawOverlay = triggerRedrawOverlay;
        plot.pointOffset = function(point) {
            return {
                left: parseInt(xaxes[axisNumber(point, "x") - 1].p2c(+point.x) + plotOffset.left, 10),
                top: parseInt(yaxes[axisNumber(point, "y") - 1].p2c(+point.y) + plotOffset.top, 10)
            };
        };
        plot.shutdown = shutdown;
        plot.destroy = function () {
            shutdown();
            placeholder.removeData("plot").empty();

            series = [];
            options = null;
            surface = null;
            overlay = null;
            eventHolder = null;
            ctx = null;
            octx = null;
            xaxes = [];
            yaxes = [];
            hooks = null;
            highlights = [];
            plot = null;
        };
        plot.resize = function () {
        	var width = placeholder.width(),
        		height = placeholder.height();
            surface.resize(width, height);
            overlay.resize(width, height);
        };

        // public attributes
        plot.hooks = hooks;

        // initialize
        initPlugins(plot);
        parseOptions(options_);
        setupCanvases();
        setData(data_);
        setupGrid();
        draw();
        bindEvents();


        function executeHooks(hook, args) {
            args = [plot].concat(args);
            for (var i = 0; i < hook.length; ++i)
                hook[i].apply(this, args);
        }

        function initPlugins() {

            // References to key classes, allowing plugins to modify them

            var classes = {
                Canvas: Canvas
            };

            for (var i = 0; i < plugins.length; ++i) {
                var p = plugins[i];
                p.init(plot, classes);
                if (p.options)
                    $.extend(true, options, p.options);
            }
        }

        function parseOptions(opts) {

            $.extend(true, options, opts);

            // $.extend merges arrays, rather than replacing them.  When less
            // colors are provided than the size of the default palette, we
            // end up with those colors plus the remaining defaults, which is
            // not expected behavior; avoid it by replacing them here.

            if (opts && opts.colors) {
            	options.colors = opts.colors;
            }

            if (options.xaxis.color == null)
                options.xaxis.color = $.color.parse(options.grid.color).scale('a', 0.22).toString();
            if (options.yaxis.color == null)
                options.yaxis.color = $.color.parse(options.grid.color).scale('a', 0.22).toString();

            if (options.xaxis.tickColor == null) // grid.tickColor for back-compatibility
                options.xaxis.tickColor = options.grid.tickColor || options.xaxis.color;
            if (options.yaxis.tickColor == null) // grid.tickColor for back-compatibility
                options.yaxis.tickColor = options.grid.tickColor || options.yaxis.color;

            if (options.grid.borderColor == null)
                options.grid.borderColor = options.grid.color;
            if (options.grid.tickColor == null)
                options.grid.tickColor = $.color.parse(options.grid.color).scale('a', 0.22).toString();

            // Fill in defaults for axis options, including any unspecified
            // font-spec fields, if a font-spec was provided.

            // If no x/y axis options were provided, create one of each anyway,
            // since the rest of the code assumes that they exist.

            var i, axisOptions, axisCount,
                fontSize = placeholder.css("font-size"),
                fontSizeDefault = fontSize ? +fontSize.replace("px", "") : 13,
                fontDefaults = {
                    style: placeholder.css("font-style"),
                    size: Math.round(0.8 * fontSizeDefault),
                    variant: placeholder.css("font-variant"),
                    weight: placeholder.css("font-weight"),
                    family: placeholder.css("font-family")
                };

            axisCount = options.xaxes.length || 1;
            for (i = 0; i < axisCount; ++i) {

                axisOptions = options.xaxes[i];
                if (axisOptions && !axisOptions.tickColor) {
                    axisOptions.tickColor = axisOptions.color;
                }

                axisOptions = $.extend(true, {}, options.xaxis, axisOptions);
                options.xaxes[i] = axisOptions;

                if (axisOptions.font) {
                    axisOptions.font = $.extend({}, fontDefaults, axisOptions.font);
                    if (!axisOptions.font.color) {
                        axisOptions.font.color = axisOptions.color;
                    }
                    if (!axisOptions.font.lineHeight) {
                        axisOptions.font.lineHeight = Math.round(axisOptions.font.size * 1.15);
                    }
                }
            }

            axisCount = options.yaxes.length || 1;
            for (i = 0; i < axisCount; ++i) {

                axisOptions = options.yaxes[i];
                if (axisOptions && !axisOptions.tickColor) {
                    axisOptions.tickColor = axisOptions.color;
                }

                axisOptions = $.extend(true, {}, options.yaxis, axisOptions);
                options.yaxes[i] = axisOptions;

                if (axisOptions.font) {
                    axisOptions.font = $.extend({}, fontDefaults, axisOptions.font);
                    if (!axisOptions.font.color) {
                        axisOptions.font.color = axisOptions.color;
                    }
                    if (!axisOptions.font.lineHeight) {
                        axisOptions.font.lineHeight = Math.round(axisOptions.font.size * 1.15);
                    }
                }
            }

            // backwards compatibility, to be removed in future
            if (options.xaxis.noTicks && options.xaxis.ticks == null)
                options.xaxis.ticks = options.xaxis.noTicks;
            if (options.yaxis.noTicks && options.yaxis.ticks == null)
                options.yaxis.ticks = options.yaxis.noTicks;
            if (options.x2axis) {
                options.xaxes[1] = $.extend(true, {}, options.xaxis, options.x2axis);
                options.xaxes[1].position = "top";
                // Override the inherit to allow the axis to auto-scale
                if (options.x2axis.min == null) {
                    options.xaxes[1].min = null;
                }
                if (options.x2axis.max == null) {
                    options.xaxes[1].max = null;
                }
            }
            if (options.y2axis) {
                options.yaxes[1] = $.extend(true, {}, options.yaxis, options.y2axis);
                options.yaxes[1].position = "right";
                // Override the inherit to allow the axis to auto-scale
                if (options.y2axis.min == null) {
                    options.yaxes[1].min = null;
                }
                if (options.y2axis.max == null) {
                    options.yaxes[1].max = null;
                }
            }
            if (options.grid.coloredAreas)
                options.grid.markings = options.grid.coloredAreas;
            if (options.grid.coloredAreasColor)
                options.grid.markingsColor = options.grid.coloredAreasColor;
            if (options.lines)
                $.extend(true, options.series.lines, options.lines);
            if (options.points)
                $.extend(true, options.series.points, options.points);
            if (options.bars)
                $.extend(true, options.series.bars, options.bars);
            if (options.shadowSize != null)
                options.series.shadowSize = options.shadowSize;
            if (options.highlightColor != null)
                options.series.highlightColor = options.highlightColor;

            // save options on axes for future reference
            for (i = 0; i < options.xaxes.length; ++i)
                getOrCreateAxis(xaxes, i + 1).options = options.xaxes[i];
            for (i = 0; i < options.yaxes.length; ++i)
                getOrCreateAxis(yaxes, i + 1).options = options.yaxes[i];

            // add hooks from options
            for (var n in hooks)
                if (options.hooks[n] && options.hooks[n].length)
                    hooks[n] = hooks[n].concat(options.hooks[n]);

            executeHooks(hooks.processOptions, [options]);
        }

        function setData(d) {
            series = parseData(d);
            fillInSeriesOptions();
            processData();
        }

        function parseData(d) {
            var res = [];
            for (var i = 0; i < d.length; ++i) {
                var s = $.extend(true, {}, options.series);

                if (d[i].data != null) {
                    s.data = d[i].data; // move the data instead of deep-copy
                    delete d[i].data;

                    $.extend(true, s, d[i]);

                    d[i].data = s.data;
                }
                else
                    s.data = d[i];
                res.push(s);
            }

            return res;
        }

        function axisNumber(obj, coord) {
            var a = obj[coord + "axis"];
            if (typeof a == "object") // if we got a real axis, extract number
                a = a.n;
            if (typeof a != "number")
                a = 1; // default to first axis
            return a;
        }

        function allAxes() {
            // return flat array without annoying null entries
            return $.grep(xaxes.concat(yaxes), function (a) { return a; });
        }

        function canvasToAxisCoords(pos) {
            // return an object with x/y corresponding to all used axes
            var res = {}, i, axis;
            for (i = 0; i < xaxes.length; ++i) {
                axis = xaxes[i];
                if (axis && axis.used)
                    res["x" + axis.n] = axis.c2p(pos.left);
            }

            for (i = 0; i < yaxes.length; ++i) {
                axis = yaxes[i];
                if (axis && axis.used)
                    res["y" + axis.n] = axis.c2p(pos.top);
            }

            if (res.x1 !== undefined)
                res.x = res.x1;
            if (res.y1 !== undefined)
                res.y = res.y1;

            return res;
        }

        function axisToCanvasCoords(pos) {
            // get canvas coords from the first pair of x/y found in pos
            var res = {}, i, axis, key;

            for (i = 0; i < xaxes.length; ++i) {
                axis = xaxes[i];
                if (axis && axis.used) {
                    key = "x" + axis.n;
                    if (pos[key] == null && axis.n == 1)
                        key = "x";

                    if (pos[key] != null) {
                        res.left = axis.p2c(pos[key]);
                        break;
                    }
                }
            }

            for (i = 0; i < yaxes.length; ++i) {
                axis = yaxes[i];
                if (axis && axis.used) {
                    key = "y" + axis.n;
                    if (pos[key] == null && axis.n == 1)
                        key = "y";

                    if (pos[key] != null) {
                        res.top = axis.p2c(pos[key]);
                        break;
                    }
                }
            }

            return res;
        }

        function getOrCreateAxis(axes, number) {
            if (!axes[number - 1])
                axes[number - 1] = {
                    n: number, // save the number for future reference
                    direction: axes == xaxes ? "x" : "y",
                    options: $.extend(true, {}, axes == xaxes ? options.xaxis : options.yaxis)
                };

            return axes[number - 1];
        }

        function fillInSeriesOptions() {

            var neededColors = series.length, maxIndex = -1, i;

            // Subtract the number of series that already have fixed colors or
            // color indexes from the number that we still need to generate.

            for (i = 0; i < series.length; ++i) {
                var sc = series[i].color;
                if (sc != null) {
                    neededColors--;
                    if (typeof sc == "number" && sc > maxIndex) {
                        maxIndex = sc;
                    }
                }
            }

            // If any of the series have fixed color indexes, then we need to
            // generate at least as many colors as the highest index.

            if (neededColors <= maxIndex) {
                neededColors = maxIndex + 1;
            }

            // Generate all the colors, using first the option colors and then
            // variations on those colors once they're exhausted.

            var c, colors = [], colorPool = options.colors,
                colorPoolSize = colorPool.length, variation = 0;

            for (i = 0; i < neededColors; i++) {

                c = $.color.parse(colorPool[i % colorPoolSize] || "#666");

                // Each time we exhaust the colors in the pool we adjust
                // a scaling factor used to produce more variations on
                // those colors. The factor alternates negative/positive
                // to produce lighter/darker colors.

                // Reset the variation after every few cycles, or else
                // it will end up producing only white or black colors.

                if (i % colorPoolSize == 0 && i) {
                    if (variation >= 0) {
                        if (variation < 0.5) {
                            variation = -variation - 0.2;
                        } else variation = 0;
                    } else variation = -variation;
                }

                colors[i] = c.scale('rgb', 1 + variation);
            }

            // Finalize the series options, filling in their colors

            var colori = 0, s;
            for (i = 0; i < series.length; ++i) {
                s = series[i];

                // assign colors
                if (s.color == null) {
                    s.color = colors[colori].toString();
                    ++colori;
                }
                else if (typeof s.color == "number")
                    s.color = colors[s.color].toString();

                // turn on lines automatically in case nothing is set
                if (s.lines.show == null) {
                    var v, show = true;
                    for (v in s)
                        if (s[v] && s[v].show) {
                            show = false;
                            break;
                        }
                    if (show)
                        s.lines.show = true;
                }

                // If nothing was provided for lines.zero, default it to match
                // lines.fill, since areas by default should extend to zero.

                if (s.lines.zero == null) {
                    s.lines.zero = !!s.lines.fill;
                }

                // setup axes
                s.xaxis = getOrCreateAxis(xaxes, axisNumber(s, "x"));
                s.yaxis = getOrCreateAxis(yaxes, axisNumber(s, "y"));
            }
        }

        function processData() {
            var topSentry = Number.POSITIVE_INFINITY,
                bottomSentry = Number.NEGATIVE_INFINITY,
                fakeInfinity = Number.MAX_VALUE,
                i, j, k, m, length,
                s, points, ps, x, y, axis, val, f, p,
                data, format;

            function updateAxis(axis, min, max) {
                if (min < axis.datamin && min != -fakeInfinity)
                    axis.datamin = min;
                if (max > axis.datamax && max != fakeInfinity)
                    axis.datamax = max;
            }

            $.each(allAxes(), function (_, axis) {
                // init axis
                axis.datamin = topSentry;
                axis.datamax = bottomSentry;
                axis.used = false;
            });

            for (i = 0; i < series.length; ++i) {
                s = series[i];
                s.datapoints = { points: [] };

                executeHooks(hooks.processRawData, [ s, s.data, s.datapoints ]);
            }

            // first pass: clean and copy data
            for (i = 0; i < series.length; ++i) {
                s = series[i];

                data = s.data;
                format = s.datapoints.format;

                if (!format) {
                    format = [];
                    // find out how to copy
                    format.push({ x: true, number: true, required: true });
                    format.push({ y: true, number: true, required: true });

                    if (s.bars.show || (s.lines.show && s.lines.fill)) {
                        var autoscale = !!((s.bars.show && s.bars.zero) || (s.lines.show && s.lines.zero));
                        format.push({ y: true, number: true, required: false, defaultValue: 0, autoscale: autoscale });
                        if (s.bars.horizontal) {
                            delete format[format.length - 1].y;
                            format[format.length - 1].x = true;
                        }
                    }

                    s.datapoints.format = format;
                }

                if (s.datapoints.pointsize != null)
                    continue; // already filled in

                s.datapoints.pointsize = format.length;

                ps = s.datapoints.pointsize;
                points = s.datapoints.points;

                var insertSteps = s.lines.show && s.lines.steps;
                s.xaxis.used = s.yaxis.used = true;

                for (j = k = 0; j < data.length; ++j, k += ps) {
                    p = data[j];

                    var nullify = p == null;
                    if (!nullify) {
                        for (m = 0; m < ps; ++m) {
                            val = p[m];
                            f = format[m];

                            if (f) {
                                if (f.number && val != null) {
                                    val = +val; // convert to number
                                    if (isNaN(val))
                                        val = null;
                                    else if (val == Infinity)
                                        val = fakeInfinity;
                                    else if (val == -Infinity)
                                        val = -fakeInfinity;
                                }

                                if (val == null) {
                                    if (f.required)
                                        nullify = true;

                                    if (f.defaultValue != null)
                                        val = f.defaultValue;
                                }
                            }

                            points[k + m] = val;
                        }
                    }

                    if (nullify) {
                        for (m = 0; m < ps; ++m) {
                            val = points[k + m];
                            if (val != null) {
                                f = format[m];
                                // extract min/max info
                                if (f.autoscale !== false) {
                                    if (f.x) {
                                        updateAxis(s.xaxis, val, val);
                                    }
                                    if (f.y) {
                                        updateAxis(s.yaxis, val, val);
                                    }
                                }
                            }
                            points[k + m] = null;
                        }
                    }

                    if (insertSteps && k > 0 && (!nullify || points[k - ps] != null)) {
                        // copy the point to make room for a middle point
                        for (m = 0; m < ps; ++m)
                            points[k + ps + m] = points[k + m];

                        // middle point has same y
                        points[k + 1] = points[k - ps + 1] || 0;

                        // if series has null values, let's give the last !null value a nice step
                        if(nullify)
                        	points[k] = p[0];

                        // we've added a point, better reflect that
                        k += ps;
                    }
                }
            }

            // give the hooks a chance to run
            for (i = 0; i < series.length; ++i) {
                s = series[i];
                points = s.datapoints.points;
                ps = s.datapoints.pointsize;

                // grafana
                if (s.transform === 'negative-Y') {
                  for (j = 0; j < points.length; j += ps) {
                    if (points[j] == null)
                        continue;

                      val = points[j + 1];
                      points[j + 1] = -val;
                  }
                }

                executeHooks(hooks.processDatapoints, [ s, s.datapoints]);
            }

            // second pass: find datamax/datamin for auto-scaling
            for (i = 0; i < series.length; ++i) {
                s = series[i];
                points = s.datapoints.points;
                ps = s.datapoints.pointsize;
                format = s.datapoints.format;

                var xmin = topSentry, ymin = topSentry,
                    xmax = bottomSentry, ymax = bottomSentry;

                for (j = 0; j < points.length; j += ps) {
                    if (points[j] == null)
                        continue;

                    for (m = 0; m < ps; ++m) {
                        val = points[j + m];
                        f = format[m];
                        if (!f || f.autoscale === false || val == fakeInfinity || val == -fakeInfinity)
                            continue;

                        if (f.x) {
                            if (val < xmin)
                                xmin = val;
                            if (val > xmax)
                                xmax = val;
                        }
                        if (f.y) {
                            if (val < ymin)
                                ymin = val;
                            if (val > ymax)
                                ymax = val;
                        }
                    }
                }

                if (s.bars.show) {
                    // make sure we got room for the bar on the dancing floor
                    var delta;

                    switch (s.bars.align) {
                        case "left":
                            delta = 0;
                            break;
                        case "right":
                            delta = -s.bars.barWidth;
                            break;
                        default:
                            delta = -s.bars.barWidth / 2;
                    }

                    if (s.bars.horizontal) {
                        ymin += delta;
                        ymax += delta + s.bars.barWidth;
                    }
                    else {
                        xmin += delta;
                        xmax += delta + s.bars.barWidth;
                    }
                }

                updateAxis(s.xaxis, xmin, xmax);
                updateAxis(s.yaxis, ymin, ymax);
            }

            $.each(allAxes(), function (_, axis) {
                if (axis.datamin == topSentry)
                    axis.datamin = null;
                if (axis.datamax == bottomSentry)
                    axis.datamax = null;
            });
        }

        function setupCanvases() {
            // Make sure the placeholder is clear of everything except canvases
            // from a previous plot in this container that we'll try to re-use.

            placeholder.find(".flot-temp-elem").remove();

            if (placeholder.css("position") == 'static')
                placeholder.css("position", "relative"); // for positioning labels and overlay

            surface = new Canvas("flot-base", placeholder);
            overlay = new Canvas("flot-overlay", placeholder); // overlay canvas for interactive features

            ctx = surface.context;
            octx = overlay.context;

            // define which element we're listening for events on
            eventHolder = $(overlay.element).unbind();

            // If we're re-using a plot object, shut down the old one

            var existing = placeholder.data("plot");

            if (existing) {
                existing.shutdown();
                overlay.clear();
            }

            // save in case we get replotted
            placeholder.data("plot", plot);
        }

        function bindEvents() {
            // bind events
            if (options.grid.hoverable) {
                eventHolder.mousemove(onMouseMove);

                // Use bind, rather than .mouseleave, because we officially
                // still support jQuery 1.2.6, which doesn't define a shortcut
                // for mouseenter or mouseleave.  This was a bug/oversight that
                // was fixed somewhere around 1.3.x.  We can return to using
                // .mouseleave when we drop support for 1.2.6.

                eventHolder.bind("mouseleave", onMouseLeave);
            }

            if (options.grid.clickable)
                eventHolder.click(onClick);

            executeHooks(hooks.bindEvents, [eventHolder]);
        }

        function shutdown() {
            if (redrawTimeout)
                clearTimeout(redrawTimeout);

            eventHolder.unbind("mousemove", onMouseMove);
            eventHolder.unbind("mouseleave", onMouseLeave);
            eventHolder.unbind("click", onClick);

            executeHooks(hooks.shutdown, [eventHolder]);
        }

        function setTransformationHelpers(axis) {
            // set helper functions on the axis, assumes plot area
            // has been computed already

            function identity(x) { return x; }

            var s, m, t = axis.options.transform || identity,
                it = axis.options.inverseTransform;

            // precompute how much the axis is scaling a point
            // in canvas space
            if (axis.direction == "x") {
                s = axis.scale = plotWidth / Math.abs(t(axis.max) - t(axis.min));
                m = Math.min(t(axis.max), t(axis.min));
            }
            else {
                s = axis.scale = plotHeight / Math.abs(t(axis.max) - t(axis.min));
                s = -s;
                m = Math.max(t(axis.max), t(axis.min));
            }

            // data point to canvas coordinate
            if (t == identity) // slight optimization
                axis.p2c = function (p) { return (p - m) * s; };
            else
                axis.p2c = function (p) { return (t(p) - m) * s; };
            // canvas coordinate to data point
            if (!it)
                axis.c2p = function (c) { return m + c / s; };
            else
                axis.c2p = function (c) { return it(m + c / s); };
        }

        function measureTickLabels(axis) {

            var opts = axis.options,
                ticks = axis.ticks || [],
                labelWidth = opts.labelWidth || 0,
                labelHeight = opts.labelHeight || 0,
                maxWidth = labelWidth || (axis.direction == "x" ? Math.floor(surface.width / (ticks.length || 1)) : null),
                legacyStyles = axis.direction + "Axis " + axis.direction + axis.n + "Axis",
                layer = "flot-" + axis.direction + "-axis flot-" + axis.direction + axis.n + "-axis " + legacyStyles,
                font = opts.font || "flot-tick-label tickLabel";

            for (var i = 0; i < ticks.length; ++i) {

                var t = ticks[i];

                if (!t.label)
                    continue;

                var info = surface.getTextInfo(layer, t.label, font, null, maxWidth);

                /// Grafana fix, add +1 to label width
                labelWidth = Math.max(labelWidth, info.width + 1);
                labelHeight = Math.max(labelHeight, info.height);
            }

            axis.labelWidth = opts.labelWidth || labelWidth;
            axis.labelHeight = opts.labelHeight || labelHeight;
        }

        function allocateAxisBoxFirstPhase(axis) {
            // find the bounding box of the axis by looking at label
            // widths/heights and ticks, make room by diminishing the
            // plotOffset; this first phase only looks at one
            // dimension per axis, the other dimension depends on the
            // other axes so will have to wait

            var lw = axis.labelWidth,
                lh = axis.labelHeight,
                pos = axis.options.position,
                isXAxis = axis.direction === "x",
                tickLength = axis.options.tickLength,
                axisMargin = options.grid.axisMargin,
                padding = options.grid.labelMargin,
                eventSectionPadding = options.grid.eventSectionHeight,
                innermost = true,
                outermost = true,
                first = true,
                found = false;

            // Determine the axis's position in its direction and on its side

            $.each(isXAxis ? xaxes : yaxes, function(i, a) {
                if (a && (a.show || a.reserveSpace)) {
                    if (a === axis) {
                        found = true;
                    } else if (a.options.position === pos) {
                        if (found) {
                            outermost = false;
                        } else {
                            innermost = false;
                        }
                    }
                    if (!found) {
                        first = false;
                    }
                }
            });

            // The outermost axis on each side has no margin

            if (outermost) {
                axisMargin = 0;
            }

            // The ticks for the first axis in each direction stretch across

            if (tickLength == null) {
                tickLength = first ? "full" : 5;
            }

            if (!isNaN(+tickLength))
                padding += +tickLength;

            if (isXAxis) {
                // Add space for event section
                lh += padding;
                lh += eventSectionPadding;

                if (pos == "bottom") {
                    plotOffset.bottom += lh + axisMargin;
                    axis.box = { top: surface.height - plotOffset.bottom, height: lh };
                }
                else {
                    axis.box = { top: plotOffset.top + axisMargin, height: lh };
                    plotOffset.top += lh + axisMargin;
                }
            }
            else {
                lw += padding;

                if (pos == "left") {
                    axis.box = { left: plotOffset.left + axisMargin, width: lw };
                    plotOffset.left += lw + axisMargin;
                }
                else {
                    plotOffset.right += lw + axisMargin;
                    axis.box = { left: surface.width - plotOffset.right, width: lw };
                }
            }

             // save for future reference
            axis.position = pos;
            axis.tickLength = tickLength;
            axis.box.padding = padding;
            axis.box.eventSectionPadding = eventSectionPadding;
            axis.innermost = innermost;
        }

        function allocateAxisBoxSecondPhase(axis) {
            // now that all axis boxes have been placed in one
            // dimension, we can set the remaining dimension coordinates
            if (axis.direction == "x") {
                axis.box.left = plotOffset.left - axis.labelWidth / 2;
                axis.box.width = surface.width - plotOffset.left - plotOffset.right + axis.labelWidth;
            }
            else {
                axis.box.top = plotOffset.top - axis.labelHeight / 2;
                axis.box.height = surface.height - plotOffset.bottom - plotOffset.top + axis.labelHeight;
            }
        }

        function adjustLayoutForThingsStickingOut() {
            // possibly adjust plot offset to ensure everything stays
            // inside the canvas and isn't clipped off

            var minMargin = options.grid.minBorderMargin,
                axis, i;

            // check stuff from the plot (FIXME: this should just read
            // a value from the series, otherwise it's impossible to
            // customize)
            if (minMargin == null) {
                minMargin = 0;
                for (i = 0; i < series.length; ++i)
                    minMargin = Math.max(minMargin, 2 * (series[i].points.radius + series[i].points.lineWidth/2));
            }

            var margins = {
                left: minMargin,
                right: minMargin,
                top: minMargin,
                bottom: minMargin
            };

            // check axis labels, note we don't check the actual
            // labels but instead use the overall width/height to not
            // jump as much around with replots
            $.each(allAxes(), function (_, axis) {
                if (axis.reserveSpace && axis.ticks && axis.ticks.length) {
                    if (axis.direction === "x") {
                        margins.left = Math.max(margins.left, axis.labelWidth / 2);
                        margins.right = Math.max(margins.right, axis.labelWidth / 2);
                    } else {
                        margins.bottom = Math.max(margins.bottom, axis.labelHeight / 2);
                        margins.top = Math.max(margins.top, axis.labelHeight / 2);
                    }
                }
            });

            plotOffset.left = Math.ceil(Math.max(margins.left, plotOffset.left));
            plotOffset.right = Math.ceil(Math.max(margins.right, plotOffset.right));
            plotOffset.top = Math.ceil(Math.max(margins.top, plotOffset.top));
            plotOffset.bottom = Math.ceil(Math.max(margins.bottom, plotOffset.bottom));
        }

        function setupGrid() {
            var i, axes = allAxes(), showGrid = options.grid.show;

            // Initialize the plot's offset from the edge of the canvas

            for (var a in plotOffset) {
                var margin = options.grid.margin || 0;
                plotOffset[a] = typeof margin == "number" ? margin : margin[a] || 0;
            }

            executeHooks(hooks.processOffset, [plotOffset]);

            // If the grid is visible, add its border width to the offset

            for (var a in plotOffset) {
                if(typeof(options.grid.borderWidth) == "object") {
                    plotOffset[a] += showGrid ? options.grid.borderWidth[a] : 0;
                }
                else {
                    plotOffset[a] += showGrid ? options.grid.borderWidth : 0;
                }
            }

            $.each(axes, function (_, axis) {
                var axisOpts = axis.options;
                axis.show = axisOpts.show == null ? axis.used : axisOpts.show;
                axis.reserveSpace = axisOpts.reserveSpace == null ? axis.show : axisOpts.reserveSpace;
                setRange(axis);
            });

            if (showGrid) {

                var allocatedAxes = $.grep(axes, function (axis) {
                    return axis.show || axis.reserveSpace;
                });

                $.each(allocatedAxes, function (_, axis) {
                    // make the ticks
                    setupTickGeneration(axis);
                    setTicks(axis);
                    snapRangeToTicks(axis, axis.ticks);
                    // find labelWidth/Height for axis
                    measureTickLabels(axis);
                });

                // with all dimensions calculated, we can compute the
                // axis bounding boxes, start from the outside
                // (reverse order)
                for (i = allocatedAxes.length - 1; i >= 0; --i)
                    allocateAxisBoxFirstPhase(allocatedAxes[i]);

                // make sure we've got enough space for things that
                // might stick out
                adjustLayoutForThingsStickingOut();

                $.each(allocatedAxes, function (_, axis) {
                    allocateAxisBoxSecondPhase(axis);
                });
            }

            plotWidth = surface.width - plotOffset.left - plotOffset.right;
            plotHeight = surface.height - plotOffset.bottom - plotOffset.top;

            // now we got the proper plot dimensions, we can compute the scaling
            $.each(axes, function (_, axis) {
                setTransformationHelpers(axis);
            });

            if (showGrid) {
                drawAxisLabels();
            }

            insertLegend();
        }

        function setRange(axis) {
            var opts = axis.options,
                min = +(opts.min != null ? opts.min : axis.datamin),
                max = +(opts.max != null ? opts.max : axis.datamax),
                delta = max - min;

            if (delta == 0.0) {
                // Grafana fix: wide Y min and max using increased wideFactor
                // when all series values are the same
                var wideFactor = 0.25;
                var widen = Math.abs(max == 0 ? 1 : max * wideFactor);

                if (opts.min == null) {
                  min -= widen;
                }
                // always widen max if we couldn't widen min to ensure we
                // don't fall into min == max which doesn't work
                if (opts.max == null || opts.min != null) {
                  max += widen;
                }
            }
            else {
                // consider autoscaling
                var margin = opts.autoscaleMargin;
                if (margin != null) {
                    if (opts.min == null) {
                        min -= delta * margin;
                        // make sure we don't go below zero if all values
                        // are positive
                        if (min < 0 && axis.datamin != null && axis.datamin >= 0)
                            min = 0;
                    }
                    if (opts.max == null) {
                        max += delta * margin;
                        if (max > 0 && axis.datamax != null && axis.datamax <= 0)
                            max = 0;
                    }
                }
            }
            axis.min = min;
            axis.max = max;
        }

        function setupTickGeneration(axis) {
            var opts = axis.options;

            // estimate number of ticks
            var noTicks;
            if (typeof opts.ticks == "number" && opts.ticks > 0)
                noTicks = opts.ticks;
            else
                // heuristic based on the model a*sqrt(x) fitted to
                // some data points that seemed reasonable
                noTicks = 0.3 * Math.sqrt(axis.direction == "x" ? surface.width : surface.height);

            var delta = (axis.max - axis.min) / noTicks,
                dec = -Math.floor(Math.log(delta) / Math.LN10),
                maxDec = opts.tickDecimals;

            if (maxDec != null && dec > maxDec) {
                dec = maxDec;
            }

            var magn = Math.pow(10, -dec),
                norm = delta / magn, // norm is between 1.0 and 10.0
                size;

            if (norm < 1.5) {
                size = 1;
            } else if (norm < 3) {
                size = 2;
                // special case for 2.5, requires an extra decimal
                if (norm > 2.25 && (maxDec == null || dec + 1 <= maxDec)) {
                    size = 2.5;
                    ++dec;
                }
            } else if (norm < 7.5) {
                size = 5;
            } else {
                size = 10;
            }

            size *= magn;

            if (opts.minTickSize != null && size < opts.minTickSize) {
                size = opts.minTickSize;
            }

            axis.delta = delta;
            axis.tickDecimals = Math.max(0, maxDec != null ? maxDec : dec);
            axis.tickSize = opts.tickSize || size;
            // grafana addition
            axis.scaledDecimals = axis.tickDecimals - Math.floor(Math.log(axis.tickSize) / Math.LN10);

            // Time mode was moved to a plug-in in 0.8, and since so many people use it
            // we'll add an especially friendly reminder to make sure they included it.

            if (opts.mode == "time" && !axis.tickGenerator) {
                throw new Error("Time mode requires the flot.time plugin.");
            }

            // Flot supports base-10 axes; any other mode else is handled by a plug-in,
            // like flot.time.js.

            if (!axis.tickGenerator) {

                axis.tickGenerator = function (axis) {

                    var ticks = [],
                        start = floorInBase(axis.min, axis.tickSize),
                        i = 0,
                        v = Number.NaN,
                        prev;

                    do {
                        prev = v;
                        v = start + i * axis.tickSize;
                        ticks.push(v);
                        ++i;
                    } while (v < axis.max && v != prev);
                    return ticks;
                };

				axis.tickFormatter = function (value, axis) {

					var factor = axis.tickDecimals ? Math.pow(10, axis.tickDecimals) : 1;
					var formatted = "" + Math.round(value * factor) / factor;

					// If tickDecimals was specified, ensure that we have exactly that
					// much precision; otherwise default to the value's own precision.

					if (axis.tickDecimals != null) {
						var decimal = formatted.indexOf(".");
						var precision = decimal == -1 ? 0 : formatted.length - decimal - 1;
						if (precision < axis.tickDecimals) {
							return (precision ? formatted : formatted + ".") + ("" + factor).substr(1, axis.tickDecimals - precision);
						}
					}

                    return formatted;
                };
            }

            if ($.isFunction(opts.tickFormatter))
                axis.tickFormatter = function (v, axis) { return "" + opts.tickFormatter(v, axis); };

            if (opts.alignTicksWithAxis != null) {
                var otherAxis = (axis.direction == "x" ? xaxes : yaxes)[opts.alignTicksWithAxis - 1];
                if (otherAxis && otherAxis.used && otherAxis != axis) {
                    // consider snapping min/max to outermost nice ticks
                    var niceTicks = axis.tickGenerator(axis);
                    if (niceTicks.length > 0) {
                        if (opts.min == null)
                            axis.min = Math.min(axis.min, niceTicks[0]);
                        if (opts.max == null && niceTicks.length > 1)
                            axis.max = Math.max(axis.max, niceTicks[niceTicks.length - 1]);
                    }

                    axis.tickGenerator = function (axis) {
                        // copy ticks, scaled to this axis
                        var ticks = [], v, i;
                        for (i = 0; i < otherAxis.ticks.length; ++i) {
                            v = (otherAxis.ticks[i].v - otherAxis.min) / (otherAxis.max - otherAxis.min);
                            v = axis.min + v * (axis.max - axis.min);
                            ticks.push(v);
                        }
                        return ticks;
                    };

                    // we might need an extra decimal since forced
                    // ticks don't necessarily fit naturally
                    if (!axis.mode && opts.tickDecimals == null) {
                        var extraDec = Math.max(0, -Math.floor(Math.log(axis.delta) / Math.LN10) + 1),
                            ts = axis.tickGenerator(axis);

                        // only proceed if the tick interval rounded
                        // with an extra decimal doesn't give us a
                        // zero at end
                        if (!(ts.length > 1 && /\..*0$/.test((ts[1] - ts[0]).toFixed(extraDec))))
                            axis.tickDecimals = extraDec;
                    }
                }
            }
        }

        function setTicks(axis) {
            var oticks = axis.options.ticks, ticks = [];
            if (oticks == null || (typeof oticks == "number" && oticks > 0))
                ticks = axis.tickGenerator(axis);
            else if (oticks) {
                if ($.isFunction(oticks))
                    // generate the ticks
                    ticks = oticks(axis);
                else
                    ticks = oticks;
            }

            // clean up/labelify the supplied ticks, copy them over
            var i, v;
            axis.ticks = [];
            for (i = 0; i < ticks.length; ++i) {
                var label = null;
                var t = ticks[i];
                if (typeof t == "object") {
                    v = +t[0];
                    if (t.length > 1)
                        label = t[1];
                }
                else
                    v = +t;
                if (label == null)
                    label = axis.tickFormatter(v, axis);
                if (!isNaN(v))
                    axis.ticks.push({ v: v, label: label });
            }
        }

        function snapRangeToTicks(axis, ticks) {
            if (axis.options.autoscaleMargin && ticks.length > 0) {
                // snap to ticks
                if (axis.options.min == null)
                    axis.min = Math.min(axis.min, ticks[0].v);
                if (axis.options.max == null && ticks.length > 1)
                    axis.max = Math.max(axis.max, ticks[ticks.length - 1].v);
            }
        }

        function draw() {

            surface.clear();

            executeHooks(hooks.drawBackground, [ctx]);

            var grid = options.grid;

            // draw background, if any
            if (grid.show && grid.backgroundColor)
                drawBackground();

            if (grid.show && !grid.aboveData) {
                drawGrid();
            }

            for (var i = 0; i < series.length; ++i) {
                executeHooks(hooks.drawSeries, [ctx, series[i]]);
                drawSeries(series[i]);
            }

            executeHooks(hooks.draw, [ctx]);

            if (grid.show && grid.aboveData) {
                drawGrid();
            }

            surface.render();

            // A draw implies that either the axes or data have changed, so we
            // should probably update the overlay highlights as well.

            triggerRedrawOverlay();
        }

        function extractRange(ranges, coord) {
            var axis, from, to, key, axes = allAxes();

            for (var i = 0; i < axes.length; ++i) {
                axis = axes[i];
                if (axis.direction == coord) {
                    key = coord + axis.n + "axis";
                    if (!ranges[key] && axis.n == 1)
                        key = coord + "axis"; // support x1axis as xaxis
                    if (ranges[key]) {
                        from = ranges[key].from;
                        to = ranges[key].to;
                        break;
                    }
                }
            }

            // backwards-compat stuff - to be removed in future
            if (!ranges[key]) {
                axis = coord == "x" ? xaxes[0] : yaxes[0];
                from = ranges[coord + "1"];
                to = ranges[coord + "2"];
            }

            // auto-reverse as an added bonus
            if (from != null && to != null && from > to) {
                var tmp = from;
                from = to;
                to = tmp;
            }

            return { from: from, to: to, axis: axis };
        }

        function drawBackground() {
            ctx.save();
            ctx.translate(plotOffset.left, plotOffset.top);

            ctx.fillStyle = getColorOrGradient(options.grid.backgroundColor, plotHeight, 0, "rgba(255, 255, 255, 0)");
            ctx.fillRect(0, 0, plotWidth, plotHeight);
            ctx.restore();
        }

        function drawGrid() {
            var i, axes, bw, bc;

            ctx.save();
            ctx.translate(plotOffset.left, plotOffset.top);

            // draw markings
            var markings = options.grid.markings;
            if (markings) {
                if ($.isFunction(markings)) {
                    axes = plot.getAxes();
                    // xmin etc. is backwards compatibility, to be
                    // removed in the future
                    axes.xmin = axes.xaxis.min;
                    axes.xmax = axes.xaxis.max;
                    axes.ymin = axes.yaxis.min;
                    axes.ymax = axes.yaxis.max;

                    markings = markings(axes);
                }

                for (i = 0; i < markings.length; ++i) {
                    var m = markings[i],
                        xrange = extractRange(m, "x"),
                        yrange = extractRange(m, "y");

                    // fill in missing
                    if (xrange.from == null)
                        xrange.from = xrange.axis.min;
                    if (xrange.to == null)
                        xrange.to = xrange.axis.max;
                    if (yrange.from == null)
                        yrange.from = yrange.axis.min;
                    if (yrange.to == null)
                        yrange.to = yrange.axis.max;

                    // clip
                    if (xrange.to < xrange.axis.min || xrange.from > xrange.axis.max ||
                        yrange.to < yrange.axis.min || yrange.from > yrange.axis.max)
                        continue;

                    xrange.from = Math.max(xrange.from, xrange.axis.min);
                    xrange.to = Math.min(xrange.to, xrange.axis.max);
                    yrange.from = Math.max(yrange.from, yrange.axis.min);
                    yrange.to = Math.min(yrange.to, yrange.axis.max);

                    var xequal = xrange.from === xrange.to,
                        yequal = yrange.from === yrange.to;

                    if (xequal && yequal) {
                        continue;
                    }

                    // then draw
                    xrange.from = Math.floor(xrange.axis.p2c(xrange.from));
                    xrange.to = Math.floor(xrange.axis.p2c(xrange.to));
                    yrange.from = Math.floor(yrange.axis.p2c(yrange.from));
                    yrange.to = Math.floor(yrange.axis.p2c(yrange.to));

                    if (xequal || yequal) {
                        var lineWidth = m.lineWidth || options.grid.markingsLineWidth,
                            subPixel = lineWidth % 2 ? 0.5 : 0;
                        ctx.beginPath();
                        ctx.strokeStyle = m.color || options.grid.markingsColor;
                        ctx.lineWidth = lineWidth;
                        if (xequal) {
                            ctx.moveTo(xrange.to + subPixel, yrange.from);
                            ctx.lineTo(xrange.to + subPixel, yrange.to);
                        } else {
                            ctx.moveTo(xrange.from, yrange.to + subPixel);
                            ctx.lineTo(xrange.to, yrange.to + subPixel);
                        }
                        ctx.stroke();
                    } else {
                        ctx.fillStyle = m.color || options.grid.markingsColor;
                        ctx.fillRect(xrange.from, yrange.to,
                                     xrange.to - xrange.from,
                                     yrange.from - yrange.to);
                    }
                }
            }

            // draw the ticks
            axes = allAxes();
            bw = options.grid.borderWidth;

            for (var j = 0; j < axes.length; ++j) {
                var axis = axes[j], box = axis.box,
                    t = axis.tickLength, x, y, xoff, yoff;
                if (!axis.show || axis.ticks.length == 0)
                    continue;

                ctx.lineWidth = 1;

                // find the edges
                if (axis.direction == "x") {
                    x = 0;
                    if (t == "full")
                        y = (axis.position == "top" ? 0 : plotHeight);
                    else
                        y = box.top - plotOffset.top + (axis.position == "top" ? box.height : 0);
                }
                else {
                    y = 0;
                    if (t == "full")
                        x = (axis.position == "left" ? 0 : plotWidth);
                    else
                        x = box.left - plotOffset.left + (axis.position == "left" ? box.width : 0);
                }

                // draw tick bar
                if (!axis.innermost) {
                    ctx.strokeStyle = axis.options.color;
                    ctx.beginPath();
                    xoff = yoff = 0;
                    if (axis.direction == "x")
                        xoff = plotWidth + 1;
                    else
                        yoff = plotHeight + 1;

                    if (ctx.lineWidth == 1) {
                        if (axis.direction == "x") {
                            y = Math.floor(y) + 0.5;
                        } else {
                            x = Math.floor(x) + 0.5;
                        }
                    }

                    ctx.moveTo(x, y);
                    ctx.lineTo(x + xoff, y + yoff);
                    ctx.stroke();
                }

                // draw ticks

                ctx.strokeStyle = axis.options.tickColor;

                ctx.beginPath();
                for (i = 0; i < axis.ticks.length; ++i) {
                    var v = axis.ticks[i].v;

                    xoff = yoff = 0;

                    if (isNaN(v) || v < axis.min || v > axis.max
                        // skip those lying on the axes if we got a border
                        || (t == "full"
                            && ((typeof bw == "object" && bw[axis.position] > 0) || bw > 0)
                            && (v == axis.min || v == axis.max)))
                        continue;

                    if (axis.direction == "x") {
                        x = axis.p2c(v);
                        yoff = t == "full" ? -plotHeight : t;

                        if (axis.position == "top")
                            yoff = -yoff;
                    }
                    else {
                        y = axis.p2c(v);
                        xoff = t == "full" ? -plotWidth : t;

                        if (axis.position == "left")
                            xoff = -xoff;
                    }

                    if (ctx.lineWidth == 1) {
                        if (axis.direction == "x")
                            x = Math.floor(x) + 0.5;
                        else
                            y = Math.floor(y) + 0.5;
                    }

                    ctx.moveTo(x, y);
                    ctx.lineTo(x + xoff, y + yoff);
                }

                ctx.stroke();
            }


            // draw border
            if (bw) {
                // If either borderWidth or borderColor is an object, then draw the border
                // line by line instead of as one rectangle
                bc = options.grid.borderColor;
                if(typeof bw == "object" || typeof bc == "object") {
                    if (typeof bw !== "object") {
                        bw = {top: bw, right: bw, bottom: bw, left: bw};
                    }
                    if (typeof bc !== "object") {
                        bc = {top: bc, right: bc, bottom: bc, left: bc};
                    }

                    if (bw.top > 0) {
                        ctx.strokeStyle = bc.top;
                        ctx.lineWidth = bw.top;
                        ctx.beginPath();
                        ctx.moveTo(0 - bw.left, 0 - bw.top/2);
                        ctx.lineTo(plotWidth, 0 - bw.top/2);
                        ctx.stroke();
                    }

                    if (bw.right > 0) {
                        ctx.strokeStyle = bc.right;
                        ctx.lineWidth = bw.right;
                        ctx.beginPath();
                        ctx.moveTo(plotWidth + bw.right / 2, 0 - bw.top);
                        ctx.lineTo(plotWidth + bw.right / 2, plotHeight);
                        ctx.stroke();
                    }

                    if (bw.bottom > 0) {
                        ctx.strokeStyle = bc.bottom;
                        ctx.lineWidth = bw.bottom;
                        ctx.beginPath();
                        ctx.moveTo(plotWidth + bw.right, plotHeight + bw.bottom / 2);
                        ctx.lineTo(0, plotHeight + bw.bottom / 2);
                        ctx.stroke();
                    }

                    if (bw.left > 0) {
                        ctx.strokeStyle = bc.left;
                        ctx.lineWidth = bw.left;
                        ctx.beginPath();
                        ctx.moveTo(0 - bw.left/2, plotHeight + bw.bottom);
                        ctx.lineTo(0- bw.left/2, 0);
                        ctx.stroke();
                    }
                }
                else {
                    ctx.lineWidth = bw;
                    ctx.strokeStyle = options.grid.borderColor;
                    ctx.strokeRect(-bw/2, -bw/2, plotWidth + bw, plotHeight + bw);
                }
            }

            ctx.restore();
        }

        function drawAxisLabels() {

            $.each(allAxes(), function (_, axis) {
                var box = axis.box,
                    legacyStyles = axis.direction + "Axis " + axis.direction + axis.n + "Axis",
                    layer = "flot-" + axis.direction + "-axis flot-" + axis.direction + axis.n + "-axis " + legacyStyles,
                    font = axis.options.font || "flot-tick-label tickLabel",
                    tick, x, y, halign, valign;

                // Remove text before checking for axis.show and ticks.length;
                // otherwise plugins, like flot-tickrotor, that draw their own
                // tick labels will end up with both theirs and the defaults.

                surface.removeText(layer);

                if (!axis.show || axis.ticks.length == 0)
                    return;

                for (var i = 0; i < axis.ticks.length; ++i) {

                    tick = axis.ticks[i];
                    if (!tick.label || tick.v < axis.min || tick.v > axis.max)
                        continue;

                    if (axis.direction == "x") {
                        halign = "center";
                        x = plotOffset.left + axis.p2c(tick.v);
                        if (axis.position == "bottom") {
                            y = box.top + box.padding + box.eventSectionPadding;
                        } else {
                            y = box.top + box.height - box.padding;
                            valign = "bottom";
                        }
                    } else {
                        valign = "middle";
                        y = plotOffset.top + axis.p2c(tick.v);
                        if (axis.position == "left") {
                            x = box.left + box.width - box.padding;
                            halign = "right";
                        } else {
                            x = box.left + box.padding;
                        }
                    }

                    surface.addText(layer, x, y, tick.label, font, null, null, halign, valign);
                }
            });
        }

        function drawSeries(series) {
            if (series.lines.show)
                drawSeriesLines(series);
            if (series.bars.show)
                drawSeriesBars(series);
            if (series.points.show)
                drawSeriesPoints(series);
        }

        function drawSeriesLines(series) {
            function plotLine(datapoints, xoffset, yoffset, axisx, axisy) {
                var points = datapoints.points,
                    ps = datapoints.pointsize,
                    prevx = null, prevy = null;

                ctx.beginPath();
                for (var i = ps; i < points.length; i += ps) {
                    var x1 = points[i - ps], y1 = points[i - ps + 1],
                        x2 = points[i], y2 = points[i + 1];

                    if (x1 == null || x2 == null)
                        continue;

                    // clip with ymin
                    if (y1 <= y2 && y1 < axisy.min) {
                        if (y2 < axisy.min)
                            continue;   // line segment is outside
                        // compute new intersection point
                        x1 = (axisy.min - y1) / (y2 - y1) * (x2 - x1) + x1;
                        y1 = axisy.min;
                    }
                    else if (y2 <= y1 && y2 < axisy.min) {
                        if (y1 < axisy.min)
                            continue;
                        x2 = (axisy.min - y1) / (y2 - y1) * (x2 - x1) + x1;
                        y2 = axisy.min;
                    }

                    // clip with ymax
                    if (y1 >= y2 && y1 > axisy.max) {
                        if (y2 > axisy.max)
                            continue;
                        x1 = (axisy.max - y1) / (y2 - y1) * (x2 - x1) + x1;
                        y1 = axisy.max;
                    }
                    else if (y2 >= y1 && y2 > axisy.max) {
                        if (y1 > axisy.max)
                            continue;
                        x2 = (axisy.max - y1) / (y2 - y1) * (x2 - x1) + x1;
                        y2 = axisy.max;
                    }

                    // clip with xmin
                    if (x1 <= x2 && x1 < axisx.min) {
                        if (x2 < axisx.min)
                            continue;
                        y1 = (axisx.min - x1) / (x2 - x1) * (y2 - y1) + y1;
                        x1 = axisx.min;
                    }
                    else if (x2 <= x1 && x2 < axisx.min) {
                        if (x1 < axisx.min)
                            continue;
                        y2 = (axisx.min - x1) / (x2 - x1) * (y2 - y1) + y1;
                        x2 = axisx.min;
                    }

                    // clip with xmax
                    if (x1 >= x2 && x1 > axisx.max) {
                        if (x2 > axisx.max)
                            continue;
                        y1 = (axisx.max - x1) / (x2 - x1) * (y2 - y1) + y1;
                        x1 = axisx.max;
                    }
                    else if (x2 >= x1 && x2 > axisx.max) {
                        if (x1 > axisx.max)
                            continue;
                        y2 = (axisx.max - x1) / (x2 - x1) * (y2 - y1) + y1;
                        x2 = axisx.max;
                    }

                    if (x1 != prevx || y1 != prevy)
                        ctx.moveTo(axisx.p2c(x1) + xoffset, axisy.p2c(y1) + yoffset);

                    prevx = x2;
                    prevy = y2;
                    ctx.lineTo(axisx.p2c(x2) + xoffset, axisy.p2c(y2) + yoffset);
                }
                ctx.stroke();
            }

            function plotLineArea(datapoints, axisx, axisy) {
                var points = datapoints.points,
                    ps = datapoints.pointsize,
                    bottom = Math.min(Math.max(0, axisy.min), axisy.max),
                    i = 0, top, areaOpen = false,
                    ypos = 1, segmentStart = 0, segmentEnd = 0;

                // we process each segment in two turns, first forward
                // direction to sketch out top, then once we hit the
                // end we go backwards to sketch the bottom
                while (true) {
                    if (ps > 0 && i > points.length + ps)
                        break;

                    i += ps; // ps is negative if going backwards

                    var x1 = points[i - ps],
                        y1 = points[i - ps + ypos],
                        x2 = points[i], y2 = points[i + ypos];

                    if (areaOpen) {
                        if (ps > 0 && x1 != null && x2 == null) {
                            // at turning point
                            segmentEnd = i;
                            ps = -ps;
                            ypos = 2;
                            continue;
                        }

                        if (ps < 0 && i == segmentStart + ps) {
                            // done with the reverse sweep
                            ctx.fill();
                            areaOpen = false;
                            ps = -ps;
                            ypos = 1;
                            i = segmentStart = segmentEnd + ps;
                            continue;
                        }
                    }

                    if (x1 == null || x2 == null)
                        continue;

                    // clip x values

                    // clip with xmin
                    if (x1 <= x2 && x1 < axisx.min) {
                        if (x2 < axisx.min)
                            continue;
                        y1 = (axisx.min - x1) / (x2 - x1) * (y2 - y1) + y1;
                        x1 = axisx.min;
                    }
                    else if (x2 <= x1 && x2 < axisx.min) {
                        if (x1 < axisx.min)
                            continue;
                        y2 = (axisx.min - x1) / (x2 - x1) * (y2 - y1) + y1;
                        x2 = axisx.min;
                    }

                    // clip with xmax
                    if (x1 >= x2 && x1 > axisx.max) {
                        if (x2 > axisx.max)
                            continue;
                        y1 = (axisx.max - x1) / (x2 - x1) * (y2 - y1) + y1;
                        x1 = axisx.max;
                    }
                    else if (x2 >= x1 && x2 > axisx.max) {
                        if (x1 > axisx.max)
                            continue;
                        y2 = (axisx.max - x1) / (x2 - x1) * (y2 - y1) + y1;
                        x2 = axisx.max;
                    }

                    if (!areaOpen) {
                        // open area
                        ctx.beginPath();
                        ctx.moveTo(axisx.p2c(x1), axisy.p2c(bottom));
                        areaOpen = true;
                    }

                    // now first check the case where both is outside
                    if (y1 >= axisy.max && y2 >= axisy.max) {
                        ctx.lineTo(axisx.p2c(x1), axisy.p2c(axisy.max));
                        ctx.lineTo(axisx.p2c(x2), axisy.p2c(axisy.max));
                        continue;
                    }
                    else if (y1 <= axisy.min && y2 <= axisy.min) {
                        ctx.lineTo(axisx.p2c(x1), axisy.p2c(axisy.min));
                        ctx.lineTo(axisx.p2c(x2), axisy.p2c(axisy.min));
                        continue;
                    }

                    // else it's a bit more complicated, there might
                    // be a flat maxed out rectangle first, then a
                    // triangular cutout or reverse; to find these
                    // keep track of the current x values
                    var x1old = x1, x2old = x2;

                    // clip the y values, without shortcutting, we
                    // go through all cases in turn

                    // clip with ymin
                    if (y1 <= y2 && y1 < axisy.min && y2 >= axisy.min) {
                        x1 = (axisy.min - y1) / (y2 - y1) * (x2 - x1) + x1;
                        y1 = axisy.min;
                    }
                    else if (y2 <= y1 && y2 < axisy.min && y1 >= axisy.min) {
                        x2 = (axisy.min - y1) / (y2 - y1) * (x2 - x1) + x1;
                        y2 = axisy.min;
                    }

                    // clip with ymax
                    if (y1 >= y2 && y1 > axisy.max && y2 <= axisy.max) {
                        x1 = (axisy.max - y1) / (y2 - y1) * (x2 - x1) + x1;
                        y1 = axisy.max;
                    }
                    else if (y2 >= y1 && y2 > axisy.max && y1 <= axisy.max) {
                        x2 = (axisy.max - y1) / (y2 - y1) * (x2 - x1) + x1;
                        y2 = axisy.max;
                    }

                    // if the x value was changed we got a rectangle
                    // to fill
                    if (x1 != x1old) {
                        ctx.lineTo(axisx.p2c(x1old), axisy.p2c(y1));
                        // it goes to (x1, y1), but we fill that below
                    }

                    // fill triangular section, this sometimes result
                    // in redundant points if (x1, y1) hasn't changed
                    // from previous line to, but we just ignore that
                    ctx.lineTo(axisx.p2c(x1), axisy.p2c(y1));
                    ctx.lineTo(axisx.p2c(x2), axisy.p2c(y2));

                    // fill the other rectangle if it's there
                    if (x2 != x2old) {
                        ctx.lineTo(axisx.p2c(x2), axisy.p2c(y2));
                        ctx.lineTo(axisx.p2c(x2old), axisy.p2c(y2));
                    }
                }
            }

            ctx.save();
            ctx.translate(plotOffset.left, plotOffset.top);
            ctx.lineJoin = "round";

            var lw = series.lines.lineWidth,
                sw = series.shadowSize;
            // FIXME: consider another form of shadow when filling is turned on
            if (lw > 0 && sw > 0) {
                // draw shadow as a thick and thin line with transparency
                ctx.lineWidth = sw;
                ctx.strokeStyle = "rgba(0,0,0,0.1)";
                // position shadow at angle from the mid of line
                var angle = Math.PI/18;
                plotLine(series.datapoints, Math.sin(angle) * (lw/2 + sw/2), Math.cos(angle) * (lw/2 + sw/2), series.xaxis, series.yaxis);
                ctx.lineWidth = sw/2;
                plotLine(series.datapoints, Math.sin(angle) * (lw/2 + sw/4), Math.cos(angle) * (lw/2 + sw/4), series.xaxis, series.yaxis);
            }

            ctx.lineWidth = lw;
            ctx.strokeStyle = series.color;
            var fillStyle = getFillStyle(series.lines, series.color, 0, plotHeight);
            if (fillStyle) {
                ctx.fillStyle = fillStyle;
                plotLineArea(series.datapoints, series.xaxis, series.yaxis);
            }

            if (lw > 0)
                plotLine(series.datapoints, 0, 0, series.xaxis, series.yaxis);
            ctx.restore();
        }

        function drawSeriesPoints(series) {
            function plotPoints(datapoints, radius, fillStyle, offset, shadow, axisx, axisy, symbol) {
                var points = datapoints.points, ps = datapoints.pointsize;

                for (var i = 0; i < points.length; i += ps) {
                    var x = points[i], y = points[i + 1];
                    if (x == null || x < axisx.min || x > axisx.max || y < axisy.min || y > axisy.max)
                        continue;

                    ctx.beginPath();
                    x = axisx.p2c(x);
                    y = axisy.p2c(y) + offset;
                    if (symbol == "circle")
                        ctx.arc(x, y, radius, 0, shadow ? Math.PI : Math.PI * 2, false);
                    else
                        symbol(ctx, x, y, radius, shadow);
                    ctx.closePath();

                    if (fillStyle) {
                        ctx.fillStyle = fillStyle;
                        ctx.fill();
                    }
                    ctx.stroke();
                }
            }

            ctx.save();
            ctx.translate(plotOffset.left, plotOffset.top);

            var lw = series.points.lineWidth,
                sw = series.shadowSize,
                radius = series.points.radius,
                symbol = series.points.symbol;

            // If the user sets the line width to 0, we change it to a very
            // small value. A line width of 0 seems to force the default of 1.
            // Doing the conditional here allows the shadow setting to still be
            // optional even with a lineWidth of 0.

            if( lw == 0 )
                lw = 0.0001;

            if (lw > 0 && sw > 0) {
                // draw shadow in two steps
                var w = sw / 2;
                ctx.lineWidth = w;
                ctx.strokeStyle = "rgba(0,0,0,0.1)";
                plotPoints(series.datapoints, radius, null, w + w/2, true,
                           series.xaxis, series.yaxis, symbol);

                ctx.strokeStyle = "rgba(0,0,0,0.2)";
                plotPoints(series.datapoints, radius, null, w/2, true,
                           series.xaxis, series.yaxis, symbol);
            }

            ctx.lineWidth = lw;
            ctx.strokeStyle = series.color;
            plotPoints(series.datapoints, radius,
                       getFillStyle(series.points, series.color), 0, false,
                       series.xaxis, series.yaxis, symbol);
            ctx.restore();
        }

        function drawBar(x, y, b, barLeft, barRight, fillStyleCallback, axisx, axisy, c, horizontal, lineWidth) {
            var left, right, bottom, top,
                drawLeft, drawRight, drawTop, drawBottom,
                tmp;

            // in horizontal mode, we start the bar from the left
            // instead of from the bottom so it appears to be
            // horizontal rather than vertical
            if (horizontal) {
                drawBottom = drawRight = drawTop = true;
                drawLeft = false;
                left = b;
                right = x;
                top = y + barLeft;
                bottom = y + barRight;

                // account for negative bars
                if (right < left) {
                    tmp = right;
                    right = left;
                    left = tmp;
                    drawLeft = true;
                    drawRight = false;
                }
            }
            else {
                drawLeft = drawRight = drawTop = true;
                drawBottom = false;
                left = x + barLeft;
                right = x + barRight;
                bottom = b;
                top = y;

                // account for negative bars
                if (top < bottom) {
                    tmp = top;
                    top = bottom;
                    bottom = tmp;
                    drawBottom = true;
                    drawTop = false;
                }
            }

            // clip
            if (right < axisx.min || left > axisx.max ||
                top < axisy.min || bottom > axisy.max)
                return;

            if (left < axisx.min) {
                left = axisx.min;
                drawLeft = false;
            }

            if (right > axisx.max) {
                right = axisx.max;
                drawRight = false;
            }

            if (bottom < axisy.min) {
                bottom = axisy.min;
                drawBottom = false;
            }

            if (top > axisy.max) {
                top = axisy.max;
                drawTop = false;
            }

            left = axisx.p2c(left);
            bottom = axisy.p2c(bottom);
            right = axisx.p2c(right);
            top = axisy.p2c(top);

            // fill the bar
            if (fillStyleCallback) {
                c.fillStyle = fillStyleCallback(bottom, top);
                c.fillRect(left, top, right - left, bottom - top)
            }

            // draw outline
            if (lineWidth > 0 && (drawLeft || drawRight || drawTop || drawBottom)) {
                c.beginPath();

                // FIXME: inline moveTo is buggy with excanvas
                c.moveTo(left, bottom);
                if (drawLeft)
                    c.lineTo(left, top);
                else
                    c.moveTo(left, top);
                if (drawTop)
                    c.lineTo(right, top);
                else
                    c.moveTo(right, top);
                if (drawRight)
                    c.lineTo(right, bottom);
                else
                    c.moveTo(right, bottom);
                if (drawBottom)
                    c.lineTo(left, bottom);
                else
                    c.moveTo(left, bottom);
                c.stroke();
            }
        }

        function drawSeriesBars(series) {
            function plotBars(datapoints, barLeft, barRight, fillStyleCallback, axisx, axisy) {
                var points = datapoints.points, ps = datapoints.pointsize;

                for (var i = 0; i < points.length; i += ps) {
                    if (points[i] == null)
                        continue;
                    drawBar(points[i], points[i + 1], points[i + 2], barLeft, barRight, fillStyleCallback, axisx, axisy, ctx, series.bars.horizontal, series.bars.lineWidth);
                }
            }

            ctx.save();
            ctx.translate(plotOffset.left, plotOffset.top);

            // FIXME: figure out a way to add shadows (for instance along the right edge)
            ctx.lineWidth = series.bars.lineWidth;
            ctx.strokeStyle = series.color;

            var barLeft;

            switch (series.bars.align) {
                case "left":
                    barLeft = 0;
                    break;
                case "right":
                    barLeft = -series.bars.barWidth;
                    break;
                default:
                    barLeft = -series.bars.barWidth / 2;
            }

            var fillStyleCallback = series.bars.fill ? function (bottom, top) { return getFillStyle(series.bars, series.color, bottom, top); } : null;
            plotBars(series.datapoints, barLeft, barLeft + series.bars.barWidth, fillStyleCallback, series.xaxis, series.yaxis);
            ctx.restore();
        }

        function getFillStyle(filloptions, seriesColor, bottom, top) {
            var fill = filloptions.fill;
            if (!fill)
                return null;

            if (filloptions.fillColor)
                return getColorOrGradient(filloptions.fillColor, bottom, top, seriesColor);

            var c = $.color.parse(seriesColor);
            c.a = typeof fill == "number" ? fill : 0.4;
            c.normalize();
            return c.toString();
        }

        function insertLegend() {

            if (options.legend.container != null) {
                $(options.legend.container).html("");
            } else {
                placeholder.find(".legend").remove();
            }

            if (!options.legend.show) {
                return;
            }

            var fragments = [], entries = [], rowStarted = false,
                lf = options.legend.labelFormatter, s, label;

            // Build a list of legend entries, with each having a label and a color

            for (var i = 0; i < series.length; ++i) {
                s = series[i];
                if (s.label) {
                    label = lf ? lf(s.label, s) : s.label;
                    if (label) {
                        entries.push({
                            label: label,
                            color: s.color
                        });
                    }
                }
            }

            // Sort the legend using either the default or a custom comparator

            if (options.legend.sorted) {
                if ($.isFunction(options.legend.sorted)) {
                    entries.sort(options.legend.sorted);
                } else if (options.legend.sorted == "reverse") {
                	entries.reverse();
                } else {
                    var ascending = options.legend.sorted != "descending";
                    entries.sort(function(a, b) {
                        return a.label == b.label ? 0 : (
                            (a.label < b.label) != ascending ? 1 : -1   // Logical XOR
                        );
                    });
                }
            }

            // Generate markup for the list of entries, in their final order

            for (var i = 0; i < entries.length; ++i) {

                var entry = entries[i];

                if (i % options.legend.noColumns == 0) {
                    if (rowStarted)
                        fragments.push('</tr>');
                    fragments.push('<tr>');
                    rowStarted = true;
                }

                fragments.push(
                    '<td class="legendColorBox"><div style="border:1px solid ' + options.legend.labelBoxBorderColor + ';padding:1px"><div style="width:4px;height:0;border:5px solid ' + entry.color + ';overflow:hidden"></div></div></td>' +
                    '<td class="legendLabel">' + entry.label + '</td>'
                );
            }

            if (rowStarted)
                fragments.push('</tr>');

            if (fragments.length == 0)
                return;

            var table = '<table style="font-size:smaller;color:' + options.grid.color + '">' + fragments.join("") + '</table>';
            if (options.legend.container != null)
                $(options.legend.container).html(table);
            else {
                var pos = "",
                    p = options.legend.position,
                    m = options.legend.margin;
                if (m[0] == null)
                    m = [m, m];
                if (p.charAt(0) == "n")
                    pos += 'top:' + (m[1] + plotOffset.top) + 'px;';
                else if (p.charAt(0) == "s")
                    pos += 'bottom:' + (m[1] + plotOffset.bottom) + 'px;';
                if (p.charAt(1) == "e")
                    pos += 'right:' + (m[0] + plotOffset.right) + 'px;';
                else if (p.charAt(1) == "w")
                    pos += 'left:' + (m[0] + plotOffset.left) + 'px;';
                var legend = $('<div class="legend">' + table.replace('style="', 'style="position:absolute;' + pos +';') + '</div>').appendTo(placeholder);
                if (options.legend.backgroundOpacity != 0.0) {
                    // put in the transparent background
                    // separately to avoid blended labels and
                    // label boxes
                    var c = options.legend.backgroundColor;
                    if (c == null) {
                        c = options.grid.backgroundColor;
                        if (c && typeof c == "string")
                            c = $.color.parse(c);
                        else
                            c = $.color.extract(legend, 'background-color');
                        c.a = 1;
                        c = c.toString();
                    }
                    var div = legend.children();
                    $('<div style="position:absolute;width:' + div.width() + 'px;height:' + div.height() + 'px;' + pos +'background-color:' + c + ';"> </div>').prependTo(legend).css('opacity', options.legend.backgroundOpacity);
                }
            }
        }


        // interactive features

        var highlights = [],
            redrawTimeout = null;

        // returns the data item the mouse is over, or null if none is found
        function findNearbyItem(mouseX, mouseY, seriesFilter) {
            var maxDistance = options.grid.mouseActiveRadius,
                smallestDistance = maxDistance * maxDistance + 1,
                item = null, foundPoint = false, i, j, ps;

            for (i = series.length - 1; i >= 0; --i) {
                if (!seriesFilter(series[i]))
                    continue;

                var s = series[i],
                    axisx = s.xaxis,
                    axisy = s.yaxis,
                    points = s.datapoints.points,
                    mx = axisx.c2p(mouseX), // precompute some stuff to make the loop faster
                    my = axisy.c2p(mouseY),
                    maxx = maxDistance / axisx.scale,
                    maxy = maxDistance / axisy.scale;

                ps = s.datapoints.pointsize;
                // with inverse transforms, we can't use the maxx/maxy
                // optimization, sadly
                if (axisx.options.inverseTransform)
                    maxx = Number.MAX_VALUE;
                if (axisy.options.inverseTransform)
                    maxy = Number.MAX_VALUE;

                if (s.lines.show || s.points.show) {
                    for (j = 0; j < points.length; j += ps) {
                        var x = points[j], y = points[j + 1];
                        if (x == null)
                            continue;

                        // For points and lines, the cursor must be within a
                        // certain distance to the data point
                        if (x - mx > maxx || x - mx < -maxx ||
                            y - my > maxy || y - my < -maxy)
                            continue;

                        // We have to calculate distances in pixels, not in
                        // data units, because the scales of the axes may be different
                        var dx = Math.abs(axisx.p2c(x) - mouseX),
                            dy = Math.abs(axisy.p2c(y) - mouseY),
                            dist = dx * dx + dy * dy; // we save the sqrt

                        // use <= to ensure last point takes precedence
                        // (last generally means on top of)
                        if (dist < smallestDistance) {
                            smallestDistance = dist;
                            item = [i, j / ps];
                        }
                    }
                }

                if (s.bars.show && !item) { // no other point can be nearby

                    var barLeft, barRight;

                    switch (s.bars.align) {
                        case "left":
                            barLeft = 0;
                            break;
                        case "right":
                            barLeft = -s.bars.barWidth;
                            break;
                        default:
                            barLeft = -s.bars.barWidth / 2;
                    }

                    barRight = barLeft + s.bars.barWidth;

                    for (j = 0; j < points.length; j += ps) {
                        var x = points[j], y = points[j + 1], b = points[j + 2];
                        if (x == null)
                            continue;

                        // for a bar graph, the cursor must be inside the bar
                        if (series[i].bars.horizontal ?
                            (mx <= Math.max(b, x) && mx >= Math.min(b, x) &&
                             my >= y + barLeft && my <= y + barRight) :
                            (mx >= x + barLeft && mx <= x + barRight &&
                             my >= Math.min(b, y) && my <= Math.max(b, y)))
                                item = [i, j / ps];
                    }
                }
            }

            if (item) {
                i = item[0];
                j = item[1];
                ps = series[i].datapoints.pointsize;

                return { datapoint: series[i].datapoints.points.slice(j * ps, (j + 1) * ps),
                         dataIndex: j,
                         series: series[i],
                         seriesIndex: i };
            }

            return null;
        }

        function onMouseMove(e) {
            if (options.grid.hoverable)
                triggerClickHoverEvent("plothover", e,
                                       function (s) { return s["hoverable"] != false; });
        }

        function onMouseLeave(e) {
            if (options.grid.hoverable)
                triggerClickHoverEvent("plothover", e,
                                       function (s) { return false; });
        }

        function onClick(e) {
          if (plot.isSelecting) {
            return;
          }

          triggerClickHoverEvent("plotclick", e, function (s) { return s["clickable"] != false; });
        }

        // trigger click or hover event (they send the same parameters
        // so we share their code)
        function triggerClickHoverEvent(eventname, event, seriesFilter) {
            var offset = eventHolder.offset(),
                canvasX = event.pageX - offset.left - plotOffset.left,
                canvasY = event.pageY - offset.top - plotOffset.top,
            pos = canvasToAxisCoords({ left: canvasX, top: canvasY });

            pos.pageX = event.pageX;
            pos.pageY = event.pageY;

            // Add ctrlKey and metaKey to event
            pos.ctrlKey = event.ctrlKey;
            pos.metaKey = event.metaKey;

            var item = findNearbyItem(canvasX, canvasY, seriesFilter);

            if (item) {
                // fill in mouse pos for any listeners out there
                item.pageX = parseInt(item.series.xaxis.p2c(item.datapoint[0]) + offset.left + plotOffset.left, 10);
                item.pageY = parseInt(item.series.yaxis.p2c(item.datapoint[1]) + offset.top + plotOffset.top, 10);
            }

            if (options.grid.autoHighlight) {
                // clear auto-highlights
                for (var i = 0; i < highlights.length; ++i) {
                    var h = highlights[i];
                    if (h.auto == eventname &&
                        !(item && h.series == item.series &&
                          h.point[0] == item.datapoint[0] &&
                          h.point[1] == item.datapoint[1]))
                        unhighlight(h.series, h.point);
                }

                if (item)
                    highlight(item.series, item.datapoint, eventname);
            }

            placeholder.trigger(eventname, [ pos, item ]);
        }

        function triggerRedrawOverlay() {
            var t = options.interaction.redrawOverlayInterval;
            if (t == -1) {      // skip event queue
                drawOverlay();
                return;
            }

            if (!redrawTimeout)
                redrawTimeout = setTimeout(drawOverlay, t);
        }

        function drawOverlay() {
            redrawTimeout = null;

            // draw highlights
            octx.save();
            overlay.clear();
            octx.translate(plotOffset.left, plotOffset.top);

            var i, hi;
            for (i = 0; i < highlights.length; ++i) {
                hi = highlights[i];

                if (hi.series.bars.show)
                    drawBarHighlight(hi.series, hi.point);
                else
                    drawPointHighlight(hi.series, hi.point);
            }
            octx.restore();

            executeHooks(hooks.drawOverlay, [octx]);
        }

        function highlight(s, point, auto) {
            if (typeof s == "number")
                s = series[s];

            if (typeof point == "number") {
                var ps = s.datapoints.pointsize;
                point = s.datapoints.points.slice(ps * point, ps * (point + 1));
            }

            var i = indexOfHighlight(s, point);
            if (i == -1) {
                highlights.push({ series: s, point: point, auto: auto });

                triggerRedrawOverlay();
            }
            else if (!auto)
                highlights[i].auto = false;
        }

        function unhighlight(s, point) {
            if (s == null && point == null) {
                highlights = [];
                triggerRedrawOverlay();
                return;
            }

            if (typeof s == "number")
                s = series[s];

            if (typeof point == "number") {
                var ps = s.datapoints.pointsize;
                point = s.datapoints.points.slice(ps * point, ps * (point + 1));
            }

            var i = indexOfHighlight(s, point);
            if (i != -1) {
                highlights.splice(i, 1);

                triggerRedrawOverlay();
            }
        }

        function indexOfHighlight(s, p) {
            for (var i = 0; i < highlights.length; ++i) {
                var h = highlights[i];
                if (h.series == s && h.point[0] == p[0]
                    && h.point[1] == p[1])
                    return i;
            }
            return -1;
        }

        function drawPointHighlight(series, point) {
            var x = point[0], y = point[1],
                axisx = series.xaxis, axisy = series.yaxis,
                highlightColor = (typeof series.highlightColor === "string") ? series.highlightColor : $.color.parse(series.color).scale('a', 0.5).toString();

            if (x < axisx.min || x > axisx.max || y < axisy.min || y > axisy.max)
                return;

            var pointRadius = series.points.radius + series.points.lineWidth / 2;
            octx.lineWidth = pointRadius;
            octx.strokeStyle = highlightColor;
            var radius = 1.5 * pointRadius;
            x = axisx.p2c(x);
            y = axisy.p2c(y);

            octx.beginPath();
            if (series.points.symbol == "circle")
                octx.arc(x, y, radius, 0, 2 * Math.PI, false);
            else
                series.points.symbol(octx, x, y, radius, false);
            octx.closePath();
            octx.stroke();
        }

        function drawBarHighlight(series, point) {
            var highlightColor = (typeof series.highlightColor === "string") ? series.highlightColor : $.color.parse(series.color).scale('a', 0.5).toString(),
                fillStyle = highlightColor,
                barLeft;

            switch (series.bars.align) {
                case "left":
                    barLeft = 0;
                    break;
                case "right":
                    barLeft = -series.bars.barWidth;
                    break;
                default:
                    barLeft = -series.bars.barWidth / 2;
            }

            octx.lineWidth = series.bars.lineWidth;
            octx.strokeStyle = highlightColor;

            drawBar(point[0], point[1], point[2] || 0, barLeft, barLeft + series.bars.barWidth,
                    function () { return fillStyle; }, series.xaxis, series.yaxis, octx, series.bars.horizontal, series.bars.lineWidth);
        }

        function getColorOrGradient(spec, bottom, top, defaultColor) {
            if (typeof spec == "string")
                return spec;
            else {
                // assume this is a gradient spec; IE currently only
                // supports a simple vertical gradient properly, so that's
                // what we support too
                var gradient = ctx.createLinearGradient(0, top, 0, bottom);

                for (var i = 0, l = spec.colors.length; i < l; ++i) {
                    var c = spec.colors[i];
                    if (typeof c != "string") {
                        var co = $.color.parse(defaultColor);
                        if (c.brightness != null)
                            co = co.scale('rgb', c.brightness);
                        if (c.opacity != null)
                            co.a *= c.opacity;
                        c = co.toString();
                    }
                    gradient.addColorStop(i / (l - 1), c);
                }

                return gradient;
            }
        }
    }

    // Add the plot function to the top level of the jQuery object

    $.plot = function(placeholder, data, options) {
        //var t0 = new Date();
        var plot = new Plot($(placeholder), data, options, $.plot.plugins);
        //(window.console ? console.log : alert)("time used (msecs): " + ((new Date()).getTime() - t0.getTime()));
        return plot;
    };

    $.plot.version = "0.8.3";

    $.plot.plugins = [];

    // Also add the plot function as a chainable property

    $.fn.plot = function(data, options) {
        return this.each(function() {
            $.plot(this, data, options);
        });
    };

    // round to nearby lower multiple of base
    function floorInBase(n, base) {
        return base * Math.floor(n / base);
    }

})(jQuery);


/***/ }),

/***/ 1316:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (immutable) */ __webpack_exports__["importPluginModule"] = importPluginModule;
/* harmony export (immutable) */ __webpack_exports__["loadPluginCss"] = loadPluginCss;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_systemjs_dist_system_js__ = __webpack_require__(1419);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_systemjs_dist_system_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_systemjs_dist_system_js__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_lodash__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_app_plugins_sdk__ = __webpack_require__(1305);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_app_core_utils_kbn__ = __webpack_require__(464);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_moment__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_moment___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_moment__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_angular__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_angular___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_angular__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_jquery__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_jquery___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6_jquery__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_app_core_config__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_app_core_time_series2__ = __webpack_require__(1309);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9_app_core_table_model__ = __webpack_require__(1310);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10_app_core_core__ = __webpack_require__(465);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11_app_core_utils_datemath__ = __webpack_require__(467);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12_app_core_utils_file_export__ = __webpack_require__(1323);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13_app_core_utils_flatten__ = __webpack_require__(1328);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14_app_core_utils_ticks__ = __webpack_require__(1314);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15_app_features_dashboard_impression_store__ = __webpack_require__(1312);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__built_in_plugins__ = __webpack_require__(1430);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17_d3__ = __webpack_require__(470);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18_rxjs_Observable__ = __webpack_require__(466);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18_rxjs_Observable___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_18_rxjs_Observable__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19_rxjs_Subject__ = __webpack_require__(1515);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19_rxjs_Subject___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_19_rxjs_Subject__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_20_rxjs_add_observable_empty__ = __webpack_require__(1518);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_20_rxjs_add_observable_empty___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_20_rxjs_add_observable_empty__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_21_rxjs_add_observable_from__ = __webpack_require__(1520);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_21_rxjs_add_observable_from___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_21_rxjs_add_observable_from__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_22_rxjs_add_operator_map__ = __webpack_require__(1529);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_22_rxjs_add_operator_map___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_22_rxjs_add_operator_map__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_23_rxjs_add_operator_combineAll__ = __webpack_require__(1532);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_23_rxjs_add_operator_combineAll___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_23_rxjs_add_operator_combineAll__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_24_vendor_flot_jquery_flot__ = __webpack_require__(1315);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_24_vendor_flot_jquery_flot___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_24_vendor_flot_jquery_flot__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_25_vendor_flot_jquery_flot_selection__ = __webpack_require__(1334);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_25_vendor_flot_jquery_flot_selection___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_25_vendor_flot_jquery_flot_selection__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_26_vendor_flot_jquery_flot_time__ = __webpack_require__(1335);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_26_vendor_flot_jquery_flot_time___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_26_vendor_flot_jquery_flot_time__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_27_vendor_flot_jquery_flot_stack__ = __webpack_require__(1336);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_27_vendor_flot_jquery_flot_stack___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_27_vendor_flot_jquery_flot_stack__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_28_vendor_flot_jquery_flot_pie__ = __webpack_require__(1539);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_28_vendor_flot_jquery_flot_pie___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_28_vendor_flot_jquery_flot_pie__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_29_vendor_flot_jquery_flot_stackpercent__ = __webpack_require__(1337);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_29_vendor_flot_jquery_flot_stackpercent___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_29_vendor_flot_jquery_flot_stackpercent__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_30_vendor_flot_jquery_flot_fillbelow__ = __webpack_require__(1338);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_30_vendor_flot_jquery_flot_fillbelow___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_30_vendor_flot_jquery_flot_fillbelow__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_31_vendor_flot_jquery_flot_crosshair__ = __webpack_require__(1339);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_31_vendor_flot_jquery_flot_crosshair___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_31_vendor_flot_jquery_flot_crosshair__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_32_vendor_flot_jquery_flot_dashes__ = __webpack_require__(1340);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_32_vendor_flot_jquery_flot_dashes___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_32_vendor_flot_jquery_flot_dashes__);


















// rxjs


// these imports add functions to Observable




__WEBPACK_IMPORTED_MODULE_0_systemjs_dist_system_js___default.a.config({
    baseURL: 'public',
    defaultExtension: 'js',
    packages: {
        'plugins': {
            defaultExtension: 'js'
        }
    },
    map: {
        text: 'vendor/plugin-text/text.js',
        css: 'vendor/plugin-css/css.js'
    },
    meta: {
        '*': {
            esModule: true,
            authorization: true,
        }
    }
});
// add cache busting
var systemLocate = __WEBPACK_IMPORTED_MODULE_0_systemjs_dist_system_js___default.a.locate;
__WEBPACK_IMPORTED_MODULE_0_systemjs_dist_system_js___default.a.cacheBust = '?bust=' + Date.now();
__WEBPACK_IMPORTED_MODULE_0_systemjs_dist_system_js___default.a.locate = function (load) {
    var System = this;
    return Promise.resolve(systemLocate.call(this, load)).then(function (address) {
        return address + System.cacheBust;
    });
};
function exposeToPlugin(name, component) {
    __WEBPACK_IMPORTED_MODULE_0_systemjs_dist_system_js___default.a.registerDynamic(name, [], true, function (require, exports, module) {
        module.exports = component;
    });
}
exposeToPlugin('lodash', __WEBPACK_IMPORTED_MODULE_1_lodash___default.a);
exposeToPlugin('moment', __WEBPACK_IMPORTED_MODULE_4_moment___default.a);
exposeToPlugin('jquery', __WEBPACK_IMPORTED_MODULE_6_jquery___default.a);
exposeToPlugin('angular', __WEBPACK_IMPORTED_MODULE_5_angular___default.a);
exposeToPlugin('d3', __WEBPACK_IMPORTED_MODULE_17_d3__);
exposeToPlugin('rxjs/Subject', __WEBPACK_IMPORTED_MODULE_19_rxjs_Subject__["Subject"]);
exposeToPlugin('rxjs/Observable', __WEBPACK_IMPORTED_MODULE_18_rxjs_Observable__["Observable"]);
// backward compatible path
exposeToPlugin('vendor/npm/rxjs/Rx', {
    Subject: __WEBPACK_IMPORTED_MODULE_19_rxjs_Subject__["Subject"],
    Observable: __WEBPACK_IMPORTED_MODULE_18_rxjs_Observable__["Observable"]
});
exposeToPlugin('app/features/dashboard/impression_store', {
    impressions: __WEBPACK_IMPORTED_MODULE_15_app_features_dashboard_impression_store__["impressions"],
    __esModule: true
});
exposeToPlugin('app/plugins/sdk', __WEBPACK_IMPORTED_MODULE_2_app_plugins_sdk__);
exposeToPlugin('app/core/utils/datemath', __WEBPACK_IMPORTED_MODULE_11_app_core_utils_datemath__);
exposeToPlugin('app/core/utils/file_export', __WEBPACK_IMPORTED_MODULE_12_app_core_utils_file_export__);
exposeToPlugin('app/core/utils/flatten', __WEBPACK_IMPORTED_MODULE_13_app_core_utils_flatten__);
exposeToPlugin('app/core/utils/kbn', __WEBPACK_IMPORTED_MODULE_3_app_core_utils_kbn__["default"]);
exposeToPlugin('app/core/utils/ticks', __WEBPACK_IMPORTED_MODULE_14_app_core_utils_ticks__);
exposeToPlugin('app/core/config', __WEBPACK_IMPORTED_MODULE_7_app_core_config__["default"]);
exposeToPlugin('app/core/time_series', __WEBPACK_IMPORTED_MODULE_8_app_core_time_series2__["a" /* default */]);
exposeToPlugin('app/core/time_series2', __WEBPACK_IMPORTED_MODULE_8_app_core_time_series2__["a" /* default */]);
exposeToPlugin('app/core/table_model', __WEBPACK_IMPORTED_MODULE_9_app_core_table_model__["default"]);
exposeToPlugin('app/core/app_events', __WEBPACK_IMPORTED_MODULE_10_app_core_core__["appEvents"]);
exposeToPlugin('app/core/core_module', __WEBPACK_IMPORTED_MODULE_10_app_core_core__["coreModule"]);
exposeToPlugin('app/core/core', {
    coreModule: __WEBPACK_IMPORTED_MODULE_10_app_core_core__["coreModule"],
    appEvents: __WEBPACK_IMPORTED_MODULE_10_app_core_core__["appEvents"],
    contextSrv: __WEBPACK_IMPORTED_MODULE_10_app_core_core__["contextSrv"],
    __esModule: true
});









var flotDeps = [
    'jquery.flot', 'jquery.flot.pie', 'jquery.flot.time', 'jquery.flot.fillbelow', 'jquery.flot.crosshair',
    'jquery.flot.stack', 'jquery.flot.selection', 'jquery.flot.stackpercent', 'jquery.flot.events'
];
for (var _i = 0, flotDeps_1 = flotDeps; _i < flotDeps_1.length; _i++) {
    var flotDep = flotDeps_1[_i];
    exposeToPlugin(flotDep, { fakeDep: 1 });
}
function importPluginModule(path) {
    var builtIn = __WEBPACK_IMPORTED_MODULE_16__built_in_plugins__["a" /* default */][path];
    if (builtIn) {
        return Promise.resolve(builtIn);
    }
    return __WEBPACK_IMPORTED_MODULE_0_systemjs_dist_system_js___default.a.import(path);
}
function loadPluginCss(options) {
    if (__WEBPACK_IMPORTED_MODULE_7_app_core_config__["default"].bootData.user.lightTheme) {
        __WEBPACK_IMPORTED_MODULE_0_systemjs_dist_system_js___default.a.import(options.light + '!css');
    }
    else {
        __WEBPACK_IMPORTED_MODULE_0_systemjs_dist_system_js___default.a.import(options.dark + '!css');
    }
}


/***/ }),

/***/ 1317:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_app_core_utils_version__ = __webpack_require__(1329);


var index = [];
var categories = {
    Combine: [],
    Transform: [],
    Calculate: [],
    Filter: [],
    Special: [],
};
function addFuncDef(funcDef) {
    funcDef.params = funcDef.params || [];
    funcDef.defaultParams = funcDef.defaultParams || [];
    if (funcDef.category) {
        funcDef.category.push(funcDef);
    }
    index[funcDef.name] = funcDef;
    index[funcDef.shortName || funcDef.name] = funcDef;
}
var optionalSeriesRefArgs = [
    { name: 'other', type: 'value_or_series', optional: true },
    { name: 'other', type: 'value_or_series', optional: true },
    { name: 'other', type: 'value_or_series', optional: true },
    { name: 'other', type: 'value_or_series', optional: true },
    { name: 'other', type: 'value_or_series', optional: true },
];
addFuncDef({
    name: 'scaleToSeconds',
    category: categories.Transform,
    params: [{ name: 'seconds', type: 'int' }],
    defaultParams: [1],
});
addFuncDef({
    name: 'perSecond',
    category: categories.Transform,
    params: [{ name: 'max value', type: 'int', optional: true }],
    defaultParams: [],
});
addFuncDef({
    name: 'holtWintersForecast',
    category: categories.Calculate,
});
addFuncDef({
    name: 'holtWintersConfidenceBands',
    category: categories.Calculate,
    params: [{ name: 'delta', type: 'int' }],
    defaultParams: [3],
});
addFuncDef({
    name: 'holtWintersAberration',
    category: categories.Calculate,
    params: [{ name: 'delta', type: 'int' }],
    defaultParams: [3],
});
addFuncDef({
    name: 'nPercentile',
    category: categories.Calculate,
    params: [{ name: 'Nth percentile', type: 'int' }],
    defaultParams: [95],
});
addFuncDef({
    name: 'diffSeries',
    params: optionalSeriesRefArgs,
    defaultParams: ['#A'],
    category: categories.Calculate,
});
addFuncDef({
    name: 'stddevSeries',
    params: optionalSeriesRefArgs,
    defaultParams: [''],
    category: categories.Calculate,
});
addFuncDef({
    name: 'divideSeries',
    params: optionalSeriesRefArgs,
    defaultParams: ['#A'],
    category: categories.Calculate,
});
addFuncDef({
    name: 'multiplySeries',
    params: optionalSeriesRefArgs,
    defaultParams: ['#A'],
    category: categories.Calculate,
});
addFuncDef({
    name: 'asPercent',
    params: optionalSeriesRefArgs,
    defaultParams: ['#A'],
    category: categories.Calculate,
});
addFuncDef({
    name: 'group',
    params: optionalSeriesRefArgs,
    defaultParams: ['#A', '#B'],
    category: categories.Combine,
});
addFuncDef({
    name: 'sumSeries',
    shortName: 'sum',
    category: categories.Combine,
    params: optionalSeriesRefArgs,
    defaultParams: [''],
});
addFuncDef({
    name: 'averageSeries',
    shortName: 'avg',
    category: categories.Combine,
    params: optionalSeriesRefArgs,
    defaultParams: [''],
});
addFuncDef({
    name: 'rangeOfSeries',
    category: categories.Combine,
});
addFuncDef({
    name: 'percentileOfSeries',
    category: categories.Combine,
    params: [{ name: 'n', type: 'int' }, { name: 'interpolate', type: 'boolean', options: ['true', 'false'] }],
    defaultParams: [95, 'false'],
});
addFuncDef({
    name: 'sumSeriesWithWildcards',
    category: categories.Combine,
    params: [
        { name: 'node', type: 'int' },
        { name: 'node', type: 'int', optional: true },
        { name: 'node', type: 'int', optional: true },
        { name: 'node', type: 'int', optional: true },
    ],
    defaultParams: [3],
});
addFuncDef({
    name: 'maxSeries',
    shortName: 'max',
    category: categories.Combine,
});
addFuncDef({
    name: 'minSeries',
    shortName: 'min',
    category: categories.Combine,
});
addFuncDef({
    name: 'averageSeriesWithWildcards',
    category: categories.Combine,
    params: [{ name: 'node', type: 'int' }, { name: 'node', type: 'int', optional: true }],
    defaultParams: [3],
});
addFuncDef({
    name: 'alias',
    category: categories.Special,
    params: [{ name: 'alias', type: 'string' }],
    defaultParams: ['alias'],
});
addFuncDef({
    name: 'aliasSub',
    category: categories.Special,
    params: [{ name: 'search', type: 'string' }, { name: 'replace', type: 'string' }],
    defaultParams: ['', '\\1'],
});
addFuncDef({
    name: 'stacked',
    category: categories.Special,
    params: [{ name: 'stack', type: 'string' }],
    defaultParams: ['stacked'],
});
addFuncDef({
    name: 'consolidateBy',
    category: categories.Special,
    params: [
        {
            name: 'function',
            type: 'string',
            options: ['sum', 'average', 'min', 'max'],
        },
    ],
    defaultParams: ['max'],
});
addFuncDef({
    name: 'cumulative',
    category: categories.Special,
    params: [],
    defaultParams: [],
});
addFuncDef({
    name: 'groupByNode',
    category: categories.Special,
    params: [
        {
            name: 'node',
            type: 'int',
            options: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12],
        },
        {
            name: 'function',
            type: 'string',
            options: ['sum', 'avg', 'maxSeries'],
        },
    ],
    defaultParams: [3, 'sum'],
});
addFuncDef({
    name: 'aliasByNode',
    category: categories.Special,
    params: [
        { name: 'node', type: 'int', options: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12] },
        { name: 'node', type: 'int', options: [0, -1, -2, -3, -4, -5, -6, -7], optional: true },
        { name: 'node', type: 'int', options: [0, -1, -2, -3, -4, -5, -6, -7], optional: true },
        { name: 'node', type: 'int', options: [0, -1, -2, -3, -4, -5, -6, -7], optional: true },
    ],
    defaultParams: [3],
});
addFuncDef({
    name: 'substr',
    category: categories.Special,
    params: [
        { name: 'start', type: 'int', options: [-6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12] },
        { name: 'stop', type: 'int', options: [-6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12] },
    ],
    defaultParams: [0, 0],
});
addFuncDef({
    name: 'sortByName',
    category: categories.Special,
    params: [{ name: 'natural', type: 'boolean', options: ['true', 'false'], optional: true }],
    defaultParams: ['false'],
});
addFuncDef({
    name: 'sortByMaxima',
    category: categories.Special,
});
addFuncDef({
    name: 'sortByMinima',
    category: categories.Special,
});
addFuncDef({
    name: 'sortByTotal',
    category: categories.Special,
});
addFuncDef({
    name: 'aliasByMetric',
    category: categories.Special,
});
addFuncDef({
    name: 'randomWalk',
    fake: true,
    category: categories.Special,
    params: [{ name: 'name', type: 'string' }],
    defaultParams: ['randomWalk'],
});
addFuncDef({
    name: 'countSeries',
    category: categories.Special,
});
addFuncDef({
    name: 'constantLine',
    category: categories.Special,
    params: [{ name: 'value', type: 'int' }],
    defaultParams: [10],
});
addFuncDef({
    name: 'cactiStyle',
    category: categories.Special,
});
addFuncDef({
    name: 'keepLastValue',
    category: categories.Special,
    params: [{ name: 'n', type: 'int' }],
    defaultParams: [100],
});
addFuncDef({
    name: 'changed',
    category: categories.Special,
    params: [],
    defaultParams: [],
});
addFuncDef({
    name: 'scale',
    category: categories.Transform,
    params: [{ name: 'factor', type: 'int' }],
    defaultParams: [1],
});
addFuncDef({
    name: 'offset',
    category: categories.Transform,
    params: [{ name: 'amount', type: 'int' }],
    defaultParams: [10],
});
addFuncDef({
    name: 'transformNull',
    category: categories.Transform,
    params: [{ name: 'amount', type: 'int' }],
    defaultParams: [0],
});
addFuncDef({
    name: 'integral',
    category: categories.Transform,
});
addFuncDef({
    name: 'derivative',
    category: categories.Transform,
});
addFuncDef({
    name: 'nonNegativeDerivative',
    category: categories.Transform,
    params: [{ name: 'max value or 0', type: 'int', optional: true }],
    defaultParams: [''],
});
addFuncDef({
    name: 'timeShift',
    category: categories.Transform,
    params: [{ name: 'amount', type: 'select', options: ['1h', '6h', '12h', '1d', '2d', '7d', '14d', '30d'] }],
    defaultParams: ['1d'],
});
addFuncDef({
    name: 'timeStack',
    category: categories.Transform,
    params: [
        { name: 'timeShiftUnit', type: 'select', options: ['1h', '6h', '12h', '1d', '2d', '7d', '14d', '30d'] },
        { name: 'timeShiftStart', type: 'int' },
        { name: 'timeShiftEnd', type: 'int' },
    ],
    defaultParams: ['1d', 0, 7],
});
addFuncDef({
    name: 'summarize',
    category: categories.Transform,
    params: [
        { name: 'interval', type: 'string' },
        { name: 'func', type: 'select', options: ['sum', 'avg', 'min', 'max', 'last'] },
        { name: 'alignToFrom', type: 'boolean', optional: true, options: ['false', 'true'] },
    ],
    defaultParams: ['1h', 'sum', 'false'],
});
addFuncDef({
    name: 'smartSummarize',
    category: categories.Transform,
    params: [
        { name: 'interval', type: 'string' },
        { name: 'func', type: 'select', options: ['sum', 'avg', 'min', 'max', 'last'] },
    ],
    defaultParams: ['1h', 'sum'],
});
addFuncDef({
    name: 'absolute',
    category: categories.Transform,
});
addFuncDef({
    name: 'hitcount',
    category: categories.Transform,
    params: [{ name: 'interval', type: 'string' }],
    defaultParams: ['10s'],
});
addFuncDef({
    name: 'log',
    category: categories.Transform,
    params: [{ name: 'base', type: 'int' }],
    defaultParams: ['10'],
});
addFuncDef({
    name: 'averageAbove',
    category: categories.Filter,
    params: [{ name: 'n', type: 'int' }],
    defaultParams: [25],
});
addFuncDef({
    name: 'averageBelow',
    category: categories.Filter,
    params: [{ name: 'n', type: 'int' }],
    defaultParams: [25],
});
addFuncDef({
    name: 'currentAbove',
    category: categories.Filter,
    params: [{ name: 'n', type: 'int' }],
    defaultParams: [25],
});
addFuncDef({
    name: 'currentBelow',
    category: categories.Filter,
    params: [{ name: 'n', type: 'int' }],
    defaultParams: [25],
});
addFuncDef({
    name: 'maximumAbove',
    category: categories.Filter,
    params: [{ name: 'value', type: 'int' }],
    defaultParams: [0],
});
addFuncDef({
    name: 'maximumBelow',
    category: categories.Filter,
    params: [{ name: 'value', type: 'int' }],
    defaultParams: [0],
});
addFuncDef({
    name: 'minimumAbove',
    category: categories.Filter,
    params: [{ name: 'value', type: 'int' }],
    defaultParams: [0],
});
addFuncDef({
    name: 'minimumBelow',
    category: categories.Filter,
    params: [{ name: 'value', type: 'int' }],
    defaultParams: [0],
});
addFuncDef({
    name: 'limit',
    category: categories.Filter,
    params: [{ name: 'n', type: 'int' }],
    defaultParams: [5],
});
addFuncDef({
    name: 'mostDeviant',
    category: categories.Filter,
    params: [{ name: 'n', type: 'int' }],
    defaultParams: [10],
});
addFuncDef({
    name: 'exclude',
    category: categories.Filter,
    params: [{ name: 'exclude', type: 'string' }],
    defaultParams: ['exclude'],
});
addFuncDef({
    name: 'highestCurrent',
    category: categories.Filter,
    params: [{ name: 'count', type: 'int' }],
    defaultParams: [5],
});
addFuncDef({
    name: 'highestMax',
    category: categories.Filter,
    params: [{ name: 'count', type: 'int' }],
    defaultParams: [5],
});
addFuncDef({
    name: 'lowestCurrent',
    category: categories.Filter,
    params: [{ name: 'count', type: 'int' }],
    defaultParams: [5],
});
addFuncDef({
    name: 'movingAverage',
    category: categories.Filter,
    params: [
        { name: 'windowSize', type: 'int_or_interval', options: ['5', '7', '10', '5min', '10min', '30min', '1hour'] },
    ],
    defaultParams: [10],
});
addFuncDef({
    name: 'movingMedian',
    category: categories.Filter,
    params: [
        { name: 'windowSize', type: 'int_or_interval', options: ['5', '7', '10', '5min', '10min', '30min', '1hour'] },
    ],
    defaultParams: ['5'],
});
addFuncDef({
    name: 'stdev',
    category: categories.Filter,
    params: [{ name: 'n', type: 'int' }, { name: 'tolerance', type: 'int' }],
    defaultParams: [5, 0.1],
});
addFuncDef({
    name: 'highestAverage',
    category: categories.Filter,
    params: [{ name: 'count', type: 'int' }],
    defaultParams: [5],
});
addFuncDef({
    name: 'lowestAverage',
    category: categories.Filter,
    params: [{ name: 'count', type: 'int' }],
    defaultParams: [5],
});
addFuncDef({
    name: 'removeAbovePercentile',
    category: categories.Filter,
    params: [{ name: 'n', type: 'int' }],
    defaultParams: [5],
});
addFuncDef({
    name: 'removeAboveValue',
    category: categories.Filter,
    params: [{ name: 'n', type: 'int' }],
    defaultParams: [5],
});
addFuncDef({
    name: 'removeBelowPercentile',
    category: categories.Filter,
    params: [{ name: 'n', type: 'int' }],
    defaultParams: [5],
});
addFuncDef({
    name: 'removeBelowValue',
    category: categories.Filter,
    params: [{ name: 'n', type: 'int' }],
    defaultParams: [5],
});
addFuncDef({
    name: 'useSeriesAbove',
    category: categories.Filter,
    params: [{ name: 'value', type: 'int' }, { name: 'search', type: 'string' }, { name: 'replace', type: 'string' }],
    defaultParams: [0, 'search', 'replace'],
});
////////////////////
// Graphite 1.0.x //
////////////////////
addFuncDef({
    name: 'aggregateLine',
    category: categories.Combine,
    params: [{ name: 'func', type: 'select', options: ['sum', 'avg', 'min', 'max', 'last'] }],
    defaultParams: ['avg'],
    version: '1.0',
});
addFuncDef({
    name: 'averageOutsidePercentile',
    category: categories.Filter,
    params: [{ name: 'n', type: 'int' }],
    defaultParams: [95],
    version: '1.0',
});
addFuncDef({
    name: 'delay',
    category: categories.Transform,
    params: [{ name: 'steps', type: 'int' }],
    defaultParams: [1],
    version: '1.0',
});
addFuncDef({
    name: 'exponentialMovingAverage',
    category: categories.Calculate,
    params: [
        { name: 'windowSize', type: 'int_or_interval', options: ['5', '7', '10', '5min', '10min', '30min', '1hour'] },
    ],
    defaultParams: [10],
    version: '1.0',
});
addFuncDef({
    name: 'fallbackSeries',
    category: categories.Special,
    params: [{ name: 'fallback', type: 'string' }],
    defaultParams: ['constantLine(0)'],
    version: '1.0',
});
addFuncDef({
    name: 'grep',
    category: categories.Filter,
    params: [{ name: 'grep', type: 'string' }],
    defaultParams: ['grep'],
    version: '1.0',
});
addFuncDef({
    name: 'groupByNodes',
    category: categories.Special,
    params: [
        {
            name: 'function',
            type: 'string',
            options: ['sum', 'avg', 'maxSeries'],
        },
        { name: 'node', type: 'int', options: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12] },
        { name: 'node', type: 'int', options: [0, -1, -2, -3, -4, -5, -6, -7], optional: true },
        { name: 'node', type: 'int', options: [0, -1, -2, -3, -4, -5, -6, -7], optional: true },
        { name: 'node', type: 'int', options: [0, -1, -2, -3, -4, -5, -6, -7], optional: true },
    ],
    defaultParams: ['sum', 3],
    version: '1.0',
});
addFuncDef({
    name: 'integralByInterval',
    category: categories.Transform,
    params: [{ name: 'intervalUnit', type: 'select', options: ['1h', '6h', '12h', '1d', '2d', '7d', '14d', '30d'] }],
    defaultParams: ['1d'],
    version: '1.0',
});
addFuncDef({
    name: 'interpolate',
    category: categories.Transform,
    params: [{ name: 'limit', type: 'int', optional: true }],
    defaultParams: [],
    version: '1.0',
});
addFuncDef({
    name: 'invert',
    category: categories.Transform,
    version: '1.0',
});
addFuncDef({
    name: 'isNonNull',
    category: categories.Combine,
    version: '1.0',
});
addFuncDef({
    name: 'linearRegression',
    category: categories.Calculate,
    params: [
        {
            name: 'startSourceAt',
            type: 'select',
            options: ['-1h', '-6h', '-12h', '-1d', '-2d', '-7d', '-14d', '-30d'],
            optional: true,
        },
        {
            name: 'endSourceAt',
            type: 'select',
            options: ['-1h', '-6h', '-12h', '-1d', '-2d', '-7d', '-14d', '-30d'],
            optional: true,
        },
    ],
    defaultParams: [],
    version: '1.0',
});
addFuncDef({
    name: 'mapSeries',
    shortName: 'map',
    params: [{ name: 'node', type: 'int' }],
    defaultParams: [3],
    category: categories.Combine,
    version: '1.0',
});
addFuncDef({
    name: 'movingMin',
    category: categories.Calculate,
    params: [
        { name: 'windowSize', type: 'int_or_interval', options: ['5', '7', '10', '5min', '10min', '30min', '1hour'] },
    ],
    defaultParams: [10],
    version: '1.0',
});
addFuncDef({
    name: 'movingMax',
    category: categories.Calculate,
    params: [
        { name: 'windowSize', type: 'int_or_interval', options: ['5', '7', '10', '5min', '10min', '30min', '1hour'] },
    ],
    defaultParams: [10],
    version: '1.0',
});
addFuncDef({
    name: 'movingSum',
    category: categories.Calculate,
    params: [
        { name: 'windowSize', type: 'int_or_interval', options: ['5', '7', '10', '5min', '10min', '30min', '1hour'] },
    ],
    defaultParams: [10],
    version: '1.0',
});
addFuncDef({
    name: 'multiplySeriesWithWildcards',
    category: categories.Calculate,
    params: [
        { name: 'position', type: 'int', options: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12] },
        { name: 'position', type: 'int', options: [0, -1, -2, -3, -4, -5, -6, -7], optional: true },
        { name: 'position', type: 'int', options: [0, -1, -2, -3, -4, -5, -6, -7], optional: true },
        { name: 'position', type: 'int', options: [0, -1, -2, -3, -4, -5, -6, -7], optional: true },
    ],
    defaultParams: [2],
    version: '1.0',
});
addFuncDef({
    name: 'offsetToZero',
    category: categories.Transform,
    version: '1.0',
});
addFuncDef({
    name: 'pow',
    category: categories.Transform,
    params: [{ name: 'factor', type: 'int' }],
    defaultParams: [10],
    version: '1.0',
});
addFuncDef({
    name: 'powSeries',
    category: categories.Transform,
    params: optionalSeriesRefArgs,
    defaultParams: [''],
    version: '1.0',
});
addFuncDef({
    name: 'reduceSeries',
    shortName: 'reduce',
    params: [
        { name: 'function', type: 'string', options: ['asPercent', 'diffSeries', 'divideSeries'] },
        { name: 'reduceNode', type: 'int', options: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13] },
        { name: 'reduceMatchers', type: 'string' },
        { name: 'reduceMatchers', type: 'string' },
    ],
    defaultParams: ['asPercent', 2, 'used_bytes', 'total_bytes'],
    category: categories.Combine,
    version: '1.0',
});
addFuncDef({
    name: 'removeBetweenPercentile',
    category: categories.Filter,
    params: [{ name: 'n', type: 'int' }],
    defaultParams: [95],
    version: '1.0',
});
addFuncDef({
    name: 'removeEmptySeries',
    category: categories.Filter,
    version: '1.0',
});
addFuncDef({
    name: 'squareRoot',
    category: categories.Transform,
    version: '1.0',
});
addFuncDef({
    name: 'timeSlice',
    category: categories.Transform,
    params: [
        { name: 'startSliceAt', type: 'select', options: ['-1h', '-6h', '-12h', '-1d', '-2d', '-7d', '-14d', '-30d'] },
        {
            name: 'endSliceAt',
            type: 'select',
            options: ['-1h', '-6h', '-12h', '-1d', '-2d', '-7d', '-14d', '-30d'],
            optional: true,
        },
    ],
    defaultParams: ['-1h'],
    version: '1.0',
});
addFuncDef({
    name: 'weightedAverage',
    category: categories.Filter,
    params: [
        { name: 'other', type: 'value_or_series', optional: true },
        { name: 'node', type: 'int', options: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12] },
    ],
    defaultParams: ['#A', 4],
    version: '1.0',
});
addFuncDef({
    name: 'seriesByTag',
    category: categories.Special,
    params: [
        { name: 'tagExpression', type: 'string' },
        { name: 'tagExpression', type: 'string', optional: true },
        { name: 'tagExpression', type: 'string', optional: true },
        { name: 'tagExpression', type: 'string', optional: true },
    ],
    version: '1.1',
});
addFuncDef({
    name: 'groupByTags',
    category: categories.Special,
    params: [
        {
            name: 'function',
            type: 'string',
            options: ['sum', 'avg', 'maxSeries'],
        },
        { name: 'tag', type: 'string' },
        { name: 'tag', type: 'string', optional: true },
        { name: 'tag', type: 'string', optional: true },
        { name: 'tag', type: 'string', optional: true },
    ],
    defaultParams: ['sum', 'tag'],
    version: '1.1',
});
addFuncDef({
    name: 'aliasByTags',
    category: categories.Special,
    params: [
        { name: 'tag', type: 'string' },
        { name: 'tag', type: 'string', optional: true },
        { name: 'tag', type: 'string', optional: true },
        { name: 'tag', type: 'string', optional: true },
    ],
    defaultParams: ['tag'],
    version: '1.1',
});
__WEBPACK_IMPORTED_MODULE_0_lodash___default.a.each(categories, function (funcList, catName) {
    categories[catName] = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.sortBy(funcList, 'name');
});
function FuncInstance(funcDef, options) {
    this.def = funcDef;
    this.params = [];
    if (options && options.withDefaultParams) {
        this.params = funcDef.defaultParams.slice(0);
    }
    this.updateText();
}
function isNumeric(obj) {
    return !isNaN(parseFloat(obj)) && isFinite(obj);
}
FuncInstance.prototype.render = function (metricExp) {
    var str = this.def.name + '(';
    var parameters = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.map(this.params, function (value, index) {
        var paramType = this.def.params[index].type;
        if (paramType === 'int' || paramType === 'value_or_series' || paramType === 'boolean') {
            return value;
        }
        else if (paramType === 'int_or_interval' && isNumeric(value)) {
            return value;
        }
        return "'" + value + "'";
    }.bind(this));
    if (metricExp) {
        parameters.unshift(metricExp);
    }
    return str + parameters.join(', ') + ')';
};
FuncInstance.prototype._hasMultipleParamsInString = function (strValue, index) {
    if (strValue.indexOf(',') === -1) {
        return false;
    }
    return this.def.params[index + 1] && this.def.params[index + 1].optional;
};
FuncInstance.prototype.updateParam = function (strValue, index) {
    // handle optional parameters
    // if string contains ',' and next param is optional, split and update both
    if (this._hasMultipleParamsInString(strValue, index)) {
        __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.each(strValue.split(','), function (partVal, idx) {
            this.updateParam(partVal.trim(), index + idx);
        }.bind(this));
        return;
    }
    if (strValue === '' && this.def.params[index].optional) {
        this.params.splice(index, 1);
    }
    else {
        this.params[index] = strValue;
    }
    this.updateText();
};
FuncInstance.prototype.updateText = function () {
    if (this.params.length === 0) {
        this.text = this.def.name + '()';
        return;
    }
    var text = this.def.name + '(';
    text += this.params.join(', ');
    text += ')';
    this.text = text;
};
function isVersionRelatedFunction(func, graphiteVersion) {
    return Object(__WEBPACK_IMPORTED_MODULE_1_app_core_utils_version__["b" /* isVersionGtOrEq */])(graphiteVersion, func.version) || !func.version;
}
/* harmony default export */ __webpack_exports__["default"] = ({
    createFuncInstance: function (funcDef, options) {
        if (__WEBPACK_IMPORTED_MODULE_0_lodash___default.a.isString(funcDef)) {
            if (!index[funcDef]) {
                throw { message: 'Method not found ' + name };
            }
            funcDef = index[funcDef];
        }
        return new FuncInstance(funcDef, options);
    },
    getFuncDef: function (name) {
        return index[name];
    },
    getCategories: function (graphiteVersion) {
        var filteredCategories = {};
        __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.each(categories, function (functions, category) {
            var filteredFuncs = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.filter(functions, function (func) {
                return isVersionRelatedFunction(func, graphiteVersion);
            });
            if (filteredFuncs.length) {
                filteredCategories[category] = filteredFuncs;
            }
        });
        return filteredCategories;
    },
});


/***/ }),

/***/ 1318:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return convertToHeatMap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return elasticHistogramToHeatmap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return convertToCards; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return mergeZeroBuckets; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return getValueBucketBound; });
/* unused harmony export isHeatmapDataEqual */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return calculateBucketSize; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_lodash__);

var VALUE_INDEX = 0;
var TIME_INDEX = 1;
function elasticHistogramToHeatmap(seriesList) {
    var heatmap = {};
    for (var _i = 0, seriesList_1 = seriesList; _i < seriesList_1.length; _i++) {
        var series = seriesList_1[_i];
        var bound = Number(series.alias);
        if (isNaN(bound)) {
            return heatmap;
        }
        for (var _a = 0, _b = series.datapoints; _a < _b.length; _a++) {
            var point = _b[_a];
            var count = point[VALUE_INDEX];
            var time = point[TIME_INDEX];
            if (!__WEBPACK_IMPORTED_MODULE_0_lodash___default.a.isNumber(count)) {
                continue;
            }
            var bucket = heatmap[time];
            if (!bucket) {
                bucket = heatmap[time] = { x: time, buckets: {} };
            }
            bucket.buckets[bound] = { y: bound, count: count, values: [], points: [] };
        }
    }
    return heatmap;
}
/**
 * Convert buckets into linear array of "cards" - objects, represented heatmap elements.
 * @param  {Object} buckets
 * @return {Array}          Array of "card" objects
 */
function convertToCards(buckets) {
    var min = 0, max = 0;
    var cards = [];
    __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.forEach(buckets, function (xBucket) {
        __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.forEach(xBucket.buckets, function (yBucket) {
            var card = {
                x: xBucket.x,
                y: yBucket.y,
                yBounds: yBucket.bounds,
                values: yBucket.values,
                count: yBucket.count,
            };
            cards.push(card);
            if (cards.length === 1) {
                min = yBucket.count;
                max = yBucket.count;
            }
            min = yBucket.count < min ? yBucket.count : min;
            max = yBucket.count > max ? yBucket.count : max;
        });
    });
    var cardStats = { min: min, max: max };
    return { cards: cards, cardStats: cardStats };
}
/**
 * Special method for log scales. When series converted into buckets with log scale,
 * for simplification, 0 values are converted into 0, not into -Infinity. On the other hand, we mean
 * that all values less than series minimum, is 0 values, and we create special "minimum" bucket for
 * that values (actually, there're no values less than minimum, so this bucket is empty).
 *  8-16|    | ** |    |  * |  **|
 *   4-8|  * |*  *|*   |** *| *  |
 *   2-4| * *|    | ***|    |*   |
 *   1-2|*   |    |    |    |    | This bucket contains minimum series value
 * 0.5-1|____|____|____|____|____| This bucket should be displayed as 0 on graph
 *     0|____|____|____|____|____| This bucket is for 0 values (should actually be -Infinity)
 * So we should merge two bottom buckets into one (0-value bucket).
 *
 * @param  {Object} buckets  Heatmap buckets
 * @param  {Number} minValue Minimum series value
 * @return {Object}          Transformed buckets
 */
function mergeZeroBuckets(buckets, minValue) {
    __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.forEach(buckets, function (xBucket) {
        var yBuckets = xBucket.buckets;
        var emptyBucket = {
            bounds: { bottom: 0, top: 0 },
            values: [],
            points: [],
            count: 0,
        };
        var nullBucket = yBuckets[0] || emptyBucket;
        var minBucket = yBuckets[minValue] || emptyBucket;
        var newBucket = {
            y: 0,
            bounds: { bottom: minValue, top: minBucket.bounds.top || minValue },
            values: [],
            points: [],
            count: 0,
        };
        newBucket.points = nullBucket.points.concat(minBucket.points);
        newBucket.values = nullBucket.values.concat(minBucket.values);
        newBucket.count = newBucket.values.length;
        if (newBucket.count === 0) {
            return;
        }
        delete yBuckets[minValue];
        yBuckets[0] = newBucket;
    });
    return buckets;
}
/**
   * Convert set of time series into heatmap buckets
   * @return {Object}    Heatmap object:
 * {
 *   xBucketBound_1: {
 *     x: xBucketBound_1,
 *     buckets: {
 *       yBucketBound_1: {
 *         y: yBucketBound_1,
 *         bounds: {bottom, top}
 *         values: [val_1, val_2, ..., val_K],
 *         points: [[val_Y, val_X, series_name], ..., [...]],
 *         seriesStat: {seriesName_1: val_1, seriesName_2: val_2}
 *       },
 *       ...
 *       yBucketBound_M: {}
 *     },
 *     values: [val_1, val_2, ..., val_K],
 *     points: [
 *       [val_Y, val_X, series_name], (point_1)
 *       ...
 *       [...] (point_K)
 *     ]
 *   },
 *   xBucketBound_2: {},
 *   ...
 *   xBucketBound_N: {}
 * }
 */
function convertToHeatMap(seriesList, yBucketSize, xBucketSize, logBase) {
    if (logBase === void 0) { logBase = 1; }
    var heatmap = {};
    var _loop_1 = function (series) {
        var datapoints = series.datapoints;
        var seriesName = series.label;
        // Slice series into X axis buckets
        // |    | ** |    |  * |  **|
        // |  * |*  *|*   |** *| *  |
        // |** *|    | ***|    |*   |
        // |____|____|____|____|____|_
        //
        __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.forEach(datapoints, function (point) {
            var bucketBound = getBucketBound(point[TIME_INDEX], xBucketSize);
            pushToXBuckets(heatmap, point, bucketBound, seriesName);
        });
    };
    for (var _i = 0, seriesList_2 = seriesList; _i < seriesList_2.length; _i++) {
        var series = seriesList_2[_i];
        _loop_1(series);
    }
    // Slice X axis buckets into Y (value) buckets
    // |  **|     |2|,
    // | *  | --\ |1|,
    // |*   | --/ |1|,
    // |____|     |0|
    //
    __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.forEach(heatmap, function (xBucket) {
        if (logBase !== 1) {
            xBucket.buckets = convertToLogScaleValueBuckets(xBucket, yBucketSize, logBase);
        }
        else {
            xBucket.buckets = convertToValueBuckets(xBucket, yBucketSize);
        }
    });
    return heatmap;
}
function pushToXBuckets(buckets, point, bucketNum, seriesName) {
    var value = point[VALUE_INDEX];
    if (value === null || value === undefined || isNaN(value)) {
        return;
    }
    // Add series name to point for future identification
    var point_ext = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.concat(point, seriesName);
    if (buckets[bucketNum] && buckets[bucketNum].values) {
        buckets[bucketNum].values.push(value);
        buckets[bucketNum].points.push(point_ext);
    }
    else {
        buckets[bucketNum] = {
            x: bucketNum,
            values: [value],
            points: [point_ext]
        };
    }
}
function pushToYBuckets(buckets, bucketNum, value, point, bounds) {
    var count = 1;
    // Use the 3rd argument as scale/count
    if (point.length > 3) {
        count = parseInt(point[2]);
    }
    if (buckets[bucketNum]) {
        buckets[bucketNum].values.push(value);
        buckets[bucketNum].points.push(point);
        buckets[bucketNum].count += count;
    }
    else {
        buckets[bucketNum] = {
            y: bucketNum,
            bounds: bounds,
            values: [value],
            points: [point],
            count: count,
        };
    }
}
function getValueBucketBound(value, yBucketSize, logBase) {
    if (logBase === 1) {
        return getBucketBound(value, yBucketSize);
    }
    else {
        return getLogScaleBucketBound(value, yBucketSize, logBase);
    }
}
/**
 * Find bucket for given value (for linear scale)
 */
function getBucketBounds(value, bucketSize) {
    var bottom, top;
    bottom = Math.floor(value / bucketSize) * bucketSize;
    top = (Math.floor(value / bucketSize) + 1) * bucketSize;
    return { bottom: bottom, top: top };
}
function getBucketBound(value, bucketSize) {
    var bounds = getBucketBounds(value, bucketSize);
    return bounds.bottom;
}
function convertToValueBuckets(xBucket, bucketSize) {
    var values = xBucket.values;
    var points = xBucket.points;
    var buckets = {};
    __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.forEach(values, function (val, index) {
        var bounds = getBucketBounds(val, bucketSize);
        var bucketNum = bounds.bottom;
        pushToYBuckets(buckets, bucketNum, val, points[index], bounds);
    });
    return buckets;
}
/**
 * Find bucket for given value (for log scales)
 */
function getLogScaleBucketBounds(value, yBucketSplitFactor, logBase) {
    var top, bottom;
    if (value === 0) {
        return { bottom: 0, top: 0 };
    }
    var value_log = logp(value, logBase);
    var pow, powTop;
    if (yBucketSplitFactor === 1 || !yBucketSplitFactor) {
        pow = Math.floor(value_log);
        powTop = pow + 1;
    }
    else {
        var additional_bucket_size = 1 / yBucketSplitFactor;
        var additional_log = value_log - Math.floor(value_log);
        additional_log = Math.floor(additional_log / additional_bucket_size) * additional_bucket_size;
        pow = Math.floor(value_log) + additional_log;
        powTop = pow + additional_bucket_size;
    }
    bottom = Math.pow(logBase, pow);
    top = Math.pow(logBase, powTop);
    return { bottom: bottom, top: top };
}
function getLogScaleBucketBound(value, yBucketSplitFactor, logBase) {
    var bounds = getLogScaleBucketBounds(value, yBucketSplitFactor, logBase);
    return bounds.bottom;
}
function convertToLogScaleValueBuckets(xBucket, yBucketSplitFactor, logBase) {
    var values = xBucket.values;
    var points = xBucket.points;
    var buckets = {};
    __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.forEach(values, function (val, index) {
        var bounds = getLogScaleBucketBounds(val, yBucketSplitFactor, logBase);
        var bucketNum = bounds.bottom;
        pushToYBuckets(buckets, bucketNum, val, points[index], bounds);
    });
    return buckets;
}
/**
 * Logarithm for custom base
 * @param value
 * @param base logarithm base
 */
function logp(value, base) {
    return Math.log(value) / Math.log(base);
}
/**
 * Calculate size of Y bucket from given buckets bounds.
 * @param bounds Array of Y buckets bounds
 * @param logBase Logarithm base
 */
function calculateBucketSize(bounds, logBase) {
    if (logBase === void 0) { logBase = 1; }
    var bucketSize = Infinity;
    if (bounds.length === 0) {
        return 0;
    }
    else if (bounds.length === 1) {
        return bounds[0];
    }
    else {
        bounds = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.sortBy(bounds);
        for (var i = 1; i < bounds.length; i++) {
            var distance = getDistance(bounds[i], bounds[i - 1], logBase);
            bucketSize = distance < bucketSize ? distance : bucketSize;
        }
    }
    return bucketSize;
}
/**
 * Calculate distance between two numbers in given scale (linear or logarithmic).
 * @param a
 * @param b
 * @param logBase
 */
function getDistance(a, b, logBase) {
    if (logBase === void 0) { logBase = 1; }
    if (logBase === 1) {
        // Linear distance
        return Math.abs(b - a);
    }
    else {
        // logarithmic distance
        var ratio = Math.max(a, b) / Math.min(a, b);
        return logp(ratio, logBase);
    }
}
/**
 * Compare two heatmap data objects
 * @param objA
 * @param objB
 */
function isHeatmapDataEqual(objA, objB) {
    var is_eql = !emptyXOR(objA, objB);
    __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.forEach(objA, function (xBucket, x) {
        if (objB[x]) {
            if (emptyXOR(xBucket.buckets, objB[x].buckets)) {
                is_eql = false;
                return false;
            }
            __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.forEach(xBucket.buckets, function (yBucket, y) {
                if (objB[x].buckets && objB[x].buckets[y]) {
                    if (objB[x].buckets[y].values) {
                        is_eql = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.isEqual(__WEBPACK_IMPORTED_MODULE_0_lodash___default.a.sortBy(yBucket.values), __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.sortBy(objB[x].buckets[y].values));
                        if (!is_eql) {
                            return false;
                        }
                        else {
                            return true;
                        }
                    }
                    else {
                        is_eql = false;
                        return false;
                    }
                }
                else {
                    is_eql = false;
                    return false;
                }
            });
            if (!is_eql) {
                return false;
            }
            else {
                return true;
            }
        }
        else {
            is_eql = false;
            return false;
        }
    });
    return is_eql;
}
function emptyXOR(foo, bar) {
    return (__WEBPACK_IMPORTED_MODULE_0_lodash___default.a.isEmpty(foo) || __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.isEmpty(bar)) && !(__WEBPACK_IMPORTED_MODULE_0_lodash___default.a.isEmpty(foo) && __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.isEmpty(bar));
}



/***/ }),

/***/ 1319:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Observable_1 = __webpack_require__(466);
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var EmptyObservable = (function (_super) {
    __extends(EmptyObservable, _super);
    function EmptyObservable(scheduler) {
        _super.call(this);
        this.scheduler = scheduler;
    }
    /**
     * Creates an Observable that emits no items to the Observer and immediately
     * emits a complete notification.
     *
     * <span class="informal">Just emits 'complete', and nothing else.
     * </span>
     *
     * <img src="./img/empty.png" width="100%">
     *
     * This static operator is useful for creating a simple Observable that only
     * emits the complete notification. It can be used for composing with other
     * Observables, such as in a {@link mergeMap}.
     *
     * @example <caption>Emit the number 7, then complete.</caption>
     * var result = Rx.Observable.empty().startWith(7);
     * result.subscribe(x => console.log(x));
     *
     * @example <caption>Map and flatten only odd numbers to the sequence 'a', 'b', 'c'</caption>
     * var interval = Rx.Observable.interval(1000);
     * var result = interval.mergeMap(x =>
     *   x % 2 === 1 ? Rx.Observable.of('a', 'b', 'c') : Rx.Observable.empty()
     * );
     * result.subscribe(x => console.log(x));
     *
     * // Results in the following to the console:
     * // x is equal to the count on the interval eg(0,1,2,3,...)
     * // x will occur every 1000ms
     * // if x % 2 is equal to 1 print abc
     * // if x % 2 is not equal to 1 nothing will be output
     *
     * @see {@link create}
     * @see {@link never}
     * @see {@link of}
     * @see {@link throw}
     *
     * @param {Scheduler} [scheduler] A {@link IScheduler} to use for scheduling
     * the emission of the complete notification.
     * @return {Observable} An "empty" Observable: emits only the complete
     * notification.
     * @static true
     * @name empty
     * @owner Observable
     */
    EmptyObservable.create = function (scheduler) {
        return new EmptyObservable(scheduler);
    };
    EmptyObservable.dispatch = function (arg) {
        var subscriber = arg.subscriber;
        subscriber.complete();
    };
    EmptyObservable.prototype._subscribe = function (subscriber) {
        var scheduler = this.scheduler;
        if (scheduler) {
            return scheduler.schedule(EmptyObservable.dispatch, 0, { subscriber: subscriber });
        }
        else {
            subscriber.complete();
        }
    };
    return EmptyObservable;
}(Observable_1.Observable));
exports.EmptyObservable = EmptyObservable;
//# sourceMappingURL=EmptyObservable.js.map

/***/ }),

/***/ 1320:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var root_1 = __webpack_require__(127);
function symbolIteratorPonyfill(root) {
    var Symbol = root.Symbol;
    if (typeof Symbol === 'function') {
        if (!Symbol.iterator) {
            Symbol.iterator = Symbol('iterator polyfill');
        }
        return Symbol.iterator;
    }
    else {
        // [for Mozilla Gecko 27-35:](https://mzl.la/2ewE1zC)
        var Set_1 = root.Set;
        if (Set_1 && typeof new Set_1()['@@iterator'] === 'function') {
            return '@@iterator';
        }
        var Map_1 = root.Map;
        // required for compatability with es6-shim
        if (Map_1) {
            var keys = Object.getOwnPropertyNames(Map_1.prototype);
            for (var i = 0; i < keys.length; ++i) {
                var key = keys[i];
                // according to spec, Map.prototype[@@iterator] and Map.orototype.entries must be equal.
                if (key !== 'entries' && key !== 'size' && Map_1.prototype[key] === Map_1.prototype['entries']) {
                    return key;
                }
            }
        }
        return '@@iterator';
    }
}
exports.symbolIteratorPonyfill = symbolIteratorPonyfill;
exports.iterator = symbolIteratorPonyfill(root_1.root);
/**
 * @deprecated use iterator instead
 */
exports.$$iterator = exports.iterator;
//# sourceMappingURL=iterator.js.map

/***/ }),

/***/ 1322:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return DashboardRow; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_app_core_core__ = __webpack_require__(465);
///<reference path="../../../headers/common.d.ts" />


var DashboardRow = /** @class */ (function () {
    function DashboardRow(model) {
        this.model = model;
        this.defaults = {
            title: 'Dashboard Row',
            panels: [],
            showTitle: false,
            titleSize: 'h6',
            height: 250,
            isNew: false,
            repeat: null,
            repeatRowId: null,
            repeatIteration: null,
            collapse: false,
        };
        Object(__WEBPACK_IMPORTED_MODULE_1_app_core_core__["assignModelProperties"])(this, model, this.defaults);
        this.events = new __WEBPACK_IMPORTED_MODULE_1_app_core_core__["Emitter"]();
        this.updateRowSpan();
    }
    DashboardRow.prototype.getSaveModel = function () {
        this.model = {};
        Object(__WEBPACK_IMPORTED_MODULE_1_app_core_core__["assignModelProperties"])(this.model, this, this.defaults);
        // remove properties that dont server persisted purpose
        delete this.model.isNew;
        return this.model;
    };
    DashboardRow.prototype.updateRowSpan = function () {
        this.span = 0;
        for (var _i = 0, _a = this.panels; _i < _a.length; _i++) {
            var panel = _a[_i];
            this.span += panel.span;
        }
    };
    DashboardRow.prototype.panelSpanChanged = function (alwaysSendEvent) {
        var oldSpan = this.span;
        this.updateRowSpan();
        if (alwaysSendEvent || oldSpan !== this.span) {
            this.events.emit('span-changed');
        }
    };
    DashboardRow.prototype.addPanel = function (panel) {
        var rowSpan = this.span;
        var panelCount = this.panels.length;
        var space = (12 - rowSpan) - panel.span;
        // try to make room of there is no space left
        if (space <= 0) {
            if (panelCount === 1) {
                this.panels[0].span = 6;
                panel.span = 6;
            }
            else if (panelCount === 2) {
                this.panels[0].span = 4;
                this.panels[1].span = 4;
                panel.span = 4;
            }
            else if (panelCount === 3) {
                this.panels[0].span = 3;
                this.panels[1].span = 3;
                this.panels[2].span = 3;
                panel.span = 3;
            }
        }
        this.panels.push(panel);
        this.events.emit('panel-added', panel);
        this.panelSpanChanged();
    };
    DashboardRow.prototype.removePanel = function (panel, ask) {
        var _this = this;
        if (ask !== false) {
            var text2, confirmText;
            if (panel.alert) {
                text2 = "Panel includes an alert rule, removing panel will also remove alert rule";
                confirmText = "YES";
            }
            __WEBPACK_IMPORTED_MODULE_1_app_core_core__["appEvents"].emit('confirm-modal', {
                title: 'Remove Panel',
                text: 'Are you sure you want to remove this panel?',
                text2: text2,
                icon: 'fa-trash',
                confirmText: confirmText,
                yesText: 'Remove',
                onConfirm: function () {
                    _this.removePanel(panel, false);
                }
            });
            return;
        }
        var index = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.indexOf(this.panels, panel);
        this.panels.splice(index, 1);
        this.events.emit('panel-removed', panel);
        this.panelSpanChanged();
    };
    DashboardRow.prototype.movePanel = function (fromIndex, toIndex) {
        this.panels.splice(toIndex, 0, this.panels.splice(fromIndex, 1)[0]);
    };
    DashboardRow.prototype.destroy = function () {
        this.events.removeAllListeners();
    };
    DashboardRow.prototype.copyPropertiesFromRowSource = function (source) {
        this.height = source.height;
        this.title = source.title;
        this.showTitle = source.showTitle;
        this.titleSize = source.titleSize;
    };
    DashboardRow.prototype.toggleCollapse = function () {
        this.collapse = !this.collapse;
    };
    return DashboardRow;
}());



/***/ }),

/***/ 1323:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (immutable) */ __webpack_exports__["exportSeriesListToCsv"] = exportSeriesListToCsv;
/* harmony export (immutable) */ __webpack_exports__["exportSeriesListToCsvColumns"] = exportSeriesListToCsvColumns;
/* harmony export (immutable) */ __webpack_exports__["exportTableDataToCsv"] = exportTableDataToCsv;
/* harmony export (immutable) */ __webpack_exports__["saveSaveBlob"] = saveSaveBlob;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_moment__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_moment___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_moment__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_file_saver__ = __webpack_require__(203);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_file_saver___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_file_saver__);



var DEFAULT_DATETIME_FORMAT = 'YYYY-MM-DDTHH:mm:ssZ';
function exportSeriesListToCsv(seriesList, dateTimeFormat, excel) {
    if (dateTimeFormat === void 0) { dateTimeFormat = DEFAULT_DATETIME_FORMAT; }
    if (excel === void 0) { excel = false; }
    var text = (excel ? 'sep=;\n' : '') + 'Series;Time;Value\n';
    __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.each(seriesList, function (series) {
        __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.each(series.datapoints, function (dp) {
            text += series.alias + ';' + __WEBPACK_IMPORTED_MODULE_1_moment___default()(dp[1]).format(dateTimeFormat) + ';' + dp[0] + '\n';
        });
    });
    saveSaveBlob(text, 'grafana_data_export.csv');
}
function exportSeriesListToCsvColumns(seriesList, dateTimeFormat, excel) {
    if (dateTimeFormat === void 0) { dateTimeFormat = DEFAULT_DATETIME_FORMAT; }
    if (excel === void 0) { excel = false; }
    var text = (excel ? 'sep=;\n' : '') + 'Time;';
    // add header
    __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.each(seriesList, function (series) {
        text += series.alias + ';';
    });
    text = text.substring(0, text.length - 1);
    text += '\n';
    // process data
    var dataArr = [[]];
    var sIndex = 1;
    __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.each(seriesList, function (series) {
        var cIndex = 0;
        dataArr.push([]);
        __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.each(series.datapoints, function (dp) {
            dataArr[0][cIndex] = __WEBPACK_IMPORTED_MODULE_1_moment___default()(dp[1]).format(dateTimeFormat);
            dataArr[sIndex][cIndex] = dp[0];
            cIndex++;
        });
        sIndex++;
    });
    // make text
    for (var i = 0; i < dataArr[0].length; i++) {
        text += dataArr[0][i] + ';';
        for (var j = 1; j < dataArr.length; j++) {
            text += dataArr[j][i] + ';';
        }
        text = text.substring(0, text.length - 1);
        text += '\n';
    }
    saveSaveBlob(text, 'grafana_data_export.csv');
}
function exportTableDataToCsv(table, excel) {
    if (excel === void 0) { excel = false; }
    var text = excel ? 'sep=;\n' : '';
    // add header
    __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.each(table.columns, function (column) {
        text += (column.title || column.text) + ';';
    });
    text += '\n';
    // process data
    __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.each(table.rows, function (row) {
        __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.each(row, function (value) {
            text += value + ';';
        });
        text += '\n';
    });
    saveSaveBlob(text, 'grafana_data_export.csv');
}
function saveSaveBlob(payload, fname) {
    var blob = new Blob([payload], { type: "text/csv;charset=utf-8" });
    Object(__WEBPACK_IMPORTED_MODULE_2_file_saver__["saveAs"])(blob, fname);
}


/***/ }),

/***/ 1324:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LinkSrv", function() { return LinkSrv; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_angular__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_angular___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_angular__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_lodash__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_app_core_utils_kbn__ = __webpack_require__(464);



var LinkSrv = /** @class */ (function () {
    /** @ngInject */
    LinkSrv.$inject = ["templateSrv", "timeSrv"];
    function LinkSrv(templateSrv, timeSrv) {
        this.templateSrv = templateSrv;
        this.timeSrv = timeSrv;
    }
    LinkSrv.prototype.getLinkUrl = function (link) {
        var url = this.templateSrv.replace(link.url || '');
        var params = {};
        if (link.keepTime) {
            var range = this.timeSrv.timeRangeForUrl();
            params['from'] = range.from;
            params['to'] = range.to;
        }
        if (link.includeVars) {
            this.templateSrv.fillVariableValuesForUrl(params);
        }
        return this.addParamsToUrl(url, params);
    };
    LinkSrv.prototype.addParamsToUrl = function (url, params) {
        var paramsArray = [];
        __WEBPACK_IMPORTED_MODULE_1_lodash___default.a.each(params, function (value, key) {
            if (value === null) {
                return;
            }
            if (value === true) {
                paramsArray.push(key);
            }
            else if (__WEBPACK_IMPORTED_MODULE_1_lodash___default.a.isArray(value)) {
                __WEBPACK_IMPORTED_MODULE_1_lodash___default.a.each(value, function (instance) {
                    paramsArray.push(key + '=' + encodeURIComponent(instance));
                });
            }
            else {
                paramsArray.push(key + '=' + encodeURIComponent(value));
            }
        });
        if (paramsArray.length === 0) {
            return url;
        }
        return this.appendToQueryString(url, paramsArray.join('&'));
    };
    LinkSrv.prototype.appendToQueryString = function (url, stringToAppend) {
        if (!__WEBPACK_IMPORTED_MODULE_1_lodash___default.a.isUndefined(stringToAppend) && stringToAppend !== null && stringToAppend !== '') {
            var pos = url.indexOf('?');
            if (pos !== -1) {
                if (url.length - pos > 1) {
                    url += '&';
                }
            }
            else {
                url += '?';
            }
            url += stringToAppend;
        }
        return url;
    };
    LinkSrv.prototype.getAnchorInfo = function (link) {
        var info = {};
        info.href = this.getLinkUrl(link);
        info.title = this.templateSrv.replace(link.title || '');
        return info;
    };
    LinkSrv.prototype.getPanelLinkAnchorInfo = function (link, scopedVars) {
        var info = {};
        if (link.type === 'absolute') {
            info.target = link.targetBlank ? '_blank' : '_self';
            info.href = this.templateSrv.replace(link.url || '', scopedVars);
            info.title = this.templateSrv.replace(link.title || '', scopedVars);
        }
        else if (link.dashUri) {
            info.href = 'dashboard/' + link.dashUri + '?';
            info.title = this.templateSrv.replace(link.title || '', scopedVars);
            info.target = link.targetBlank ? '_blank' : '';
        }
        else {
            info.title = this.templateSrv.replace(link.title || '', scopedVars);
            var slug = __WEBPACK_IMPORTED_MODULE_2_app_core_utils_kbn__["default"].slugifyForUrl(link.dashboard || '');
            info.href = 'dashboard/db/' + slug + '?';
        }
        var params = {};
        if (link.keepTime) {
            var range = this.timeSrv.timeRangeForUrl();
            params['from'] = range.from;
            params['to'] = range.to;
        }
        if (link.includeVars) {
            this.templateSrv.fillVariableValuesForUrl(params, scopedVars);
        }
        info.href = this.addParamsToUrl(info.href, params);
        if (link.params) {
            info.href = this.appendToQueryString(info.href, this.templateSrv.replace(link.params, scopedVars));
        }
        return info;
    };
    return LinkSrv;
}());

__WEBPACK_IMPORTED_MODULE_0_angular___default.a.module('grafana.services').service('linkSrv', LinkSrv);


/***/ }),

/***/ 1325:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__annotations_srv__ = __webpack_require__(1395);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__event_editor__ = __webpack_require__(1398);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__event_manager__ = __webpack_require__(1399);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__event__ = __webpack_require__(1326);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__annotation_tooltip__ = __webpack_require__(1400);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "AnnotationsSrv", function() { return __WEBPACK_IMPORTED_MODULE_0__annotations_srv__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "eventEditor", function() { return __WEBPACK_IMPORTED_MODULE_1__event_editor__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "EventManager", function() { return __WEBPACK_IMPORTED_MODULE_2__event_manager__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "AnnotationEvent", function() { return __WEBPACK_IMPORTED_MODULE_3__event__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "annotationTooltipDirective", function() { return __WEBPACK_IMPORTED_MODULE_4__annotation_tooltip__["a"]; });








/***/ }),

/***/ 1326:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AnnotationEvent; });
var AnnotationEvent = /** @class */ (function () {
    function AnnotationEvent() {
    }
    return AnnotationEvent;
}());



/***/ }),

/***/ 1327:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "QueryCtrl", function() { return QueryCtrl; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_lodash__);
///<reference path="../../headers/common.d.ts" />

var QueryCtrl = /** @class */ (function () {
    function QueryCtrl($scope, $injector) {
        this.$scope = $scope;
        this.$injector = $injector;
        this.panel = this.panelCtrl.panel;
        this.isLastQuery = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.indexOf(this.panel.targets, this.target) === (this.panel.targets.length - 1);
    }
    QueryCtrl.prototype.refresh = function () {
        this.panelCtrl.refresh();
    };
    return QueryCtrl;
}());



/***/ }),

/***/ 1328:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (immutable) */ __webpack_exports__["default"] = flatten;
// Copyright (c) 2014, Hugh Kennedy
// Based on code from https://github.com/hughsk/flat/blob/master/index.js
//
function flatten(target, opts) {
    opts = opts || {};
    var delimiter = opts.delimiter || '.';
    var maxDepth = opts.maxDepth || 3;
    var currentDepth = 1;
    var output = {};
    function step(object, prev) {
        Object.keys(object).forEach(function (key) {
            var value = object[key];
            var isarray = opts.safe && Array.isArray(value);
            var type = Object.prototype.toString.call(value);
            var isobject = type === "[object Object]";
            var newKey = prev ? prev + delimiter + key : key;
            if (!opts.maxDepth) {
                maxDepth = currentDepth + 1;
            }
            if (!isarray && isobject && Object.keys(value).length && currentDepth < maxDepth) {
                ++currentDepth;
                return step(value, newKey);
            }
            output[newKey] = value;
        });
    }
    step(target, null);
    return output;
}


/***/ }),

/***/ 1329:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return SemVersion; });
/* harmony export (immutable) */ __webpack_exports__["b"] = isVersionGtOrEq;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_lodash__);

var versionPattern = /^(\d+)(?:\.(\d+))?(?:\.(\d+))?(?:-([0-9A-Za-z\.]+))?/;
var SemVersion = /** @class */ (function () {
    function SemVersion(version) {
        var match = versionPattern.exec(version);
        if (match) {
            this.major = Number(match[1]);
            this.minor = Number(match[2] || 0);
            this.patch = Number(match[3] || 0);
            this.meta = match[4];
        }
    }
    SemVersion.prototype.isGtOrEq = function (version) {
        var compared = new SemVersion(version);
        return !(this.major < compared.major || this.minor < compared.minor || this.patch < compared.patch);
    };
    SemVersion.prototype.isValid = function () {
        return __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.isNumber(this.major);
    };
    return SemVersion;
}());

function isVersionGtOrEq(a, b) {
    var a_semver = new SemVersion(a);
    return a_semver.isGtOrEq(b);
}


/***/ }),

/***/ 1330:
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
  __webpack_require__(12),
  __webpack_require__(7),
], __WEBPACK_AMD_DEFINE_RESULT__ = function (angular, _) {
  'use strict';

  var module = angular.module('grafana.controllers');

  module.directive('cloudwatchQueryParameter', function() {
    return {
      templateUrl: 'public/app/plugins/datasource/cloudwatch/partials/query.parameter.html',
      controller: 'CloudWatchQueryParameterCtrl',
      restrict: 'E',
      scope: {
        target: "=",
        datasource: "=",
        onChange: "&",
      }
    };
  });

  module.controller('CloudWatchQueryParameterCtrl', ["$scope", "templateSrv", "uiSegmentSrv", "datasourceSrv", "$q", function($scope, templateSrv, uiSegmentSrv, datasourceSrv, $q) {

    $scope.init = function() {
      var target = $scope.target;
      target.namespace = target.namespace || '';
      target.metricName = target.metricName || '';
      target.statistics = target.statistics || ['Average'];
      target.dimensions = target.dimensions || {};
      target.period = target.period || '';
      target.region = target.region || '';

      $scope.regionSegment =  uiSegmentSrv.getSegmentForValue($scope.target.region, 'select region');
      $scope.namespaceSegment = uiSegmentSrv.getSegmentForValue($scope.target.namespace, 'select namespace');
      $scope.metricSegment = uiSegmentSrv.getSegmentForValue($scope.target.metricName, 'select metric');

      $scope.dimSegments = _.reduce($scope.target.dimensions, function(memo, value, key) {
        memo.push(uiSegmentSrv.newKey(key));
        memo.push(uiSegmentSrv.newOperator("="));
        memo.push(uiSegmentSrv.newKeyValue(value));
        return memo;
      }, []);

      $scope.statSegments = _.map($scope.target.statistics, function(stat) {
        return uiSegmentSrv.getSegmentForValue(stat);
      });

      $scope.ensurePlusButton($scope.statSegments);
      $scope.ensurePlusButton($scope.dimSegments);
      $scope.removeDimSegment = uiSegmentSrv.newSegment({fake: true, value: '-- remove dimension --'});
      $scope.removeStatSegment = uiSegmentSrv.newSegment({fake: true, value: '-- remove stat --'});

      if (_.isEmpty($scope.target.region)) {
        $scope.target.region = $scope.datasource.getDefaultRegion();
      }

      if (!$scope.onChange) {
        $scope.onChange = function() {};
      }
    };

    $scope.getStatSegments = function() {
      return $q.when(_.flatten([
        angular.copy($scope.removeStatSegment),
        _.map($scope.datasource.standardStatistics, function(s) {
          return uiSegmentSrv.getSegmentForValue(s);
        }),
        uiSegmentSrv.getSegmentForValue('pNN.NN'),
      ]));
    };

    $scope.statSegmentChanged = function(segment, index) {
      if (segment.value === $scope.removeStatSegment.value) {
        $scope.statSegments.splice(index, 1);
      } else {
        segment.type = 'value';
      }

      $scope.target.statistics = _.reduce($scope.statSegments, function(memo, seg) {
        if (!seg.fake) { memo.push(seg.value); } return memo;
      }, []);

      $scope.ensurePlusButton($scope.statSegments);
      $scope.onChange();
    };

    $scope.ensurePlusButton = function(segments) {
      var count = segments.length;
      var lastSegment = segments[Math.max(count-1, 0)];

      if (!lastSegment || lastSegment.type !== 'plus-button') {
        segments.push(uiSegmentSrv.newPlusButton());
      }
    };

    $scope.getDimSegments = function(segment, $index) {
      if (segment.type === 'operator') { return $q.when([]); }

      var target = $scope.target;
      var query = $q.when([]);

      if (segment.type === 'key' || segment.type === 'plus-button') {
        query = $scope.datasource.getDimensionKeys($scope.target.namespace, $scope.target.region);
      } else if (segment.type === 'value')  {
        var dimensionKey = $scope.dimSegments[$index-2].value;
        query = $scope.datasource.getDimensionValues(target.region, target.namespace, target.metricName, dimensionKey, target.dimensions);
      }

      return query.then($scope.transformToSegments(true)).then(function(results) {
        if (segment.type === 'key') {
          results.splice(0, 0, angular.copy($scope.removeDimSegment));
        }
        return results;
      });
    };

    $scope.dimSegmentChanged = function(segment, index) {
      $scope.dimSegments[index] = segment;

      if (segment.value === $scope.removeDimSegment.value) {
        $scope.dimSegments.splice(index, 3);
      }
      else if (segment.type === 'plus-button') {
        $scope.dimSegments.push(uiSegmentSrv.newOperator('='));
        $scope.dimSegments.push(uiSegmentSrv.newFake('select dimension value', 'value', 'query-segment-value'));
        segment.type = 'key';
        segment.cssClass = 'query-segment-key';
      }

      $scope.syncDimSegmentsWithModel();
      $scope.ensurePlusButton($scope.dimSegments);
      $scope.onChange();
    };

    $scope.syncDimSegmentsWithModel = function() {
      var dims = {};
      var length = $scope.dimSegments.length;

      for (var i = 0; i < length - 2; i += 3) {
        var keySegment = $scope.dimSegments[i];
        var valueSegment = $scope.dimSegments[i + 2];
        if (!valueSegment.fake) {
          dims[keySegment.value] = valueSegment.value;
        }
      }

      $scope.target.dimensions = dims;
    };

    $scope.getRegions = function() {
      return $scope.datasource.metricFindQuery('regions()')
      .then($scope.transformToSegments(true));
    };

    $scope.getNamespaces = function() {
      return $scope.datasource.metricFindQuery('namespaces()')
      .then($scope.transformToSegments(true));
    };

    $scope.getMetrics = function() {
      return $scope.datasource.metricFindQuery('metrics(' + $scope.target.namespace + ',' + $scope.target.region + ')')
      .then($scope.transformToSegments(true));
    };

    $scope.regionChanged = function() {
      $scope.target.region = $scope.regionSegment.value;
      $scope.onChange();
    };

    $scope.namespaceChanged = function() {
      $scope.target.namespace = $scope.namespaceSegment.value;
      $scope.onChange();
    };

    $scope.metricChanged = function() {
      $scope.target.metricName = $scope.metricSegment.value;
      $scope.onChange();
    };

    $scope.transformToSegments = function(addTemplateVars) {
      return function(results) {
        var segments = _.map(results, function(segment) {
          return uiSegmentSrv.newSegment({ value: segment.text, expandable: segment.expandable });
        });

        if (addTemplateVars) {
          _.each(templateSrv.variables, function(variable) {
            segments.unshift(uiSegmentSrv.newSegment({ type: 'template', value: '$' + variable.name, expandable: true }));
          });
        }

        return segments;
      };
    };

    $scope.init();

  }]);

}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(201)(module)))

/***/ }),

/***/ 1331:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__query_part__ = __webpack_require__(1332);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_app_core_utils_kbn__ = __webpack_require__(464);
///<reference path="../../../headers/common.d.ts" />



var InfluxQuery = /** @class */ (function () {
    /** @ngInject */
    InfluxQuery.$inject = ["target", "templateSrv", "scopedVars"];
    function InfluxQuery(target, templateSrv, scopedVars) {
        this.target = target;
        this.templateSrv = templateSrv;
        this.scopedVars = scopedVars;
        target.policy = target.policy || 'default';
        target.dsType = 'influxdb';
        target.resultFormat = target.resultFormat || 'time_series';
        target.orderByTime = target.orderByTime || 'ASC';
        target.tags = target.tags || [];
        target.groupBy = target.groupBy || [
            { type: 'time', params: ['$__interval'] },
            { type: 'fill', params: ['null'] },
        ];
        target.select = target.select || [[
                { type: 'field', params: ['value'] },
                { type: 'mean', params: [] },
            ]];
        this.updateProjection();
    }
    InfluxQuery.prototype.updateProjection = function () {
        this.selectModels = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.map(this.target.select, function (parts) {
            return __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.map(parts, __WEBPACK_IMPORTED_MODULE_1__query_part__["a" /* default */].create);
        });
        this.groupByParts = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.map(this.target.groupBy, __WEBPACK_IMPORTED_MODULE_1__query_part__["a" /* default */].create);
    };
    InfluxQuery.prototype.updatePersistedParts = function () {
        this.target.select = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.map(this.selectModels, function (selectParts) {
            return __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.map(selectParts, function (part) {
                return { type: part.def.type, params: part.params };
            });
        });
    };
    InfluxQuery.prototype.hasGroupByTime = function () {
        return __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.find(this.target.groupBy, function (g) { return g.type === 'time'; });
    };
    InfluxQuery.prototype.hasFill = function () {
        return __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.find(this.target.groupBy, function (g) { return g.type === 'fill'; });
    };
    InfluxQuery.prototype.addGroupBy = function (value) {
        var stringParts = value.match(/^(\w+)\((.*)\)$/);
        var typePart = stringParts[1];
        var arg = stringParts[2];
        var partModel = __WEBPACK_IMPORTED_MODULE_1__query_part__["a" /* default */].create({ type: typePart, params: [arg] });
        var partCount = this.target.groupBy.length;
        if (partCount === 0) {
            this.target.groupBy.push(partModel.part);
        }
        else if (typePart === 'time') {
            this.target.groupBy.splice(0, 0, partModel.part);
        }
        else if (typePart === 'tag') {
            if (this.target.groupBy[partCount - 1].type === 'fill') {
                this.target.groupBy.splice(partCount - 1, 0, partModel.part);
            }
            else {
                this.target.groupBy.push(partModel.part);
            }
        }
        else {
            this.target.groupBy.push(partModel.part);
        }
        this.updateProjection();
    };
    InfluxQuery.prototype.removeGroupByPart = function (part, index) {
        var categories = __WEBPACK_IMPORTED_MODULE_1__query_part__["a" /* default */].getCategories();
        if (part.def.type === 'time') {
            // remove fill
            this.target.groupBy = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.filter(this.target.groupBy, function (g) { return g.type !== 'fill'; });
            // remove aggregations
            this.target.select = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.map(this.target.select, function (s) {
                return __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.filter(s, function (part) {
                    var partModel = __WEBPACK_IMPORTED_MODULE_1__query_part__["a" /* default */].create(part);
                    if (partModel.def.category === categories.Aggregations) {
                        return false;
                    }
                    if (partModel.def.category === categories.Selectors) {
                        return false;
                    }
                    return true;
                });
            });
        }
        this.target.groupBy.splice(index, 1);
        this.updateProjection();
    };
    InfluxQuery.prototype.removeSelect = function (index) {
        this.target.select.splice(index, 1);
        this.updateProjection();
    };
    InfluxQuery.prototype.removeSelectPart = function (selectParts, part) {
        // if we remove the field remove the whole statement
        if (part.def.type === 'field') {
            if (this.selectModels.length > 1) {
                var modelsIndex = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.indexOf(this.selectModels, selectParts);
                this.selectModels.splice(modelsIndex, 1);
            }
        }
        else {
            var partIndex = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.indexOf(selectParts, part);
            selectParts.splice(partIndex, 1);
        }
        this.updatePersistedParts();
    };
    InfluxQuery.prototype.addSelectPart = function (selectParts, type) {
        var partModel = __WEBPACK_IMPORTED_MODULE_1__query_part__["a" /* default */].create({ type: type });
        partModel.def.addStrategy(selectParts, partModel, this);
        this.updatePersistedParts();
    };
    InfluxQuery.prototype.renderTagCondition = function (tag, index, interpolate) {
        var str = "";
        var operator = tag.operator;
        var value = tag.value;
        if (index > 0) {
            str = (tag.condition || 'AND') + ' ';
        }
        if (!operator) {
            if (/^\/.*\/$/.test(value)) {
                operator = '=~';
            }
            else {
                operator = '=';
            }
        }
        // quote value unless regex
        if (operator !== '=~' && operator !== '!~') {
            if (interpolate) {
                value = this.templateSrv.replace(value, this.scopedVars);
            }
            if (operator !== '>' && operator !== '<') {
                value = "'" + value.replace(/\\/g, '\\\\') + "'";
            }
        }
        else if (interpolate) {
            value = this.templateSrv.replace(value, this.scopedVars, 'regex');
        }
        return str + '"' + tag.key + '" ' + operator + ' ' + value;
    };
    InfluxQuery.prototype.getMeasurementAndPolicy = function (interpolate) {
        var policy = this.target.policy;
        var measurement = this.target.measurement || 'measurement';
        if (!measurement.match('^/.*/$')) {
            measurement = '"' + measurement + '"';
        }
        else if (interpolate) {
            measurement = this.templateSrv.replace(measurement, this.scopedVars, 'regex');
        }
        if (policy !== 'default') {
            policy = '"' + this.target.policy + '".';
        }
        else {
            policy = "";
        }
        return policy + measurement;
    };
    InfluxQuery.prototype.interpolateQueryStr = function (value, variable, defaultFormatFn) {
        // if no multi or include all do not regexEscape
        if (!variable.multi && !variable.includeAll) {
            return value;
        }
        if (typeof value === 'string') {
            return __WEBPACK_IMPORTED_MODULE_2_app_core_utils_kbn__["default"].regexEscape(value);
        }
        var escapedValues = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.map(value, __WEBPACK_IMPORTED_MODULE_2_app_core_utils_kbn__["default"].regexEscape);
        return '(' + escapedValues.join('|') + ')';
    };
    InfluxQuery.prototype.render = function (interpolate) {
        var _this = this;
        var target = this.target;
        if (target.rawQuery) {
            if (interpolate) {
                return this.templateSrv.replace(target.query, this.scopedVars, this.interpolateQueryStr);
            }
            else {
                return target.query;
            }
        }
        var query = 'SELECT ';
        var i, y;
        for (i = 0; i < this.selectModels.length; i++) {
            var parts = this.selectModels[i];
            var selectText = "";
            for (y = 0; y < parts.length; y++) {
                var part_1 = parts[y];
                selectText = part_1.render(selectText);
            }
            if (i > 0) {
                query += ', ';
            }
            query += selectText;
        }
        query += ' FROM ' + this.getMeasurementAndPolicy(interpolate) + ' WHERE ';
        var conditions = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.map(target.tags, function (tag, index) {
            return _this.renderTagCondition(tag, index, interpolate);
        });
        if (conditions.length > 0) {
            query += '(' + conditions.join(' ') + ') AND ';
        }
        query += '$timeFilter';
        var groupBySection = "";
        for (i = 0; i < this.groupByParts.length; i++) {
            var part = this.groupByParts[i];
            if (i > 0) {
                // for some reason fill has no seperator
                groupBySection += part.def.type === 'fill' ? ' ' : ', ';
            }
            groupBySection += part.render('');
        }
        if (groupBySection.length) {
            query += ' GROUP BY ' + groupBySection;
        }
        if (target.fill) {
            query += ' fill(' + target.fill + ')';
        }
        if (target.orderByTime === 'DESC') {
            query += ' ORDER BY time DESC';
        }
        if (target.limit) {
            query += ' LIMIT ' + target.limit;
        }
        if (target.slimit) {
            query += ' SLIMIT ' + target.slimit;
        }
        return query;
    };
    InfluxQuery.prototype.renderAdhocFilters = function (filters) {
        var _this = this;
        var conditions = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.map(filters, function (tag, index) {
            return _this.renderTagCondition(tag, index, false);
        });
        return conditions.join(' ');
    };
    return InfluxQuery;
}());
/* harmony default export */ __webpack_exports__["a"] = (InfluxQuery);


/***/ }),

/***/ 1332:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_app_core_components_query_part_query_part__ = __webpack_require__(1308);
///<reference path="../../../headers/common.d.ts" />


var index = [];
var categories = {
    Aggregations: [],
    Selectors: [],
    Transformations: [],
    Predictors: [],
    Math: [],
    Aliasing: [],
    Fields: [],
};
function createPart(part) {
    var def = index[part.type];
    if (!def) {
        throw { message: 'Could not find query part ' + part.type };
    }
    return new __WEBPACK_IMPORTED_MODULE_1_app_core_components_query_part_query_part__["a" /* QueryPart */](part, def);
}
function register(options) {
    index[options.type] = new __WEBPACK_IMPORTED_MODULE_1_app_core_components_query_part_query_part__["b" /* QueryPartDef */](options);
    options.category.push(index[options.type]);
}
var groupByTimeFunctions = [];
function aliasRenderer(part, innerExpr) {
    return innerExpr + ' AS ' + '"' + part.params[0] + '"';
}
function fieldRenderer(part, innerExpr) {
    if (part.params[0] === '*') {
        return '*';
    }
    return '"' + part.params[0] + '"';
}
function replaceAggregationAddStrategy(selectParts, partModel) {
    // look for existing aggregation
    for (var i = 0; i < selectParts.length; i++) {
        var part = selectParts[i];
        if (part.def.category === categories.Aggregations) {
            selectParts[i] = partModel;
            return;
        }
        if (part.def.category === categories.Selectors) {
            selectParts[i] = partModel;
            return;
        }
    }
    selectParts.splice(1, 0, partModel);
}
function addTransformationStrategy(selectParts, partModel) {
    var i;
    // look for index to add transformation
    for (i = 0; i < selectParts.length; i++) {
        var part = selectParts[i];
        if (part.def.category === categories.Math || part.def.category === categories.Aliasing) {
            break;
        }
    }
    selectParts.splice(i, 0, partModel);
}
function addMathStrategy(selectParts, partModel) {
    var partCount = selectParts.length;
    if (partCount > 0) {
        // if last is math, replace it
        if (selectParts[partCount - 1].def.type === 'math') {
            selectParts[partCount - 1] = partModel;
            return;
        }
        // if next to last is math, replace it
        if (partCount > 1 && selectParts[partCount - 2].def.type === 'math') {
            selectParts[partCount - 2] = partModel;
            return;
        }
        else if (selectParts[partCount - 1].def.type === 'alias') {
            selectParts.splice(partCount - 1, 0, partModel);
            return;
        }
    }
    selectParts.push(partModel);
}
function addAliasStrategy(selectParts, partModel) {
    var partCount = selectParts.length;
    if (partCount > 0) {
        // if last is alias, replace it
        if (selectParts[partCount - 1].def.type === 'alias') {
            selectParts[partCount - 1] = partModel;
            return;
        }
    }
    selectParts.push(partModel);
}
function addFieldStrategy(selectParts, partModel, query) {
    // copy all parts
    var parts = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.map(selectParts, function (part) {
        return createPart({ type: part.def.type, params: __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.clone(part.params) });
    });
    query.selectModels.push(parts);
}
register({
    type: 'field',
    addStrategy: addFieldStrategy,
    category: categories.Fields,
    params: [{ type: 'field', dynamicLookup: true }],
    defaultParams: ['value'],
    renderer: fieldRenderer,
});
// Aggregations
register({
    type: 'count',
    addStrategy: replaceAggregationAddStrategy,
    category: categories.Aggregations,
    params: [],
    defaultParams: [],
    renderer: __WEBPACK_IMPORTED_MODULE_1_app_core_components_query_part_query_part__["c" /* functionRenderer */],
});
register({
    type: 'distinct',
    addStrategy: replaceAggregationAddStrategy,
    category: categories.Aggregations,
    params: [],
    defaultParams: [],
    renderer: __WEBPACK_IMPORTED_MODULE_1_app_core_components_query_part_query_part__["c" /* functionRenderer */],
});
register({
    type: 'integral',
    addStrategy: replaceAggregationAddStrategy,
    category: categories.Aggregations,
    params: [],
    defaultParams: [],
    renderer: __WEBPACK_IMPORTED_MODULE_1_app_core_components_query_part_query_part__["c" /* functionRenderer */],
});
register({
    type: 'mean',
    addStrategy: replaceAggregationAddStrategy,
    category: categories.Aggregations,
    params: [],
    defaultParams: [],
    renderer: __WEBPACK_IMPORTED_MODULE_1_app_core_components_query_part_query_part__["c" /* functionRenderer */],
});
register({
    type: 'median',
    addStrategy: replaceAggregationAddStrategy,
    category: categories.Aggregations,
    params: [],
    defaultParams: [],
    renderer: __WEBPACK_IMPORTED_MODULE_1_app_core_components_query_part_query_part__["c" /* functionRenderer */],
});
register({
    type: 'mode',
    addStrategy: replaceAggregationAddStrategy,
    category: categories.Aggregations,
    params: [],
    defaultParams: [],
    renderer: __WEBPACK_IMPORTED_MODULE_1_app_core_components_query_part_query_part__["c" /* functionRenderer */],
});
register({
    type: 'sum',
    addStrategy: replaceAggregationAddStrategy,
    category: categories.Aggregations,
    params: [],
    defaultParams: [],
    renderer: __WEBPACK_IMPORTED_MODULE_1_app_core_components_query_part_query_part__["c" /* functionRenderer */],
});
// transformations
register({
    type: 'derivative',
    addStrategy: addTransformationStrategy,
    category: categories.Transformations,
    params: [{ name: "duration", type: "interval", options: ['1s', '10s', '1m', '5m', '10m', '15m', '1h'] }],
    defaultParams: ['10s'],
    renderer: __WEBPACK_IMPORTED_MODULE_1_app_core_components_query_part_query_part__["c" /* functionRenderer */],
});
register({
    type: 'spread',
    addStrategy: addTransformationStrategy,
    category: categories.Transformations,
    params: [],
    defaultParams: [],
    renderer: __WEBPACK_IMPORTED_MODULE_1_app_core_components_query_part_query_part__["c" /* functionRenderer */],
});
register({
    type: 'non_negative_derivative',
    addStrategy: addTransformationStrategy,
    category: categories.Transformations,
    params: [{ name: "duration", type: "interval", options: ['1s', '10s', '1m', '5m', '10m', '15m', '1h'] }],
    defaultParams: ['10s'],
    renderer: __WEBPACK_IMPORTED_MODULE_1_app_core_components_query_part_query_part__["c" /* functionRenderer */],
});
register({
    type: 'difference',
    addStrategy: addTransformationStrategy,
    category: categories.Transformations,
    params: [],
    defaultParams: [],
    renderer: __WEBPACK_IMPORTED_MODULE_1_app_core_components_query_part_query_part__["c" /* functionRenderer */],
});
register({
    type: 'non_negative_difference',
    addStrategy: addTransformationStrategy,
    category: categories.Transformations,
    params: [],
    defaultParams: [],
    renderer: __WEBPACK_IMPORTED_MODULE_1_app_core_components_query_part_query_part__["c" /* functionRenderer */],
});
register({
    type: 'moving_average',
    addStrategy: addTransformationStrategy,
    category: categories.Transformations,
    params: [{ name: "window", type: "int", options: [5, 10, 20, 30, 40] }],
    defaultParams: [10],
    renderer: __WEBPACK_IMPORTED_MODULE_1_app_core_components_query_part_query_part__["c" /* functionRenderer */],
});
register({
    type: 'cumulative_sum',
    addStrategy: addTransformationStrategy,
    category: categories.Transformations,
    params: [],
    defaultParams: [],
    renderer: __WEBPACK_IMPORTED_MODULE_1_app_core_components_query_part_query_part__["c" /* functionRenderer */],
});
register({
    type: 'stddev',
    addStrategy: addTransformationStrategy,
    category: categories.Transformations,
    params: [],
    defaultParams: [],
    renderer: __WEBPACK_IMPORTED_MODULE_1_app_core_components_query_part_query_part__["c" /* functionRenderer */],
});
register({
    type: 'time',
    category: groupByTimeFunctions,
    params: [{ name: "interval", type: "time", options: ['$__interval', '1s', '10s', '1m', '5m', '10m', '15m', '1h'] }],
    defaultParams: ['$__interval'],
    renderer: __WEBPACK_IMPORTED_MODULE_1_app_core_components_query_part_query_part__["c" /* functionRenderer */],
});
register({
    type: 'fill',
    category: groupByTimeFunctions,
    params: [{ name: "fill", type: "string", options: ['none', 'null', '0', 'previous', 'linear'] }],
    defaultParams: ['null'],
    renderer: __WEBPACK_IMPORTED_MODULE_1_app_core_components_query_part_query_part__["c" /* functionRenderer */],
});
register({
    type: 'elapsed',
    addStrategy: addTransformationStrategy,
    category: categories.Transformations,
    params: [{ name: "duration", type: "interval", options: ['1s', '10s', '1m', '5m', '10m', '15m', '1h'] }],
    defaultParams: ['10s'],
    renderer: __WEBPACK_IMPORTED_MODULE_1_app_core_components_query_part_query_part__["c" /* functionRenderer */],
});
// predictions
register({
    type: 'holt_winters',
    addStrategy: addTransformationStrategy,
    category: categories.Predictors,
    params: [{ name: "number", type: "int", options: [5, 10, 20, 30, 40] }, { name: "season", type: "int", options: [0, 1, 2, 5, 10] }],
    defaultParams: [10, 2],
    renderer: __WEBPACK_IMPORTED_MODULE_1_app_core_components_query_part_query_part__["c" /* functionRenderer */],
});
register({
    type: 'holt_winters_with_fit',
    addStrategy: addTransformationStrategy,
    category: categories.Predictors,
    params: [{ name: "number", type: "int", options: [5, 10, 20, 30, 40] }, { name: "season", type: "int", options: [0, 1, 2, 5, 10] }],
    defaultParams: [10, 2],
    renderer: __WEBPACK_IMPORTED_MODULE_1_app_core_components_query_part_query_part__["c" /* functionRenderer */],
});
// Selectors
register({
    type: 'bottom',
    addStrategy: replaceAggregationAddStrategy,
    category: categories.Selectors,
    params: [{ name: 'count', type: 'int' }],
    defaultParams: [3],
    renderer: __WEBPACK_IMPORTED_MODULE_1_app_core_components_query_part_query_part__["c" /* functionRenderer */],
});
register({
    type: 'first',
    addStrategy: replaceAggregationAddStrategy,
    category: categories.Selectors,
    params: [],
    defaultParams: [],
    renderer: __WEBPACK_IMPORTED_MODULE_1_app_core_components_query_part_query_part__["c" /* functionRenderer */],
});
register({
    type: 'last',
    addStrategy: replaceAggregationAddStrategy,
    category: categories.Selectors,
    params: [],
    defaultParams: [],
    renderer: __WEBPACK_IMPORTED_MODULE_1_app_core_components_query_part_query_part__["c" /* functionRenderer */],
});
register({
    type: 'max',
    addStrategy: replaceAggregationAddStrategy,
    category: categories.Selectors,
    params: [],
    defaultParams: [],
    renderer: __WEBPACK_IMPORTED_MODULE_1_app_core_components_query_part_query_part__["c" /* functionRenderer */],
});
register({
    type: 'min',
    addStrategy: replaceAggregationAddStrategy,
    category: categories.Selectors,
    params: [],
    defaultParams: [],
    renderer: __WEBPACK_IMPORTED_MODULE_1_app_core_components_query_part_query_part__["c" /* functionRenderer */],
});
register({
    type: 'percentile',
    addStrategy: replaceAggregationAddStrategy,
    category: categories.Selectors,
    params: [{ name: 'nth', type: 'int' }],
    defaultParams: [95],
    renderer: __WEBPACK_IMPORTED_MODULE_1_app_core_components_query_part_query_part__["c" /* functionRenderer */],
});
register({
    type: 'top',
    addStrategy: replaceAggregationAddStrategy,
    category: categories.Selectors,
    params: [{ name: 'count', type: 'int' }],
    defaultParams: [3],
    renderer: __WEBPACK_IMPORTED_MODULE_1_app_core_components_query_part_query_part__["c" /* functionRenderer */],
});
register({
    type: 'tag',
    category: groupByTimeFunctions,
    params: [{ name: 'tag', type: 'string', dynamicLookup: true }],
    defaultParams: ['tag'],
    renderer: fieldRenderer,
});
register({
    type: 'math',
    addStrategy: addMathStrategy,
    category: categories.Math,
    params: [{ name: "expr", type: "string" }],
    defaultParams: [' / 100'],
    renderer: __WEBPACK_IMPORTED_MODULE_1_app_core_components_query_part_query_part__["d" /* suffixRenderer */],
});
register({
    type: 'alias',
    addStrategy: addAliasStrategy,
    category: categories.Aliasing,
    params: [{ name: "name", type: "string", quote: 'double' }],
    defaultParams: ['alias'],
    renderMode: 'suffix',
    renderer: aliasRenderer,
});
/* harmony default export */ __webpack_exports__["a"] = ({
    create: createPart,
    getCategories: function () {
        return categories;
    }
});


/***/ }),

/***/ 1333:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return InfluxQueryBuilder; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_lodash__);

function renderTagCondition(tag, index) {
    var str = '';
    var operator = tag.operator;
    var value = tag.value;
    if (index > 0) {
        str = (tag.condition || 'AND') + ' ';
    }
    if (!operator) {
        if (/^\/.*\/$/.test(tag.value)) {
            operator = '=~';
        }
        else {
            operator = '=';
        }
    }
    // quote value unless regex or number
    if (operator !== '=~' && operator !== '!~' && isNaN(+value)) {
        value = "'" + value + "'";
    }
    return str + '"' + tag.key + '" ' + operator + ' ' + value;
}
var InfluxQueryBuilder = /** @class */ (function () {
    function InfluxQueryBuilder(target, database) {
        this.target = target;
        this.database = database;
    }
    InfluxQueryBuilder.prototype.buildExploreQuery = function (type, withKey, withMeasurementFilter) {
        var query;
        var measurement;
        var policy;
        if (type === 'TAG_KEYS') {
            query = 'SHOW TAG KEYS';
            measurement = this.target.measurement;
            policy = this.target.policy;
        }
        else if (type === 'TAG_VALUES') {
            query = 'SHOW TAG VALUES';
            measurement = this.target.measurement;
            policy = this.target.policy;
        }
        else if (type === 'MEASUREMENTS') {
            query = 'SHOW MEASUREMENTS';
            if (withMeasurementFilter) {
                query += ' WITH MEASUREMENT =~ /' + withMeasurementFilter + '/';
            }
        }
        else if (type === 'FIELDS') {
            measurement = this.target.measurement;
            policy = this.target.policy;
            if (!measurement.match('^/.*/')) {
                measurement = '"' + measurement + '"';
                if (policy && policy !== 'default') {
                    policy = '"' + policy + '"';
                    measurement = policy + '.' + measurement;
                }
            }
            return 'SHOW FIELD KEYS FROM ' + measurement;
        }
        else if (type === 'RETENTION POLICIES') {
            query = 'SHOW RETENTION POLICIES on "' + this.database + '"';
            return query;
        }
        if (measurement) {
            if (!measurement.match('^/.*/') && !measurement.match(/^merge\(.*\)/)) {
                measurement = '"' + measurement + '"';
            }
            if (policy && policy !== 'default') {
                policy = '"' + policy + '"';
                measurement = policy + '.' + measurement;
            }
            query += ' FROM ' + measurement;
        }
        if (withKey) {
            query += ' WITH KEY = "' + withKey + '"';
        }
        if (this.target.tags && this.target.tags.length > 0) {
            var whereConditions = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.reduce(this.target.tags, function (memo, tag) {
                // do not add a condition for the key we want to explore for
                if (tag.key === withKey) {
                    return memo;
                }
                memo.push(renderTagCondition(tag, memo.length));
                return memo;
            }, []);
            if (whereConditions.length > 0) {
                query += ' WHERE ' + whereConditions.join(' ');
            }
        }
        if (type === 'MEASUREMENTS') {
            query += ' LIMIT 100';
            //Solve issue #2524 by limiting the number of measurements returned
            //LIMIT must be after WITH MEASUREMENT and WHERE clauses
            //This also could be used for TAG KEYS and TAG VALUES, if desired
        }
        return query;
    };
    return InfluxQueryBuilder;
}());



/***/ }),

/***/ 1334:
/***/ (function(module, exports) {

/* Flot plugin for selecting regions of a plot.

Copyright (c) 2007-2013 IOLA and Ole Laursen.
Licensed under the MIT license.

The plugin supports these options:

selection: {
	mode: null or "x" or "y" or "xy",
	color: color,
	shape: "round" or "miter" or "bevel",
	minSize: number of pixels
}

Selection support is enabled by setting the mode to one of "x", "y" or "xy".
In "x" mode, the user will only be able to specify the x range, similarly for
"y" mode. For "xy", the selection becomes a rectangle where both ranges can be
specified. "color" is color of the selection (if you need to change the color
later on, you can get to it with plot.getOptions().selection.color). "shape"
is the shape of the corners of the selection.

"minSize" is the minimum size a selection can be in pixels. This value can
be customized to determine the smallest size a selection can be and still
have the selection rectangle be displayed. When customizing this value, the
fact that it refers to pixels, not axis units must be taken into account.
Thus, for example, if there is a bar graph in time mode with BarWidth set to 1
minute, setting "minSize" to 1 will not make the minimum selection size 1
minute, but rather 1 pixel. Note also that setting "minSize" to 0 will prevent
"plotunselected" events from being fired when the user clicks the mouse without
dragging.

When selection support is enabled, a "plotselected" event will be emitted on
the DOM element you passed into the plot function. The event handler gets a
parameter with the ranges selected on the axes, like this:

	placeholder.bind( "plotselected", function( event, ranges ) {
		alert("You selected " + ranges.xaxis.from + " to " + ranges.xaxis.to)
		// similar for yaxis - with multiple axes, the extra ones are in
		// x2axis, x3axis, ...
	});

The "plotselected" event is only fired when the user has finished making the
selection. A "plotselecting" event is fired during the process with the same
parameters as the "plotselected" event, in case you want to know what's
happening while it's happening,

A "plotunselected" event with no arguments is emitted when the user clicks the
mouse to remove the selection. As stated above, setting "minSize" to 0 will
destroy this behavior.

The plugin allso adds the following methods to the plot object:

- setSelection( ranges, preventEvent )

  Set the selection rectangle. The passed in ranges is on the same form as
  returned in the "plotselected" event. If the selection mode is "x", you
  should put in either an xaxis range, if the mode is "y" you need to put in
  an yaxis range and both xaxis and yaxis if the selection mode is "xy", like
  this:

	setSelection({ xaxis: { from: 0, to: 10 }, yaxis: { from: 40, to: 60 } });

  setSelection will trigger the "plotselected" event when called. If you don't
  want that to happen, e.g. if you're inside a "plotselected" handler, pass
  true as the second parameter. If you are using multiple axes, you can
  specify the ranges on any of those, e.g. as x2axis/x3axis/... instead of
  xaxis, the plugin picks the first one it sees.

- clearSelection( preventEvent )

  Clear the selection rectangle. Pass in true to avoid getting a
  "plotunselected" event.

- getSelection()

  Returns the current selection in the same format as the "plotselected"
  event. If there's currently no selection, the function returns null.

*/

(function ($) {
    function init(plot) {
        var selection = {
                first: { x: -1, y: -1}, second: { x: -1, y: -1},
                show: false,
                active: false
            };

        // FIXME: The drag handling implemented here should be
        // abstracted out, there's some similar code from a library in
        // the navigation plugin, this should be massaged a bit to fit
        // the Flot cases here better and reused. Doing this would
        // make this plugin much slimmer.
        var savedhandlers = {};

        var mouseUpHandler = null;

        function onMouseMove(e) {
            if (selection.active) {
                updateSelection(e);

                plot.getPlaceholder().trigger("plotselecting", [ getSelection() ]);
            }
        }

        function onMouseDown(e) {
            if (e.which != 1)  // only accept left-click
                return;

            // cancel out any text selections
            document.body.focus();

            // prevent text selection and drag in old-school browsers
            if (document.onselectstart !== undefined && savedhandlers.onselectstart == null) {
                savedhandlers.onselectstart = document.onselectstart;
                document.onselectstart = function () { return false; };
            }
            if (document.ondrag !== undefined && savedhandlers.ondrag == null) {
                savedhandlers.ondrag = document.ondrag;
                document.ondrag = function () { return false; };
            }

            setSelectionPos(selection.first, e);

            selection.active = true;

            // this is a bit silly, but we have to use a closure to be
            // able to whack the same handler again
            mouseUpHandler = function (e) { onMouseUp(e); };

            $(document).one("mouseup", mouseUpHandler);
        }

        function onMouseUp(e) {
            mouseUpHandler = null;

            // revert drag stuff for old-school browsers
            if (document.onselectstart !== undefined)
                document.onselectstart = savedhandlers.onselectstart;
            if (document.ondrag !== undefined)
                document.ondrag = savedhandlers.ondrag;

            // no more dragging
            selection.active = false;
            updateSelection(e);

            if (selectionIsSane())
                triggerSelectedEvent(e);
            else {
                // this counts as a clear
                plot.getPlaceholder().trigger("plotunselected", [ ]);
                plot.getPlaceholder().trigger("plotselecting", [ null ]);
            }

            setTimeout(function() {
              plot.isSelecting = false;
            }, 10);

            return false;
        }

        function getSelection() {
            if (!selectionIsSane())
                return null;

            if (!selection.show) return null;

            var r = {}, c1 = selection.first, c2 = selection.second;
            var axes = plot.getAxes();
            // look if no axis is used
            var noAxisInUse = true;
            $.each(axes, function (name, axis) {
              if (axis.used) {
                anyUsed = false;
              }
            })

            $.each(axes, function (name, axis) {
                if (axis.used || noAxisInUse) {
                    var p1 = axis.c2p(c1[axis.direction]), p2 = axis.c2p(c2[axis.direction]);
                    r[name] = { from: Math.min(p1, p2), to: Math.max(p1, p2) };
                }
            });
            return r;
        }

        function triggerSelectedEvent(event) {
            var r = getSelection();

            // Add ctrlKey and metaKey to event
            r.ctrlKey = event.ctrlKey;
            r.metaKey = event.metaKey;

            plot.getPlaceholder().trigger("plotselected", [ r ]);

            // backwards-compat stuff, to be removed in future
            if (r.xaxis && r.yaxis)
                plot.getPlaceholder().trigger("selected", [ { x1: r.xaxis.from, y1: r.yaxis.from, x2: r.xaxis.to, y2: r.yaxis.to } ]);
        }

        function clamp(min, value, max) {
            return value < min ? min: (value > max ? max: value);
        }

        function setSelectionPos(pos, e) {
            var o = plot.getOptions();
            var offset = plot.getPlaceholder().offset();
            var plotOffset = plot.getPlotOffset();
            pos.x = clamp(0, e.pageX - offset.left - plotOffset.left, plot.width());
            pos.y = clamp(0, e.pageY - offset.top - plotOffset.top, plot.height());

            if (o.selection.mode == "y")
                pos.x = pos == selection.first ? 0 : plot.width();

            if (o.selection.mode == "x")
                pos.y = pos == selection.first ? 0 : plot.height();
        }

        function updateSelection(pos) {
            if (pos.pageX == null)
                return;

            setSelectionPos(selection.second, pos);
            if (selectionIsSane()) {
                plot.isSelecting = true;
                selection.show = true;
                plot.triggerRedrawOverlay();
            }
            else
                clearSelection(true);
        }

        function clearSelection(preventEvent) {
            if (selection.show) {
                selection.show = false;
                plot.triggerRedrawOverlay();
                if (!preventEvent)
                    plot.getPlaceholder().trigger("plotunselected", [ ]);
            }
        }

        // function taken from markings support in Flot
        function extractRange(ranges, coord) {
            var axis, from, to, key, axes = plot.getAxes();

            for (var k in axes) {
                axis = axes[k];
                if (axis.direction == coord) {
                    key = coord + axis.n + "axis";
                    if (!ranges[key] && axis.n == 1)
                        key = coord + "axis"; // support x1axis as xaxis
                    if (ranges[key]) {
                        from = ranges[key].from;
                        to = ranges[key].to;
                        break;
                    }
                }
            }

            // backwards-compat stuff - to be removed in future
            if (!ranges[key]) {
                axis = coord == "x" ? plot.getXAxes()[0] : plot.getYAxes()[0];
                from = ranges[coord + "1"];
                to = ranges[coord + "2"];
            }

            // auto-reverse as an added bonus
            if (from != null && to != null && from > to) {
                var tmp = from;
                from = to;
                to = tmp;
            }

            return { from: from, to: to, axis: axis };
        }

        function setSelection(ranges, preventEvent) {
            var axis, range, o = plot.getOptions();

            if (o.selection.mode == "y") {
                selection.first.x = 0;
                selection.second.x = plot.width();
            }
            else {
                range = extractRange(ranges, "x");

                selection.first.x = range.axis.p2c(range.from);
                selection.second.x = range.axis.p2c(range.to);
            }

            if (o.selection.mode == "x") {
                selection.first.y = 0;
                selection.second.y = plot.height();
            }
            else {
                range = extractRange(ranges, "y");

                selection.first.y = range.axis.p2c(range.from);
                selection.second.y = range.axis.p2c(range.to);
            }

            selection.show = true;
            plot.triggerRedrawOverlay();
            if (!preventEvent && selectionIsSane())
                triggerSelectedEvent();
        }

        function selectionIsSane() {
            var minSize = plot.getOptions().selection.minSize;
            return Math.abs(selection.second.x - selection.first.x) >= minSize &&
                Math.abs(selection.second.y - selection.first.y) >= minSize;
        }

        plot.clearSelection = clearSelection;
        plot.setSelection = setSelection;
        plot.getSelection = getSelection;

        plot.hooks.bindEvents.push(function(plot, eventHolder) {
            var o = plot.getOptions();
            if (o.selection.mode != null) {
                eventHolder.mousemove(onMouseMove);
                eventHolder.mousedown(onMouseDown);
            }
        });


        plot.hooks.drawOverlay.push(function (plot, ctx) {
            // draw selection
            if (selection.show && selectionIsSane()) {
                var plotOffset = plot.getPlotOffset();
                var o = plot.getOptions();

                ctx.save();
                ctx.translate(plotOffset.left, plotOffset.top);

                var c = $.color.parse(o.selection.color);

                ctx.strokeStyle = c.scale('a', 0.8).toString();
                ctx.lineWidth = 1;
                ctx.lineJoin = o.selection.shape;
                ctx.fillStyle = c.scale('a', 0.4).toString();

                var x = Math.min(selection.first.x, selection.second.x) + 0.5,
                    y = Math.min(selection.first.y, selection.second.y) + 0.5,
                    w = Math.abs(selection.second.x - selection.first.x) - 1,
                    h = Math.abs(selection.second.y - selection.first.y) - 1;

                ctx.fillRect(x, y, w, h);
                ctx.strokeRect(x, y, w, h);

                ctx.restore();
            }
        });

        plot.hooks.shutdown.push(function (plot, eventHolder) {
            eventHolder.unbind("mousemove", onMouseMove);
            eventHolder.unbind("mousedown", onMouseDown);

            if (mouseUpHandler)
                $(document).unbind("mouseup", mouseUpHandler);
        });

    }

    $.plot.plugins.push({
        init: init,
        options: {
            selection: {
                mode: null, // one of null, "x", "y" or "xy"
                color: "#e8cfac",
                shape: "round", // one of "round", "miter", or "bevel"
                minSize: 5 // minimum number of pixels
            }
        },
        name: 'selection',
        version: '1.1'
    });
})(jQuery);


/***/ }),

/***/ 1335:
/***/ (function(module, exports) {

/* Pretty handling of time axes.

Copyright (c) 2007-2013 IOLA and Ole Laursen.
Licensed under the MIT license.

Set axis.mode to "time" to enable. See the section "Time series data" in
API.txt for details.

*/

(function($) {

	var options = {
		xaxis: {
			timezone: null,		// "browser" for local to the client or timezone for timezone-js
			timeformat: null,	// format string to use
			twelveHourClock: false,	// 12 or 24 time in time mode
			monthNames: null	// list of names of months
		}
	};

	// round to nearby lower multiple of base

	function floorInBase(n, base) {
		return base * Math.floor(n / base);
	}

	// Returns a string with the date d formatted according to fmt.
	// A subset of the Open Group's strftime format is supported.

	function formatDate(d, fmt, monthNames, dayNames) {

		if (typeof d.strftime == "function") {
			return d.strftime(fmt);
		}

		var leftPad = function(n, pad) {
			n = "" + n;
			pad = "" + (pad == null ? "0" : pad);
			return n.length == 1 ? pad + n : n;
		};

		var r = [];
		var escape = false;
		var hours = d.getHours();
		var isAM = hours < 12;

		if (monthNames == null) {
			monthNames = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
		}

		if (dayNames == null) {
			dayNames = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
		}

		var hours12;

		if (hours > 12) {
			hours12 = hours - 12;
		} else if (hours == 0) {
			hours12 = 12;
		} else {
			hours12 = hours;
		}

		for (var i = 0; i < fmt.length; ++i) {

			var c = fmt.charAt(i);

			if (escape) {
				switch (c) {
					case 'a': c = "" + dayNames[d.getDay()]; break;
					case 'b': c = "" + monthNames[d.getMonth()]; break;
					case 'd': c = leftPad(d.getDate(), ""); break;
					case 'e': c = leftPad(d.getDate(), " "); break;
					case 'h':	// For back-compat with 0.7; remove in 1.0
					case 'H': c = leftPad(hours); break;
					case 'I': c = leftPad(hours12); break;
					case 'l': c = leftPad(hours12, " "); break;
					case 'm': c = leftPad(d.getMonth() + 1, ""); break;
					case 'M': c = leftPad(d.getMinutes()); break;
					// quarters not in Open Group's strftime specification
					case 'q':
						c = "" + (Math.floor(d.getMonth() / 3) + 1); break;
					case 'S': c = leftPad(d.getSeconds()); break;
					case 'y': c = leftPad(d.getFullYear() % 100); break;
					case 'Y': c = "" + d.getFullYear(); break;
					case 'p': c = (isAM) ? ("" + "am") : ("" + "pm"); break;
					case 'P': c = (isAM) ? ("" + "AM") : ("" + "PM"); break;
					case 'w': c = "" + d.getDay(); break;
				}
				r.push(c);
				escape = false;
			} else {
				if (c == "%") {
					escape = true;
				} else {
					r.push(c);
				}
			}
		}

		return r.join("");
	}

	// To have a consistent view of time-based data independent of which time
	// zone the client happens to be in we need a date-like object independent
	// of time zones.  This is done through a wrapper that only calls the UTC
	// versions of the accessor methods.

	function makeUtcWrapper(d) {

		function addProxyMethod(sourceObj, sourceMethod, targetObj, targetMethod) {
			sourceObj[sourceMethod] = function() {
				return targetObj[targetMethod].apply(targetObj, arguments);
			};
		};

		var utc = {
			date: d
		};

		// support strftime, if found

		if (d.strftime != undefined) {
			addProxyMethod(utc, "strftime", d, "strftime");
		}

		addProxyMethod(utc, "getTime", d, "getTime");
		addProxyMethod(utc, "setTime", d, "setTime");

		var props = ["Date", "Day", "FullYear", "Hours", "Milliseconds", "Minutes", "Month", "Seconds"];

		for (var p = 0; p < props.length; p++) {
			addProxyMethod(utc, "get" + props[p], d, "getUTC" + props[p]);
			addProxyMethod(utc, "set" + props[p], d, "setUTC" + props[p]);
		}

		return utc;
	};

	// select time zone strategy.  This returns a date-like object tied to the
	// desired timezone

	function dateGenerator(ts, opts) {
		if (opts.timezone == "browser") {
			return new Date(ts);
		} else if (!opts.timezone || opts.timezone == "utc") {
			return makeUtcWrapper(new Date(ts));
		} else if (typeof timezoneJS != "undefined" && typeof timezoneJS.Date != "undefined") {
			var d = new timezoneJS.Date();
			// timezone-js is fickle, so be sure to set the time zone before
			// setting the time.
			d.setTimezone(opts.timezone);
			d.setTime(ts);
			return d;
		} else {
			return makeUtcWrapper(new Date(ts));
		}
	}

	// map of app. size of time units in milliseconds

	var timeUnitSize = {
		"second": 1000,
		"minute": 60 * 1000,
		"hour": 60 * 60 * 1000,
		"day": 24 * 60 * 60 * 1000,
		"month": 30 * 24 * 60 * 60 * 1000,
		"quarter": 3 * 30 * 24 * 60 * 60 * 1000,
		"year": 365.2425 * 24 * 60 * 60 * 1000
	};

	// the allowed tick sizes, after 1 year we use
	// an integer algorithm

	var baseSpec = [
		[1, "second"], [2, "second"], [5, "second"], [10, "second"],
		[30, "second"],
		[1, "minute"], [2, "minute"], [5, "minute"], [10, "minute"],
		[30, "minute"],
		[1, "hour"], [2, "hour"], [4, "hour"],
		[8, "hour"], [12, "hour"],
		[1, "day"], [2, "day"], [3, "day"],
		[0.25, "month"], [0.5, "month"], [1, "month"],
		[2, "month"]
	];

	// we don't know which variant(s) we'll need yet, but generating both is
	// cheap

	var specMonths = baseSpec.concat([[3, "month"], [6, "month"],
		[1, "year"]]);
	var specQuarters = baseSpec.concat([[1, "quarter"], [2, "quarter"],
		[1, "year"]]);

	function init(plot) {
		plot.hooks.processOptions.push(function (plot, options) {
			$.each(plot.getAxes(), function(axisName, axis) {

				var opts = axis.options;

				if (opts.mode == "time") {
					axis.tickGenerator = function(axis) {

						var ticks = [];
						var d = dateGenerator(axis.min, opts);
						var minSize = 0;

						// make quarter use a possibility if quarters are
						// mentioned in either of these options

						var spec = (opts.tickSize && opts.tickSize[1] ===
							"quarter") ||
							(opts.minTickSize && opts.minTickSize[1] ===
							"quarter") ? specQuarters : specMonths;

						if (opts.minTickSize != null) {
							if (typeof opts.tickSize == "number") {
								minSize = opts.tickSize;
							} else {
								minSize = opts.minTickSize[0] * timeUnitSize[opts.minTickSize[1]];
							}
						}

						for (var i = 0; i < spec.length - 1; ++i) {
							if (axis.delta < (spec[i][0] * timeUnitSize[spec[i][1]]
											  + spec[i + 1][0] * timeUnitSize[spec[i + 1][1]]) / 2
								&& spec[i][0] * timeUnitSize[spec[i][1]] >= minSize) {
								break;
							}
						}

						var size = spec[i][0];
						var unit = spec[i][1];

						// special-case the possibility of several years

						if (unit == "year") {

							// if given a minTickSize in years, just use it,
							// ensuring that it's an integer

							if (opts.minTickSize != null && opts.minTickSize[1] == "year") {
								size = Math.floor(opts.minTickSize[0]);
							} else {

								var magn = Math.pow(10, Math.floor(Math.log(axis.delta / timeUnitSize.year) / Math.LN10));
								var norm = (axis.delta / timeUnitSize.year) / magn;

								if (norm < 1.5) {
									size = 1;
								} else if (norm < 3) {
									size = 2;
								} else if (norm < 7.5) {
									size = 5;
								} else {
									size = 10;
								}

								size *= magn;
							}

							// minimum size for years is 1

							if (size < 1) {
								size = 1;
							}
						}

						axis.tickSize = opts.tickSize || [size, unit];
						var tickSize = axis.tickSize[0];
						unit = axis.tickSize[1];

						var step = tickSize * timeUnitSize[unit];

						if (unit == "second") {
							d.setSeconds(floorInBase(d.getSeconds(), tickSize));
						} else if (unit == "minute") {
							d.setMinutes(floorInBase(d.getMinutes(), tickSize));
						} else if (unit == "hour") {
							d.setHours(floorInBase(d.getHours(), tickSize));
						} else if (unit == "month") {
							d.setMonth(floorInBase(d.getMonth(), tickSize));
						} else if (unit == "quarter") {
							d.setMonth(3 * floorInBase(d.getMonth() / 3,
								tickSize));
						} else if (unit == "year") {
							d.setFullYear(floorInBase(d.getFullYear(), tickSize));
						}

						// reset smaller components

						d.setMilliseconds(0);

						if (step >= timeUnitSize.minute) {
							d.setSeconds(0);
						}
						if (step >= timeUnitSize.hour) {
							d.setMinutes(0);
						}
						if (step >= timeUnitSize.day) {
							d.setHours(0);
						}
						if (step >= timeUnitSize.day * 4) {
							d.setDate(1);
						}
						if (step >= timeUnitSize.month * 2) {
							d.setMonth(floorInBase(d.getMonth(), 3));
						}
						if (step >= timeUnitSize.quarter * 2) {
							d.setMonth(floorInBase(d.getMonth(), 6));
						}
						if (step >= timeUnitSize.year) {
							d.setMonth(0);
						}

						var carry = 0;
						var v = Number.NaN;
						var prev;

						do {

							prev = v;
							v = d.getTime();
							ticks.push(v);

							if (unit == "month" || unit == "quarter") {
								if (tickSize < 1) {

									// a bit complicated - we'll divide the
									// month/quarter up but we need to take
									// care of fractions so we don't end up in
									// the middle of a day

									d.setDate(1);
									var start = d.getTime();
									d.setMonth(d.getMonth() +
										(unit == "quarter" ? 3 : 1));
									var end = d.getTime();
									d.setTime(v + carry * timeUnitSize.hour + (end - start) * tickSize);
									carry = d.getHours();
									d.setHours(0);
								} else {
									d.setMonth(d.getMonth() +
										tickSize * (unit == "quarter" ? 3 : 1));
								}
							} else if (unit == "year") {
								d.setFullYear(d.getFullYear() + tickSize);
							} else {
								d.setTime(v + step);
							}
						} while (v < axis.max && v != prev);

						return ticks;
					};

					axis.tickFormatter = function (v, axis) {

						var d = dateGenerator(v, axis.options);

						// first check global format

						if (opts.timeformat != null) {
							return formatDate(d, opts.timeformat, opts.monthNames, opts.dayNames);
						}

						// possibly use quarters if quarters are mentioned in
						// any of these places

						var useQuarters = (axis.options.tickSize &&
								axis.options.tickSize[1] == "quarter") ||
							(axis.options.minTickSize &&
								axis.options.minTickSize[1] == "quarter");

						var t = axis.tickSize[0] * timeUnitSize[axis.tickSize[1]];
						var span = axis.max - axis.min;
						var suffix = (opts.twelveHourClock) ? " %p" : "";
						var hourCode = (opts.twelveHourClock) ? "%I" : "%H";
						var fmt;

						if (t < timeUnitSize.minute) {
							fmt = hourCode + ":%M:%S" + suffix;
						} else if (t < timeUnitSize.day) {
							if (span < 2 * timeUnitSize.day) {
								fmt = hourCode + ":%M" + suffix;
							} else {
								fmt = "%b %d " + hourCode + ":%M" + suffix;
							}
						} else if (t < timeUnitSize.month) {
							fmt = "%b %d";
						} else if ((useQuarters && t < timeUnitSize.quarter) ||
							(!useQuarters && t < timeUnitSize.year)) {
							if (span < timeUnitSize.year) {
								fmt = "%b";
							} else {
								fmt = "%b %Y";
							}
						} else if (useQuarters && t < timeUnitSize.year) {
							if (span < timeUnitSize.year) {
								fmt = "Q%q";
							} else {
								fmt = "Q%q %Y";
							}
						} else {
							fmt = "%Y";
						}

						var rt = formatDate(d, fmt, opts.monthNames, opts.dayNames);

						return rt;
					};
				}
			});
		});
	}

	$.plot.plugins.push({
		init: init,
		options: options,
		name: 'time',
		version: '1.0'
	});

	// Time-axis support used to be in Flot core, which exposed the
	// formatDate function on the plot object.  Various plugins depend
	// on the function, so we need to re-expose it here.

	$.plot.formatDate = formatDate;

})(jQuery);


/***/ }),

/***/ 1336:
/***/ (function(module, exports) {

/* Flot plugin for stacking data sets rather than overlyaing them.

Copyright (c) 2007-2014 IOLA and Ole Laursen.
Licensed under the MIT license.

The plugin assumes the data is sorted on x (or y if stacking horizontally).
For line charts, it is assumed that if a line has an undefined gap (from a
null point), then the line above it should have the same gap - insert zeros
instead of "null" if you want another behaviour. This also holds for the start
and end of the chart. Note that stacking a mix of positive and negative values
in most instances doesn't make sense (so it looks weird).

Two or more series are stacked when their "stack" attribute is set to the same
key (which can be any number or string or just "true"). To specify the default
stack, you can set the stack option like this:

    series: {
        stack: null/false, true, or a key (number/string)
    }

You can also specify it for a single series, like this:

    $.plot( $("#placeholder"), [{
        data: [ ... ],
        stack: true
    }])

The stacking order is determined by the order of the data series in the array
(later series end up on top of the previous).

Internally, the plugin modifies the datapoints in each series, adding an
offset to the y value. For line series, extra data points are inserted through
interpolation. If there's a second y value, it's also adjusted (e.g for bar
charts or filled areas).

*/

(function ($) {
    var options = {
        series: { stack: null } // or number/string
    };

    function init(plot) {
        function findMatchingSeries(s, allseries) {
            var res = null;
            for (var i = 0; i < allseries.length; ++i) {
                if (s == allseries[i])
                    break;

                if (allseries[i].stack == s.stack)
                    res = allseries[i];
            }

            return res;
        }

        function stackData(plot, s, datapoints) {
            if (s.stack == null || s.stack === false)
                return;

            var other = findMatchingSeries(s, plot.getData());
            if (!other)
                return;

            var ps = datapoints.pointsize,
                points = datapoints.points,
                otherps = other.datapoints.pointsize,
                otherpoints = other.datapoints.points,
                newpoints = [],
                px, py, intery, qx, qy, bottom,
                withlines = s.lines.show,
                horizontal = s.bars.horizontal,
                withbottom = ps > 2 && (horizontal ? datapoints.format[2].x : datapoints.format[2].y),
                withsteps = withlines && s.lines.steps,
                keyOffset = horizontal ? 1 : 0,
                accumulateOffset = horizontal ? 0 : 1,
                i = 0, j = 0, l, m;

            while (true) {
                if (i >= points.length && j >= otherpoints.length)
                    break;

                l = newpoints.length;

                if (i < points.length && points[i] == null) {
                    // copy gaps
                    for (m = 0; m < ps; ++m)
                        newpoints.push(points[i + m]);
                    i += ps;
                }
                else if (i >= points.length) {
                    // take the remaining points from the previous series
                    for (m = 0; m < ps; ++m)
                        newpoints.push(otherpoints[j + m]);
                    if (withbottom)
                        newpoints[l + 2] = otherpoints[j + accumulateOffset];
                    j += otherps;
                }
                else if (j >= otherpoints.length) {
                    // take the remaining points from the current series
                    for (m = 0; m < ps; ++m)
                        newpoints.push(points[i + m]);
                    i += ps;
                }
                else if (j < otherpoints.length && otherpoints[j] == null) {
                    // ignore point
                    j += otherps;
                }
                else {
                    // cases where we actually got two points
                    px = points[i + keyOffset];
                    py = points[i + accumulateOffset];
                    qx = otherpoints[j + keyOffset];
                    qy = otherpoints[j + accumulateOffset];
                    bottom = 0;

                    if (px == qx) {
                        for (m = 0; m < ps; ++m)
                            newpoints.push(points[i + m]);

                        newpoints[l + accumulateOffset] += qy;
                        bottom = qy;

                        i += ps;
                        j += otherps;
                    }
                    else if (px > qx) {
                        // take the point from the previous series so that next series will correctly stack
                        if (i == 0) {
                            for (m = 0; m < ps; ++m)
                                newpoints.push(otherpoints[j + m]);
                            bottom = qy;
                        }
                        // we got past point below, might need to
                        // insert interpolated extra point
                        if (i > 0 && points[i - ps] != null) {
                            intery = py + (points[i - ps + accumulateOffset] - py) * (qx - px) / (points[i - ps + keyOffset] - px);
                            newpoints.push(qx);
                            newpoints.push(intery + qy);
                            for (m = 2; m < ps; ++m)
                                newpoints.push(points[i + m]);
                            bottom = qy;
                        }

                        j += otherps;
                    }
                    else { // px < qx
                        for (m = 0; m < ps; ++m)
                            newpoints.push(points[i + m]);

                        // we might be able to interpolate a point below,
                        // this can give us a better y
                        if (j > 0 && otherpoints[j - otherps] != null)
                            bottom = qy + (otherpoints[j - otherps + accumulateOffset] - qy) * (px - qx) / (otherpoints[j - otherps + keyOffset] - qx);

                        newpoints[l + accumulateOffset] += bottom;

                        i += ps;
                    }

                    fromgap = false;

                    if (l != newpoints.length && withbottom)
                        newpoints[l + 2] = bottom;
                }

                // maintain the line steps invariant
                if (withsteps && l != newpoints.length && l > 0
                    && newpoints[l] != null
                    && newpoints[l] != newpoints[l - ps]
                    && newpoints[l + 1] != newpoints[l - ps + 1]) {
                    for (m = 0; m < ps; ++m)
                        newpoints[l + ps + m] = newpoints[l + m];
                    newpoints[l + 1] = newpoints[l - ps + 1];
                }
            }

            datapoints.points = newpoints;
        }

        plot.hooks.processDatapoints.push(stackData);
    }

    $.plot.plugins.push({
        init: init,
        options: options,
        name: 'stack',
        version: '1.2'
    });
})(jQuery);


/***/ }),

/***/ 1337:
/***/ (function(module, exports) {

(function ($) {
    var options = {
        series: {
            stackpercent: null
        } // or number/string
    };

    function init(plot) {

        // will be built up dynamically as a hash from x-value, or y-value if horizontal
        var stackBases = {};
        var processed = false;
        var stackSums = {};

        //set percentage for stacked chart
        function processRawData(plot, series, data, datapoints) {
            if (!processed) {
                processed = true;
                stackSums = getStackSums(plot.getData());
            }
			if (series.stackpercent == true) {
				var num = data.length;
				series.percents = [];
				var key_idx = 0;
				var value_idx = 1;
				if (series.bars && series.bars.horizontal && series.bars.horizontal === true) {
					key_idx = 1;
					value_idx = 0;
				}
				for (var j = 0; j < num; j++) {
					var sum = stackSums[data[j][key_idx] + ""];
					if (sum > 0) {
						series.percents.push(data[j][value_idx] * 100 / sum);
					} else {
						series.percents.push(0);
					}
				}
			}
        }

        //calculate summary
        function getStackSums(_data) {
            var data_len = _data.length;
            var sums = {};
            if (data_len > 0) {
                //caculate summary
                for (var i = 0; i < data_len; i++) {
                    if (_data[i].stackpercent) {
						var key_idx = 0;
						var value_idx = 1;
						if (_data[i].bars && _data[i].bars.horizontal && _data[i].bars.horizontal === true) {
							key_idx = 1;
							value_idx = 0;
						}
                        var num = _data[i].data.length;
                        for (var j = 0; j < num; j++) {
                            var value = 0;
                            if (_data[i].data[j][1] != null) {
                                value = _data[i].data[j][value_idx];
                            }
                            if (sums[_data[i].data[j][key_idx] + ""]) {
                                sums[_data[i].data[j][key_idx] + ""] += value;
                            } else {
                                sums[_data[i].data[j][key_idx] + ""] = value;
                            }

                        }
                    }
                }
            }
            return sums;
        }

        function stackData(plot, s, datapoints) {
            if (!s.stackpercent) return;
            if (!processed) {
                stackSums = getStackSums(plot.getData());
            }
            var newPoints = [];


			var key_idx = 0;
			var value_idx = 1;
			if (s.bars && s.bars.horizontal && s.bars.horizontal === true) {
				key_idx = 1;
				value_idx = 0;
			}

			for (var i = 0; i < datapoints.points.length; i += 3) {
				// note that the values need to be turned into absolute y-values.
				// in other words, if you were to stack (x, y1), (x, y2), and (x, y3),
				// (each from different series, which is where stackBases comes in),
				// you'd want the new points to be (x, y1, 0), (x, y1+y2, y1), (x, y1+y2+y3, y1+y2)
				// generally, (x, thisValue + (base up to this point), + (base up to this point))
				if (!stackBases[datapoints.points[i + key_idx]]) {
					stackBases[datapoints.points[i + key_idx]] = 0;
				}
				newPoints[i + key_idx] = datapoints.points[i + key_idx];
				newPoints[i + value_idx] = datapoints.points[i + value_idx] + stackBases[datapoints.points[i + key_idx]];
				newPoints[i + 2] = stackBases[datapoints.points[i + key_idx]];
				stackBases[datapoints.points[i + key_idx]] += datapoints.points[i + value_idx];
				// change points to percentage values
				// you may need to set yaxis:{ max = 100 }
				if ( stackSums[newPoints[i+key_idx]+""] > 0 ){
					newPoints[i + value_idx] = newPoints[i + value_idx] * 100 / stackSums[newPoints[i + key_idx] + ""];
					newPoints[i + 2] = newPoints[i + 2] * 100 / stackSums[newPoints[i + key_idx] + ""];
				} else {
					newPoints[i + value_idx] = 0;
					newPoints[i + 2] = 0;
				}
			}

            datapoints.points = newPoints;
        }

		plot.hooks.processRawData.push(processRawData);
        plot.hooks.processDatapoints.push(stackData);
    }

    $.plot.plugins.push({
        init: init,
        options: options,
        name: 'stackpercent',
        version: '0.1'
    });
})(jQuery);


/***/ }),

/***/ 1338:
/***/ (function(module, exports) {

(function($) {
    "use strict";

    var options = {
        series: {
            fillBelowTo: null
        }
    };

    function init(plot) {
        function findBelowSeries( series, allseries ) {

            var i;

            for ( i = 0; i < allseries.length; ++i ) {
                if ( allseries[ i ].id === series.fillBelowTo ) {
                    return allseries[ i ];
                }
            }

            return null;
        }

        /* top and bottom doesn't actually matter for this, we're just using it to help make this easier to think about */
        /* this is a vector cross product operation */
        function segmentIntersection(top_left_x, top_left_y, top_right_x, top_right_y, bottom_left_x, bottom_left_y, bottom_right_x, bottom_right_y) {
            var top_delta_x, top_delta_y, bottom_delta_x, bottom_delta_y,
                s, t;

            top_delta_x = top_right_x - top_left_x;
            top_delta_y = top_right_y - top_left_y;
            bottom_delta_x = bottom_right_x - bottom_left_x;
            bottom_delta_y = bottom_right_y - bottom_left_y;

            s = (
                (-top_delta_y * (top_left_x - bottom_left_x)) + (top_delta_x * (top_left_y - bottom_left_y))
            ) / (
                -bottom_delta_x * top_delta_y + top_delta_x * bottom_delta_y
            );

            t = (
                (bottom_delta_x * (top_left_y - bottom_left_y)) - (bottom_delta_y * (top_left_x - bottom_left_x))
            ) / (
                -bottom_delta_x * top_delta_y + top_delta_x * bottom_delta_y
            );

            // Collision detected
            if (s >= 0 && s <= 1 && t >= 0 && t <= 1) {
                return [
                    top_left_x + (t * top_delta_x), // X
                    top_left_y + (t * top_delta_y) // Y
                ];
            }

            // No collision
            return null;
        }

        function plotDifferenceArea(plot, ctx, series) {
            if ( series.fillBelowTo === null ) {
                return;
            }

            var otherseries,

                ps,
                points,

                otherps,
                otherpoints,

                plotOffset,
                fillStyle;

            function openPolygon(x, y) {
                ctx.beginPath();
                ctx.moveTo(
                    series.xaxis.p2c(x) + plotOffset.left,
                    series.yaxis.p2c(y) + plotOffset.top
                );

            }

            function closePolygon() {
                ctx.closePath();
                ctx.fill();
            }

            function validateInput() {
                if (points.length/ps !== otherpoints.length/otherps) {
                    console.error("Refusing to graph inconsistent number of points");
                    return false;
                }

                var i;
                for (i = 0; i < (points.length / ps); i++) {
                    if (
                        points[i * ps] !== null &&
                        otherpoints[i * otherps] !== null &&
                        points[i * ps] !== otherpoints[i * otherps]
                    ) {
                        console.error("Refusing to graph points without matching value");
                        return false;
                    }
                }

                return true;
            }

            function findNextStart(start_i, end_i) {
                console.assert(end_i > start_i, "expects the end index to be greater than the start index");

                var start = (
                        start_i === 0 ||
                        points[start_i - 1] === null ||
                        otherpoints[start_i - 1] === null
                    ),
                    equal = false,
                    i,
                    intersect;

                for (i = start_i; i < end_i; i++) {
                    // Take note of null points
                    if (
                        points[(i * ps) + 1] === null ||
                        otherpoints[(i * ps) + 1] === null
                    ) {
                        equal = false;
                        start = true;
                    }

                    // Take note of equal points
                    else if (points[(i * ps) + 1] === otherpoints[(i * otherps) + 1]) {
                        equal = true;
                        start = false;
                    }


                    else if (points[(i * ps) + 1] > otherpoints[(i * otherps) + 1]) {
                        // If we begin above the desired point
                        if (start) {
                            openPolygon(points[i * ps], points[(i * ps) + 1]);
                        }

                        // If an equal point preceeds this, start the polygon at that equal point
                        else if (equal) {
                            openPolygon(points[(i - 1) * ps], points[((i - 1) * ps) + 1]);
                        }

                        // Otherwise, find the intersection point, and start it there
                        else {
                            intersect = intersectionPoint(i);
                            openPolygon(intersect[0], intersect[1]);
                        }

                        topTraversal(i, end_i);
                        return;
                    }

                    // If we go below equal, equal at any preceeding point is irrelevant
                    else {
                        start = false;
                        equal = false;
                    }
                }
            }

            function intersectionPoint(right_i) {
                console.assert(right_i > 0, "expects the second point in the series line segment");

                var i, intersect;

                for (i = 1; i < (otherpoints.length/otherps); i++) {
                    intersect = segmentIntersection(
                        points[(right_i - 1) * ps], points[((right_i - 1) * ps) + 1],
                        points[right_i * ps], points[(right_i * ps) + 1],

                        otherpoints[(i - 1) * otherps], otherpoints[((i - 1) * otherps) + 1],
                        otherpoints[i * otherps], otherpoints[(i * otherps) + 1]
                    );

                    if (intersect !== null) {
                        return intersect;
                    }
                }

                console.error("intersectionPoint() should only be called when an intersection happens");
            }

            function bottomTraversal(start_i, end_i) {
                console.assert(start_i >= end_i, "the start should be the rightmost point, and the end should be the leftmost (excluding the equal or intersecting point)");

                var i;

                for (i = start_i; i >= end_i; i--) {
                    ctx.lineTo(
                        otherseries.xaxis.p2c(otherpoints[i * otherps]) + plotOffset.left,
                        otherseries.yaxis.p2c(otherpoints[(i * otherps) + 1]) + plotOffset.top
                    );
                }

                closePolygon();
            }

            function topTraversal(start_i, end_i) {
                console.assert(start_i <= end_i, "the start should be the rightmost point, and the end should be the leftmost (excluding the equal or intersecting point)");

                var i,
                    intersect;

                for (i = start_i; i < end_i; i++) {
                    if (points[(i * ps) + 1] === null && i > start_i) {
                        bottomTraversal(i - 1, start_i);
                        findNextStart(i, end_i);
                        return;
                    }

                    else if (points[(i * ps) + 1] === otherpoints[(i * otherps) + 1]) {
                        bottomTraversal(i, start_i);
                        findNextStart(i, end_i);
                        return;
                    }

                    else if (points[(i * ps) + 1] < otherpoints[(i * otherps) + 1]) {
                        intersect = intersectionPoint(i);
                        ctx.lineTo(
                            series.xaxis.p2c(intersect[0]) + plotOffset.left,
                            series.yaxis.p2c(intersect[1]) + plotOffset.top
                        );
                        bottomTraversal(i, start_i);
                        findNextStart(i, end_i);
                        return;

                    }

                    else {
                        ctx.lineTo(
                            series.xaxis.p2c(points[i * ps]) + plotOffset.left,
                            series.yaxis.p2c(points[(i * ps) + 1]) + plotOffset.top
                        );
                    }
                }

                bottomTraversal(end_i, start_i);
            }


            // Begin processing

            otherseries = findBelowSeries( series, plot.getData() );

            if ( !otherseries ) {
                return;
            }

            ps = series.datapoints.pointsize;
            points = series.datapoints.points;
            otherps = otherseries.datapoints.pointsize;
            otherpoints = otherseries.datapoints.points;
            plotOffset = plot.getPlotOffset();

            if (!validateInput()) {
                return;
            }


            // Flot's getFillStyle() should probably be exposed somewhere
            fillStyle = $.color.parse(series.color);
            fillStyle.a = 0.4;
            fillStyle.normalize();
            ctx.fillStyle = fillStyle.toString();


            // Begin recursive bi-directional traversal
            findNextStart(0, points.length/ps);
        }

        plot.hooks.drawSeries.push(plotDifferenceArea);
    }

    $.plot.plugins.push({
        init: init,
        options: options,
        name: "fillbelow",
        version: "0.1.0"
    });

})(jQuery);


/***/ }),

/***/ 1339:
/***/ (function(module, exports) {

/* Flot plugin for showing crosshairs when the mouse hovers over the plot.

Copyright (c) 2007-2014 IOLA and Ole Laursen.
Licensed under the MIT license.

The plugin supports these options:

	crosshair: {
		mode: null or "x" or "y" or "xy"
		color: color
		lineWidth: number
	}

Set the mode to one of "x", "y" or "xy". The "x" mode enables a vertical
crosshair that lets you trace the values on the x axis, "y" enables a
horizontal crosshair and "xy" enables them both. "color" is the color of the
crosshair (default is "rgba(170, 0, 0, 0.80)"), "lineWidth" is the width of
the drawn lines (default is 1).

The plugin also adds four public methods:

  - setCrosshair( pos )

    Set the position of the crosshair. Note that this is cleared if the user
    moves the mouse. "pos" is in coordinates of the plot and should be on the
    form { x: xpos, y: ypos } (you can use x2/x3/... if you're using multiple
    axes), which is coincidentally the same format as what you get from a
    "plothover" event. If "pos" is null, the crosshair is cleared.

  - clearCrosshair()

    Clear the crosshair.

  - lockCrosshair(pos)

    Cause the crosshair to lock to the current location, no longer updating if
    the user moves the mouse. Optionally supply a position (passed on to
    setCrosshair()) to move it to.

    Example usage:

	var myFlot = $.plot( $("#graph"), ..., { crosshair: { mode: "x" } } };
	$("#graph").bind( "plothover", function ( evt, position, item ) {
		if ( item ) {
			// Lock the crosshair to the data point being hovered
			myFlot.lockCrosshair({
				x: item.datapoint[ 0 ],
				y: item.datapoint[ 1 ]
			});
		} else {
			// Return normal crosshair operation
			myFlot.unlockCrosshair();
		}
	});

  - unlockCrosshair()

    Free the crosshair to move again after locking it.
*/

(function ($) {
    var options = {
        crosshair: {
            mode: null, // one of null, "x", "y" or "xy",
            color: "rgba(170, 0, 0, 0.80)",
            lineWidth: 1
        }
    };
    
    function init(plot) {
        // position of crosshair in pixels
        var crosshair = { x: -1, y: -1, locked: false };

        plot.setCrosshair = function setCrosshair(pos) {
            if (!pos)
                crosshair.x = -1;
            else {
                var o = plot.p2c(pos);
                crosshair.x = Math.max(0, Math.min(o.left, plot.width()));
                crosshair.y = Math.max(0, Math.min(o.top, plot.height()));
            }
            
            plot.triggerRedrawOverlay();
        };
        
        plot.clearCrosshair = plot.setCrosshair; // passes null for pos
        
        plot.lockCrosshair = function lockCrosshair(pos) {
            if (pos)
                plot.setCrosshair(pos);
            crosshair.locked = true;
        };

        plot.unlockCrosshair = function unlockCrosshair() {
            crosshair.locked = false;
        };

        function onMouseOut(e) {
            if (crosshair.locked)
                return;

            if (crosshair.x != -1) {
                crosshair.x = -1;
                plot.triggerRedrawOverlay();
            }
        }

        function onMouseMove(e) {
            if (crosshair.locked)
                return;
                
            if (plot.getSelection && plot.getSelection()) {
                crosshair.x = -1; // hide the crosshair while selecting
                return;
            }
                
            var offset = plot.offset();
            crosshair.x = Math.max(0, Math.min(e.pageX - offset.left, plot.width()));
            crosshair.y = Math.max(0, Math.min(e.pageY - offset.top, plot.height()));
            plot.triggerRedrawOverlay();
        }
        
        plot.hooks.bindEvents.push(function (plot, eventHolder) {
            if (!plot.getOptions().crosshair.mode)
                return;

            eventHolder.mouseout(onMouseOut);
            eventHolder.mousemove(onMouseMove);
        });

        plot.hooks.drawOverlay.push(function (plot, ctx) {
            var c = plot.getOptions().crosshair;
            if (!c.mode)
                return;

            var plotOffset = plot.getPlotOffset();
            
            ctx.save();
            ctx.translate(plotOffset.left, plotOffset.top);

            if (crosshair.x != -1) {
                var adj = plot.getOptions().crosshair.lineWidth % 2 ? 0.5 : 0;

                ctx.strokeStyle = c.color;
                ctx.lineWidth = c.lineWidth;
                ctx.lineJoin = "round";

                ctx.beginPath();
                if (c.mode.indexOf("x") != -1) {
                    var drawX = Math.floor(crosshair.x) + adj;
                    ctx.moveTo(drawX, 0);
                    ctx.lineTo(drawX, plot.height());
                }
                if (c.mode.indexOf("y") != -1) {
                    var drawY = Math.floor(crosshair.y) + adj;
                    ctx.moveTo(0, drawY);
                    ctx.lineTo(plot.width(), drawY);
                }
                ctx.stroke();
            }
            ctx.restore();
        });

        plot.hooks.shutdown.push(function (plot, eventHolder) {
            eventHolder.unbind("mouseout", onMouseOut);
            eventHolder.unbind("mousemove", onMouseMove);
        });
    }
    
    $.plot.plugins.push({
        init: init,
        options: options,
        name: 'crosshair',
        version: '1.0'
    });
})(jQuery);


/***/ }),

/***/ 1340:
/***/ (function(module, exports) {

/*
 * jQuery.flot.dashes
 *
 * options = {
 *   series: {
 *     dashes: {
 *
 *       // show
 *       // default: false
 *       // Whether to show dashes for the series.
 *       show: <boolean>,
 *
 *       // lineWidth
 *       // default: 2
 *       // The width of the dashed line in pixels.
 *       lineWidth: <number>,
 *
 *       // dashLength
 *       // default: 10
 *       // Controls the length of the individual dashes and the amount of
 *       // space between them.
 *       // If this is a number, the dashes and spaces will have that length.
 *       // If this is an array, it is read as [ dashLength, spaceLength ]
 *       dashLength: <number> or <array[2]>
 *     }
 *   }
 * }
 */
(function($){

  function init(plot) {

    plot.hooks.processDatapoints.push(function(plot, series, datapoints) {

      if (!series.dashes.show) return;

      plot.hooks.draw.push(function(plot, ctx) {

        var plotOffset = plot.getPlotOffset(),
          axisx = series.xaxis,
          axisy = series.yaxis;

        function plotDashes(xoffset, yoffset) {

          var points = datapoints.points,
            ps = datapoints.pointsize,
            prevx = null,
            prevy = null,
            dashRemainder = 0,
            dashOn = true,
            dashOnLength,
            dashOffLength;

          if (series.dashes.dashLength[0]) {
            dashOnLength = series.dashes.dashLength[0];
            if (series.dashes.dashLength[1]) {
              dashOffLength = series.dashes.dashLength[1];
            } else {
              dashOffLength = dashOnLength;
            }
          } else {
            dashOffLength = dashOnLength = series.dashes.dashLength;
          }

          ctx.beginPath();

          for (var i = ps; i < points.length; i += ps) {

            var x1 = points[i - ps],
              y1 = points[i - ps + 1],
              x2 = points[i],
              y2 = points[i + 1];

            if (x1 == null || x2 == null) continue;

            // clip with ymin
            if (y1 <= y2 && y1 < axisy.min) {
              if (y2 < axisy.min) continue;   // line segment is outside
              // compute new intersection point
              x1 = (axisy.min - y1) / (y2 - y1) * (x2 - x1) + x1;
              y1 = axisy.min;
            } else if (y2 <= y1 && y2 < axisy.min) {
              if (y1 < axisy.min) continue;
              x2 = (axisy.min - y1) / (y2 - y1) * (x2 - x1) + x1;
              y2 = axisy.min;
            }

            // clip with ymax
            if (y1 >= y2 && y1 > axisy.max) {
              if (y2 > axisy.max) continue;
              x1 = (axisy.max - y1) / (y2 - y1) * (x2 - x1) + x1;
              y1 = axisy.max;
            } else if (y2 >= y1 && y2 > axisy.max) {
              if (y1 > axisy.max) continue;
              x2 = (axisy.max - y1) / (y2 - y1) * (x2 - x1) + x1;
              y2 = axisy.max;
            }

            // clip with xmin
            if (x1 <= x2 && x1 < axisx.min) {
              if (x2 < axisx.min) continue;
              y1 = (axisx.min - x1) / (x2 - x1) * (y2 - y1) + y1;
              x1 = axisx.min;
            } else if (x2 <= x1 && x2 < axisx.min) {
              if (x1 < axisx.min) continue;
              y2 = (axisx.min - x1) / (x2 - x1) * (y2 - y1) + y1;
              x2 = axisx.min;
            }

            // clip with xmax
            if (x1 >= x2 && x1 > axisx.max) {
              if (x2 > axisx.max) continue;
              y1 = (axisx.max - x1) / (x2 - x1) * (y2 - y1) + y1;
              x1 = axisx.max;
            } else if (x2 >= x1 && x2 > axisx.max) {
              if (x1 > axisx.max) continue;
              y2 = (axisx.max - x1) / (x2 - x1) * (y2 - y1) + y1;
              x2 = axisx.max;
            }

            if (x1 != prevx || y1 != prevy) {
              ctx.moveTo(axisx.p2c(x1) + xoffset, axisy.p2c(y1) + yoffset);
            }

            var ax1 = axisx.p2c(x1) + xoffset,
              ay1 = axisy.p2c(y1) + yoffset,
              ax2 = axisx.p2c(x2) + xoffset,
              ay2 = axisy.p2c(y2) + yoffset,
              dashOffset;

            function lineSegmentOffset(segmentLength) {

              var c = Math.sqrt(Math.pow(ax2 - ax1, 2) + Math.pow(ay2 - ay1, 2));

              if (c <= segmentLength) {
                return {
                  deltaX: ax2 - ax1,
                  deltaY: ay2 - ay1,
                  distance: c,
                  remainder: segmentLength - c
                }
              } else {
                var xsign = ax2 > ax1 ? 1 : -1,
                  ysign = ay2 > ay1 ? 1 : -1;
                return {
                  deltaX: xsign * Math.sqrt(Math.pow(segmentLength, 2) / (1 + Math.pow((ay2 - ay1)/(ax2 - ax1), 2))),
                  deltaY: ysign * Math.sqrt(Math.pow(segmentLength, 2) - Math.pow(segmentLength, 2) / (1 + Math.pow((ay2 - ay1)/(ax2 - ax1), 2))),
                  distance: segmentLength,
                  remainder: 0
                };
              }
            }
            //-end lineSegmentOffset

            do {

              dashOffset = lineSegmentOffset(
                dashRemainder > 0 ? dashRemainder :
                  dashOn ? dashOnLength : dashOffLength);

              if (dashOffset.deltaX != 0 || dashOffset.deltaY != 0) {
                if (dashOn) {
                  ctx.lineTo(ax1 + dashOffset.deltaX, ay1 + dashOffset.deltaY);
                } else {
                  ctx.moveTo(ax1 + dashOffset.deltaX, ay1 + dashOffset.deltaY);
                }
              }

              dashOn = !dashOn;
              dashRemainder = dashOffset.remainder;
              ax1 += dashOffset.deltaX;
              ay1 += dashOffset.deltaY;

            } while (dashOffset.distance > 0);

            prevx = x2;
            prevy = y2;
          }

          ctx.stroke();
        }
        //-end plotDashes

        ctx.save();
        ctx.translate(plotOffset.left, plotOffset.top);
        ctx.lineJoin = 'round';

        var lw = series.dashes.lineWidth,
          sw = series.shadowSize;

        // FIXME: consider another form of shadow when filling is turned on
        if (lw > 0 && sw > 0) {
          // draw shadow as a thick and thin line with transparency
          ctx.lineWidth = sw;
          ctx.strokeStyle = "rgba(0,0,0,0.1)";
          // position shadow at angle from the mid of line
          var angle = Math.PI/18;
          plotDashes(Math.sin(angle) * (lw/2 + sw/2), Math.cos(angle) * (lw/2 + sw/2));
          ctx.lineWidth = sw/2;
          plotDashes(Math.sin(angle) * (lw/2 + sw/4), Math.cos(angle) * (lw/2 + sw/4));
        }

        ctx.lineWidth = lw;
        ctx.strokeStyle = series.color;

        if (lw > 0) {
          plotDashes(0, 0);
        }

        ctx.restore();

      });
      //-end draw hook

    });
    //-end processDatapoints hook

  }
  //-end init

  $.plot.plugins.push({
    init: init,
    options: {
      series: {
        dashes: {
          show: false,
          lineWidth: 2,
          dashLength: 10
        }
      }
    },
    name: 'dashes',
    version: '0.1'
  });

})(jQuery)


/***/ }),

/***/ 1341:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = getColorScale;
/* harmony export (immutable) */ __webpack_exports__["b"] = getOpacityScale;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_d3__ = __webpack_require__(470);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_d3_scale_chromatic__ = __webpack_require__(478);


function getColorScale(colorScheme, lightTheme, maxValue, minValue) {
    if (minValue === void 0) { minValue = 0; }
    var colorInterpolator = __WEBPACK_IMPORTED_MODULE_1_d3_scale_chromatic__[colorScheme.value];
    var colorScaleInverted = colorScheme.invert === 'always' ||
        (colorScheme.invert === 'dark' && !lightTheme);
    var start = colorScaleInverted ? maxValue : minValue;
    var end = colorScaleInverted ? minValue : maxValue;
    return __WEBPACK_IMPORTED_MODULE_0_d3__["scaleSequential"](colorInterpolator).domain([start, end]);
}
function getOpacityScale(options, maxValue, minValue) {
    if (minValue === void 0) { minValue = 0; }
    var legendOpacityScale;
    if (options.colorScale === 'linear') {
        legendOpacityScale = __WEBPACK_IMPORTED_MODULE_0_d3__["scaleLinear"]()
            .domain([minValue, maxValue])
            .range([0, 1]);
    }
    else if (options.colorScale === 'sqrt') {
        legendOpacityScale = __WEBPACK_IMPORTED_MODULE_0_d3__["scalePow"]().exponent(options.exponent)
            .domain([minValue, maxValue])
            .range([0, 1]);
    }
    return legendOpacityScale;
}


/***/ }),

/***/ 1342:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return transformers; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return transformDataToTable; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__core_utils_flatten__ = __webpack_require__(1328);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__core_time_series2__ = __webpack_require__(1309);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__core_table_model__ = __webpack_require__(1310);




var transformers = {};
transformers['timeseries_to_rows'] = {
    description: 'Time series to rows',
    getColumns: function () {
        return [];
    },
    transform: function (data, panel, model) {
        model.columns = [
            { text: 'Time', type: 'date' },
            { text: 'Metric' },
            { text: 'Value' },
        ];
        for (var i = 0; i < data.length; i++) {
            var series = data[i];
            for (var y = 0; y < series.datapoints.length; y++) {
                var dp = series.datapoints[y];
                model.rows.push([dp[1], series.target, dp[0]]);
            }
        }
    },
};
transformers['timeseries_to_columns'] = {
    description: 'Time series to columns',
    getColumns: function () {
        return [];
    },
    transform: function (data, panel, model) {
        model.columns.push({ text: 'Time', type: 'date' });
        // group by time
        var points = {};
        for (var i = 0; i < data.length; i++) {
            var series = data[i];
            model.columns.push({ text: series.target });
            for (var y = 0; y < series.datapoints.length; y++) {
                var dp = series.datapoints[y];
                var timeKey = dp[1].toString();
                if (!points[timeKey]) {
                    points[timeKey] = { time: dp[1] };
                    points[timeKey][i] = dp[0];
                }
                else {
                    points[timeKey][i] = dp[0];
                }
            }
        }
        for (var time in points) {
            var point = points[time];
            var values = [point.time];
            for (var i = 0; i < data.length; i++) {
                var value = point[i];
                values.push(value);
            }
            model.rows.push(values);
        }
    }
};
transformers['timeseries_aggregations'] = {
    description: 'Time series aggregations',
    getColumns: function () {
        return [
            { text: 'Avg', value: 'avg' },
            { text: 'Min', value: 'min' },
            { text: 'Max', value: 'max' },
            { text: 'Total', value: 'total' },
            { text: 'Current', value: 'current' },
            { text: 'Count', value: 'count' },
        ];
    },
    transform: function (data, panel, model) {
        var i, y;
        model.columns.push({ text: 'Metric' });
        for (i = 0; i < panel.columns.length; i++) {
            model.columns.push({ text: panel.columns[i].text });
        }
        for (i = 0; i < data.length; i++) {
            var series = new __WEBPACK_IMPORTED_MODULE_2__core_time_series2__["a" /* default */]({
                datapoints: data[i].datapoints,
                alias: data[i].target,
            });
            series.getFlotPairs('connected');
            var cells = [series.alias];
            for (y = 0; y < panel.columns.length; y++) {
                cells.push(series.stats[panel.columns[y].value]);
            }
            model.rows.push(cells);
        }
    }
};
transformers['annotations'] = {
    description: 'Annotations',
    getColumns: function () {
        return [];
    },
    transform: function (data, panel, model) {
        model.columns.push({ text: 'Time', type: 'date' });
        model.columns.push({ text: 'Title' });
        model.columns.push({ text: 'Text' });
        model.columns.push({ text: 'Tags' });
        if (!data || !data.annotations || data.annotations.length === 0) {
            return;
        }
        for (var i = 0; i < data.annotations.length; i++) {
            var evt = data.annotations[i];
            model.rows.push([evt.min, evt.title, evt.text, evt.tags]);
        }
    }
};
transformers['table'] = {
    description: 'Table',
    getColumns: function (data) {
        if (!data || data.length === 0) {
            return [];
        }
        return data[0].columns;
    },
    transform: function (data, panel, model) {
        if (!data || data.length === 0) {
            return;
        }
        if (data[0].type !== 'table') {
            throw { message: 'Query result is not in table format, try using another transform.' };
        }
        model.columns = data[0].columns;
        model.rows = data[0].rows;
    }
};
transformers['json'] = {
    description: 'JSON Data',
    getColumns: function (data) {
        if (!data || data.length === 0) {
            return [];
        }
        var names = {};
        for (var i = 0; i < data.length; i++) {
            var series = data[i];
            if (series.type !== 'docs') {
                continue;
            }
            // only look at 100 docs
            var maxDocs = Math.min(series.datapoints.length, 100);
            for (var y = 0; y < maxDocs; y++) {
                var doc = series.datapoints[y];
                var flattened = Object(__WEBPACK_IMPORTED_MODULE_1__core_utils_flatten__["default"])(doc, null);
                for (var propName in flattened) {
                    names[propName] = true;
                }
            }
        }
        return __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.map(names, function (value, key) {
            return { text: key, value: key };
        });
    },
    transform: function (data, panel, model) {
        var i, y, z;
        for (var _i = 0, _a = panel.columns; _i < _a.length; _i++) {
            var column = _a[_i];
            var tableCol = { text: column.text };
            // if filterable data then set columns to filterable
            if (data.length > 0 && data[0].filterable) {
                tableCol.filterable = true;
            }
            model.columns.push(tableCol);
        }
        if (model.columns.length === 0) {
            model.columns.push({ text: 'JSON' });
        }
        for (i = 0; i < data.length; i++) {
            var series = data[i];
            for (y = 0; y < series.datapoints.length; y++) {
                var dp = series.datapoints[y];
                var values = [];
                if (__WEBPACK_IMPORTED_MODULE_0_lodash___default.a.isObject(dp) && panel.columns.length > 0) {
                    var flattened = Object(__WEBPACK_IMPORTED_MODULE_1__core_utils_flatten__["default"])(dp, null);
                    for (z = 0; z < panel.columns.length; z++) {
                        values.push(flattened[panel.columns[z].value]);
                    }
                }
                else {
                    values.push(JSON.stringify(dp));
                }
                model.rows.push(values);
            }
        }
    }
};
function transformDataToTable(data, panel) {
    var model = new __WEBPACK_IMPORTED_MODULE_3__core_table_model__["default"]();
    if (!data || data.length === 0) {
        return model;
    }
    var transformer = transformers[panel.transform];
    if (!transformer) {
        throw { message: 'Transformer ' + panel.transform + ' not found' };
    }
    transformer.transform(data, panel, model);
    return model;
}



/***/ }),

/***/ 1343:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

exports.isArrayLike = (function (x) { return x && typeof x.length === 'number'; });
//# sourceMappingURL=isArrayLike.js.map

/***/ }),

/***/ 1344:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function isPromise(value) {
    return value && typeof value.subscribe !== 'function' && typeof value.then === 'function';
}
exports.isPromise = isPromise;
//# sourceMappingURL=isPromise.js.map

/***/ }),

/***/ 1345:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Observable_1 = __webpack_require__(466);
var ScalarObservable_1 = __webpack_require__(1346);
var EmptyObservable_1 = __webpack_require__(1319);
var isScheduler_1 = __webpack_require__(1525);
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var ArrayObservable = (function (_super) {
    __extends(ArrayObservable, _super);
    function ArrayObservable(array, scheduler) {
        _super.call(this);
        this.array = array;
        this.scheduler = scheduler;
        if (!scheduler && array.length === 1) {
            this._isScalar = true;
            this.value = array[0];
        }
    }
    ArrayObservable.create = function (array, scheduler) {
        return new ArrayObservable(array, scheduler);
    };
    /**
     * Creates an Observable that emits some values you specify as arguments,
     * immediately one after the other, and then emits a complete notification.
     *
     * <span class="informal">Emits the arguments you provide, then completes.
     * </span>
     *
     * <img src="./img/of.png" width="100%">
     *
     * This static operator is useful for creating a simple Observable that only
     * emits the arguments given, and the complete notification thereafter. It can
     * be used for composing with other Observables, such as with {@link concat}.
     * By default, it uses a `null` IScheduler, which means the `next`
     * notifications are sent synchronously, although with a different IScheduler
     * it is possible to determine when those notifications will be delivered.
     *
     * @example <caption>Emit 10, 20, 30, then 'a', 'b', 'c', then start ticking every second.</caption>
     * var numbers = Rx.Observable.of(10, 20, 30);
     * var letters = Rx.Observable.of('a', 'b', 'c');
     * var interval = Rx.Observable.interval(1000);
     * var result = numbers.concat(letters).concat(interval);
     * result.subscribe(x => console.log(x));
     *
     * @see {@link create}
     * @see {@link empty}
     * @see {@link never}
     * @see {@link throw}
     *
     * @param {...T} values Arguments that represent `next` values to be emitted.
     * @param {Scheduler} [scheduler] A {@link IScheduler} to use for scheduling
     * the emissions of the `next` notifications.
     * @return {Observable<T>} An Observable that emits each given input value.
     * @static true
     * @name of
     * @owner Observable
     */
    ArrayObservable.of = function () {
        var array = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            array[_i - 0] = arguments[_i];
        }
        var scheduler = array[array.length - 1];
        if (isScheduler_1.isScheduler(scheduler)) {
            array.pop();
        }
        else {
            scheduler = null;
        }
        var len = array.length;
        if (len > 1) {
            return new ArrayObservable(array, scheduler);
        }
        else if (len === 1) {
            return new ScalarObservable_1.ScalarObservable(array[0], scheduler);
        }
        else {
            return new EmptyObservable_1.EmptyObservable(scheduler);
        }
    };
    ArrayObservable.dispatch = function (state) {
        var array = state.array, index = state.index, count = state.count, subscriber = state.subscriber;
        if (index >= count) {
            subscriber.complete();
            return;
        }
        subscriber.next(array[index]);
        if (subscriber.closed) {
            return;
        }
        state.index = index + 1;
        this.schedule(state);
    };
    ArrayObservable.prototype._subscribe = function (subscriber) {
        var index = 0;
        var array = this.array;
        var count = array.length;
        var scheduler = this.scheduler;
        if (scheduler) {
            return scheduler.schedule(ArrayObservable.dispatch, 0, {
                array: array, index: index, count: count, subscriber: subscriber
            });
        }
        else {
            for (var i = 0; i < count && !subscriber.closed; i++) {
                subscriber.next(array[i]);
            }
            subscriber.complete();
        }
    };
    return ArrayObservable;
}(Observable_1.Observable));
exports.ArrayObservable = ArrayObservable;
//# sourceMappingURL=ArrayObservable.js.map

/***/ }),

/***/ 1346:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Observable_1 = __webpack_require__(466);
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var ScalarObservable = (function (_super) {
    __extends(ScalarObservable, _super);
    function ScalarObservable(value, scheduler) {
        _super.call(this);
        this.value = value;
        this.scheduler = scheduler;
        this._isScalar = true;
        if (scheduler) {
            this._isScalar = false;
        }
    }
    ScalarObservable.create = function (value, scheduler) {
        return new ScalarObservable(value, scheduler);
    };
    ScalarObservable.dispatch = function (state) {
        var done = state.done, value = state.value, subscriber = state.subscriber;
        if (done) {
            subscriber.complete();
            return;
        }
        subscriber.next(value);
        if (subscriber.closed) {
            return;
        }
        state.done = true;
        this.schedule(state);
    };
    ScalarObservable.prototype._subscribe = function (subscriber) {
        var value = this.value;
        var scheduler = this.scheduler;
        if (scheduler) {
            return scheduler.schedule(ScalarObservable.dispatch, 0, {
                done: false, value: value, subscriber: subscriber
            });
        }
        else {
            subscriber.next(value);
            if (!subscriber.closed) {
                subscriber.complete();
            }
        }
    };
    return ScalarObservable;
}(Observable_1.Observable));
exports.ScalarObservable = ScalarObservable;
//# sourceMappingURL=ScalarObservable.js.map

/***/ }),

/***/ 1362:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
  __webpack_require__(1364),
  __webpack_require__(1378),
  __webpack_require__(1365),
  __webpack_require__(1367),
  __webpack_require__(1368),
  __webpack_require__(1369),
  __webpack_require__(1370),
  __webpack_require__(1371),
  __webpack_require__(1372),
  __webpack_require__(1373),
  __webpack_require__(1374),
  __webpack_require__(1377),
  __webpack_require__(1363),
  __webpack_require__(1379),
  __webpack_require__(1380),
  __webpack_require__(1381),
  __webpack_require__(1312),
  __webpack_require__(1383),
  __webpack_require__(1384),
  __webpack_require__(1385),
  __webpack_require__(1388),
  __webpack_require__(1389),
  __webpack_require__(1390),
  __webpack_require__(1393),
], __WEBPACK_AMD_DEFINE_RESULT__ = function () {}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ 1363:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_moment__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_moment___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_moment__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_lodash__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_app_core_core_module__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_app_core_utils_kbn__ = __webpack_require__(464);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_app_core_utils_datemath__ = __webpack_require__(467);
///<reference path="../../headers/common.d.ts" />





var TimeSrv = /** @class */ (function () {
    /** @ngInject **/
    TimeSrv.$inject = ["$rootScope", "$timeout", "$location", "timer", "contextSrv"];
    function TimeSrv($rootScope, $timeout, $location, timer, contextSrv) {
        var _this = this;
        this.$rootScope = $rootScope;
        this.$timeout = $timeout;
        this.$location = $location;
        this.timer = timer;
        this.contextSrv = contextSrv;
        // default time
        this.time = { from: '6h', to: 'now' };
        $rootScope.$on('zoom-out', this.zoomOut.bind(this));
        $rootScope.$on('$routeUpdate', this.routeUpdated.bind(this));
        document.addEventListener('visibilitychange', function () {
            if (_this.autoRefreshBlocked && document.visibilityState === 'visible') {
                _this.autoRefreshBlocked = false;
                _this.refreshDashboard();
            }
        });
    }
    TimeSrv.prototype.init = function (dashboard) {
        this.timer.cancelAll();
        this.dashboard = dashboard;
        this.time = dashboard.time;
        this.refresh = dashboard.refresh;
        this.initTimeFromUrl();
        this.parseTime();
        // remember time at load so we can go back to it
        this.timeAtLoad = __WEBPACK_IMPORTED_MODULE_1_lodash___default.a.cloneDeep(this.time);
        if (this.refresh) {
            this.setAutoRefresh(this.refresh);
        }
    };
    TimeSrv.prototype.parseTime = function () {
        // when absolute time is saved in json it is turned to a string
        if (__WEBPACK_IMPORTED_MODULE_1_lodash___default.a.isString(this.time.from) && this.time.from.indexOf('Z') >= 0) {
            this.time.from = __WEBPACK_IMPORTED_MODULE_0_moment___default()(this.time.from).utc();
        }
        if (__WEBPACK_IMPORTED_MODULE_1_lodash___default.a.isString(this.time.to) && this.time.to.indexOf('Z') >= 0) {
            this.time.to = __WEBPACK_IMPORTED_MODULE_0_moment___default()(this.time.to).utc();
        }
    };
    TimeSrv.prototype.parseUrlParam = function (value) {
        if (value.indexOf('now') !== -1) {
            return value;
        }
        if (value.length === 8) {
            return __WEBPACK_IMPORTED_MODULE_0_moment___default.a.utc(value, 'YYYYMMDD');
        }
        if (value.length === 15) {
            return __WEBPACK_IMPORTED_MODULE_0_moment___default.a.utc(value, 'YYYYMMDDTHHmmss');
        }
        if (!isNaN(value)) {
            var epoch = parseInt(value);
            return __WEBPACK_IMPORTED_MODULE_0_moment___default.a.utc(epoch);
        }
        return null;
    };
    TimeSrv.prototype.initTimeFromUrl = function () {
        var params = this.$location.search();
        if (params.from) {
            this.time.from = this.parseUrlParam(params.from) || this.time.from;
        }
        if (params.to) {
            this.time.to = this.parseUrlParam(params.to) || this.time.to;
        }
        if (params.refresh) {
            this.refresh = params.refresh || this.refresh;
        }
    };
    TimeSrv.prototype.routeUpdated = function () {
        var params = this.$location.search();
        var urlRange = this.timeRangeForUrl();
        // check if url has time range
        if (params.from && params.to) {
            // is it different from what our current time range?
            if (params.from !== urlRange.from || params.to !== urlRange.to) {
                // issue update
                this.initTimeFromUrl();
                this.setTime(this.time, true);
            }
        }
        else if (this.timeHasChangedSinceLoad()) {
            this.setTime(this.timeAtLoad, true);
        }
    };
    TimeSrv.prototype.timeHasChangedSinceLoad = function () {
        return this.timeAtLoad.from !== this.time.from || this.timeAtLoad.to !== this.time.to;
    };
    TimeSrv.prototype.setAutoRefresh = function (interval) {
        var _this = this;
        this.dashboard.refresh = interval;
        this.cancelNextRefresh();
        if (interval) {
            var intervalMs = __WEBPACK_IMPORTED_MODULE_3_app_core_utils_kbn__["default"].interval_to_ms(interval);
            this.refreshTimer = this.timer.register(this.$timeout(function () {
                _this.startNextRefreshTimer(intervalMs);
                _this.refreshDashboard();
            }, intervalMs));
        }
        // update url
        var params = this.$location.search();
        if (interval) {
            params.refresh = interval;
            this.$location.search(params);
        }
        else if (params.refresh) {
            delete params.refresh;
            this.$location.search(params);
        }
    };
    TimeSrv.prototype.refreshDashboard = function () {
        this.$rootScope.$broadcast('refresh');
    };
    TimeSrv.prototype.startNextRefreshTimer = function (afterMs) {
        var _this = this;
        this.cancelNextRefresh();
        this.refreshTimer = this.timer.register(this.$timeout(function () {
            _this.startNextRefreshTimer(afterMs);
            if (_this.contextSrv.isGrafanaVisible()) {
                _this.refreshDashboard();
            }
            else {
                _this.autoRefreshBlocked = true;
            }
        }, afterMs));
    };
    TimeSrv.prototype.cancelNextRefresh = function () {
        this.timer.cancel(this.refreshTimer);
    };
    TimeSrv.prototype.setTime = function (time, fromRouteUpdate) {
        __WEBPACK_IMPORTED_MODULE_1_lodash___default.a.extend(this.time, time);
        // disable refresh if zoom in or zoom out
        if (__WEBPACK_IMPORTED_MODULE_0_moment___default.a.isMoment(time.to)) {
            this.oldRefresh = this.dashboard.refresh || this.oldRefresh;
            this.setAutoRefresh(false);
        }
        else if (this.oldRefresh && this.oldRefresh !== this.dashboard.refresh) {
            this.setAutoRefresh(this.oldRefresh);
            this.oldRefresh = null;
        }
        // update url
        if (fromRouteUpdate !== true) {
            var urlRange = this.timeRangeForUrl();
            var urlParams = this.$location.search();
            urlParams.from = urlRange.from;
            urlParams.to = urlRange.to;
            this.$location.search(urlParams);
        }
        this.$rootScope.appEvent('time-range-changed', this.time);
        this.$timeout(this.refreshDashboard.bind(this), 0);
    };
    TimeSrv.prototype.timeRangeForUrl = function () {
        var range = this.timeRange().raw;
        if (__WEBPACK_IMPORTED_MODULE_0_moment___default.a.isMoment(range.from)) {
            range.from = range.from.valueOf().toString();
        }
        if (__WEBPACK_IMPORTED_MODULE_0_moment___default.a.isMoment(range.to)) {
            range.to = range.to.valueOf().toString();
        }
        return range;
    };
    TimeSrv.prototype.timeRange = function () {
        // make copies if they are moment  (do not want to return out internal moment, because they are mutable!)
        var raw = {
            from: __WEBPACK_IMPORTED_MODULE_0_moment___default.a.isMoment(this.time.from) ? __WEBPACK_IMPORTED_MODULE_0_moment___default()(this.time.from) : this.time.from,
            to: __WEBPACK_IMPORTED_MODULE_0_moment___default.a.isMoment(this.time.to) ? __WEBPACK_IMPORTED_MODULE_0_moment___default()(this.time.to) : this.time.to,
        };
        var timezone = this.dashboard && this.dashboard.getTimezone();
        return {
            from: __WEBPACK_IMPORTED_MODULE_4_app_core_utils_datemath__["parse"](raw.from, false, timezone),
            to: __WEBPACK_IMPORTED_MODULE_4_app_core_utils_datemath__["parse"](raw.to, true, timezone),
            raw: raw
        };
    };
    TimeSrv.prototype.zoomOut = function (e, factor) {
        var range = this.timeRange();
        var timespan = (range.to.valueOf() - range.from.valueOf());
        var center = range.to.valueOf() - timespan / 2;
        var to = (center + (timespan * factor) / 2);
        var from = (center - (timespan * factor) / 2);
        if (to > Date.now() && range.to <= Date.now()) {
            var offset = to - Date.now();
            from = from - offset;
            to = Date.now();
        }
        this.setTime({ from: __WEBPACK_IMPORTED_MODULE_0_moment___default.a.utc(from), to: __WEBPACK_IMPORTED_MODULE_0_moment___default.a.utc(to) });
    };
    return TimeSrv;
}());
__WEBPACK_IMPORTED_MODULE_2_app_core_core_module__["default"].service('timeSrv', TimeSrv);


/***/ }),

/***/ 1364:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DashboardCtrl", function() { return DashboardCtrl; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_app_core_config__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_angular__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_angular___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_angular__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_app_core_core_module__ = __webpack_require__(2);
///<reference path="../../headers/common.d.ts" />



var DashboardCtrl = /** @class */ (function () {
    /** @ngInject */
    DashboardCtrl.$inject = ["$scope", "$rootScope", "keybindingSrv", "timeSrv", "variableSrv", "alertingSrv", "dashboardSrv", "unsavedChangesSrv", "dynamicDashboardSrv", "dashboardViewStateSrv", "contextSrv", "playlistSrv", "alertSrv", "$timeout"];
    function DashboardCtrl($scope, $rootScope, keybindingSrv, timeSrv, variableSrv, alertingSrv, dashboardSrv, unsavedChangesSrv, dynamicDashboardSrv, dashboardViewStateSrv, contextSrv, playlistSrv, alertSrv, $timeout) {
        this.$scope = $scope;
        $scope.editor = { index: 0 };
        $scope.playlistSrv = playlistSrv;
        var resizeEventTimeout;
        $scope.setupDashboard = function (data) {
            try {
                $scope.setupDashboardInternal(data);
            }
            catch (err) {
                $scope.onInitFailed(err, 'Dashboard init failed', true);
            }
        };
        $scope.setupDashboardInternal = function (data) {
            var dashboard = dashboardSrv.create(data.dashboard, data.meta);
            dashboardSrv.setCurrent(dashboard);
            // init services
            timeSrv.init(dashboard);
            alertingSrv.init(dashboard, data.alerts);
            // template values service needs to initialize completely before
            // the rest of the dashboard can load
            variableSrv.init(dashboard)
                .catch($scope.onInitFailed.bind(this, 'Templating init failed', false))
                .finally(function () {
                dynamicDashboardSrv.init(dashboard);
                dynamicDashboardSrv.process();
                unsavedChangesSrv.init(dashboard, $scope);
                $scope.dashboard = dashboard;
                $scope.dashboardMeta = dashboard.meta;
                $scope.dashboardViewState = dashboardViewStateSrv.create($scope);
                keybindingSrv.setupDashboardBindings($scope, dashboard);
                $scope.dashboard.updateSubmenuVisibility();
                $scope.setWindowTitleAndTheme();
                $scope.appEvent("dashboard-initialized", $scope.dashboard);
            })
                .catch($scope.onInitFailed.bind(this, 'Dashboard init failed', true));
        };
        $scope.onInitFailed = function (msg, fatal, err) {
            console.log(msg, err);
            if (err.data && err.data.message) {
                err.message = err.data.message;
            }
            else if (!err.message) {
                err = { message: err.toString() };
            }
            $scope.appEvent("alert-error", [msg, err.message]);
            // protect against  recursive fallbacks
            if (fatal && !$scope.loadedFallbackDashboard) {
                $scope.loadedFallbackDashboard = true;
                $scope.setupDashboard({ dashboard: { title: 'Dashboard Init failed' } });
            }
        };
        $scope.templateVariableUpdated = function () {
            dynamicDashboardSrv.process();
        };
        $scope.setWindowTitleAndTheme = function () {
            window.document.title = __WEBPACK_IMPORTED_MODULE_0_app_core_config__["default"].window_title_prefix + $scope.dashboard.title;
        };
        $scope.broadcastRefresh = function () {
            $rootScope.$broadcast('refresh');
        };
        $scope.addRowDefault = function () {
            $scope.dashboard.addEmptyRow();
        };
        $scope.showJsonEditor = function (evt, options) {
            var editScope = $rootScope.$new();
            editScope.object = options.object;
            editScope.updateHandler = options.updateHandler;
            $scope.appEvent('show-dash-editor', { src: 'public/app/partials/edit_json.html', scope: editScope });
        };
        $scope.registerWindowResizeEvent = function () {
            __WEBPACK_IMPORTED_MODULE_1_angular___default.a.element(window).bind('resize', function () {
                $timeout.cancel(resizeEventTimeout);
                resizeEventTimeout = $timeout(function () { $scope.$broadcast('render'); }, 200);
            });
            $scope.$on('$destroy', function () {
                __WEBPACK_IMPORTED_MODULE_1_angular___default.a.element(window).unbind('resize');
                $scope.dashboard.destroy();
            });
        };
        $scope.timezoneChanged = function () {
            $rootScope.$broadcast("refresh");
        };
    }
    DashboardCtrl.prototype.init = function (dashboard) {
        this.$scope.onAppEvent('show-json-editor', this.$scope.showJsonEditor);
        this.$scope.onAppEvent('template-variable-value-updated', this.$scope.templateVariableUpdated);
        this.$scope.setupDashboard(dashboard);
        this.$scope.registerWindowResizeEvent();
    };
    return DashboardCtrl;
}());

__WEBPACK_IMPORTED_MODULE_2_app_core_core_module__["default"].controller('DashboardCtrl', DashboardCtrl);


/***/ }),

/***/ 1365:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HistoryListCtrl", function() { return HistoryListCtrl; });
/* harmony export (immutable) */ __webpack_exports__["dashboardHistoryDirective"] = dashboardHistoryDirective;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__history_srv__ = __webpack_require__(1366);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_lodash__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_angular__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_angular___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_angular__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_moment__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_moment___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_moment__);
///<reference path="../../../headers/common.d.ts" />




var HistoryListCtrl = /** @class */ (function () {
    /** @ngInject */
    HistoryListCtrl.$inject = ["$route", "$rootScope", "$location", "$q", "historySrv", "$scope"];
    function HistoryListCtrl($route, $rootScope, $location, $q, historySrv, $scope) {
        this.$route = $route;
        this.$rootScope = $rootScope;
        this.$location = $location;
        this.$q = $q;
        this.historySrv = historySrv;
        this.$scope = $scope;
        this.appending = false;
        this.diff = 'basic';
        this.limit = 10;
        this.loading = false;
        this.max = 2;
        this.mode = 'list';
        this.start = 0;
        this.canCompare = false;
        this.$rootScope.onAppEvent('dashboard-saved', this.onDashboardSaved.bind(this), $scope);
        this.resetFromSource();
    }
    HistoryListCtrl.prototype.onDashboardSaved = function () {
        this.resetFromSource();
    };
    HistoryListCtrl.prototype.switchMode = function (mode) {
        this.mode = mode;
        if (this.mode === 'list') {
            this.reset();
        }
    };
    HistoryListCtrl.prototype.dismiss = function () {
        this.$rootScope.appEvent('hide-dash-editor');
    };
    HistoryListCtrl.prototype.addToLog = function () {
        this.start = this.start + this.limit;
        this.getLog(true);
    };
    HistoryListCtrl.prototype.revisionSelectionChanged = function () {
        var selected = __WEBPACK_IMPORTED_MODULE_1_lodash___default.a.filter(this.revisions, { checked: true }).length;
        this.canCompare = selected === 2;
    };
    HistoryListCtrl.prototype.formatDate = function (date) {
        return this.dashboard.formatDate(date);
    };
    HistoryListCtrl.prototype.formatBasicDate = function (date) {
        var now = this.dashboard.timezone === 'browser' ? __WEBPACK_IMPORTED_MODULE_3_moment___default()() : __WEBPACK_IMPORTED_MODULE_3_moment___default.a.utc();
        var then = this.dashboard.timezone === 'browser' ? __WEBPACK_IMPORTED_MODULE_3_moment___default()(date) : __WEBPACK_IMPORTED_MODULE_3_moment___default.a.utc(date);
        return then.from(now);
    };
    HistoryListCtrl.prototype.getDiff = function (diff) {
        var _this = this;
        this.diff = diff;
        this.mode = 'compare';
        // have it already been fetched?
        if (this.delta[this.diff]) {
            return this.$q.when(this.delta[this.diff]);
        }
        var selected = __WEBPACK_IMPORTED_MODULE_1_lodash___default.a.filter(this.revisions, { checked: true });
        this.newInfo = selected[0];
        this.baseInfo = selected[1];
        this.isNewLatest = this.newInfo.version === this.dashboard.version;
        this.loading = true;
        var options = {
            new: {
                dashboardId: this.dashboard.id,
                version: this.newInfo.version,
            },
            base: {
                dashboardId: this.dashboard.id,
                version: this.baseInfo.version,
            },
            diffType: diff,
        };
        return this.historySrv.calculateDiff(options).then(function (response) {
            _this.delta[_this.diff] = response;
        }).catch(function () {
            _this.mode = 'list';
        }).finally(function () {
            _this.loading = false;
        });
    };
    HistoryListCtrl.prototype.getLog = function (append) {
        var _this = this;
        if (append === void 0) { append = false; }
        this.loading = !append;
        this.appending = append;
        var options = {
            limit: this.limit,
            start: this.start,
        };
        return this.historySrv.getHistoryList(this.dashboard, options).then(function (revisions) {
            // set formated dates & default values
            for (var _i = 0, revisions_1 = revisions; _i < revisions_1.length; _i++) {
                var rev = revisions_1[_i];
                rev.createdDateString = _this.formatDate(rev.created);
                rev.ageString = _this.formatBasicDate(rev.created);
                rev.checked = false;
            }
            _this.revisions = append ? _this.revisions.concat(revisions) : revisions;
        }).catch(function (err) {
            _this.loading = false;
        }).finally(function () {
            _this.loading = false;
            _this.appending = false;
        });
    };
    HistoryListCtrl.prototype.isLastPage = function () {
        return __WEBPACK_IMPORTED_MODULE_1_lodash___default.a.find(this.revisions, function (rev) { return rev.version === 1; });
    };
    HistoryListCtrl.prototype.reset = function () {
        this.delta = { basic: '', json: '' };
        this.diff = 'basic';
        this.mode = 'list';
        this.revisions = __WEBPACK_IMPORTED_MODULE_1_lodash___default.a.map(this.revisions, function (rev) { return __WEBPACK_IMPORTED_MODULE_1_lodash___default.a.extend({}, rev, { checked: false }); });
        this.canCompare = false;
        this.start = 0;
        this.isNewLatest = false;
    };
    HistoryListCtrl.prototype.resetFromSource = function () {
        this.revisions = [];
        return this.getLog().then(this.reset.bind(this));
    };
    HistoryListCtrl.prototype.restore = function (version) {
        this.$rootScope.appEvent('confirm-modal', {
            title: 'Restore version',
            text: '',
            text2: "Are you sure you want to restore the dashboard to version " + version + "? All unsaved changes will be lost.",
            icon: 'fa-history',
            yesText: "Yes, restore to version " + version,
            onConfirm: this.restoreConfirm.bind(this, version),
        });
    };
    HistoryListCtrl.prototype.restoreConfirm = function (version) {
        var _this = this;
        this.loading = true;
        return this.historySrv.restoreDashboard(this.dashboard, version).then(function (response) {
            _this.$location.path('dashboard/db/' + response.slug);
            _this.$route.reload();
            _this.$rootScope.appEvent('alert-success', ['Dashboard restored', 'Restored from version ' + version]);
        }).catch(function () {
            _this.mode = 'list';
            _this.loading = false;
        });
    };
    return HistoryListCtrl;
}());

function dashboardHistoryDirective() {
    return {
        restrict: 'E',
        templateUrl: 'public/app/features/dashboard/history/history.html',
        controller: HistoryListCtrl,
        bindToController: true,
        controllerAs: 'ctrl',
        scope: {
            dashboard: "="
        }
    };
}
__WEBPACK_IMPORTED_MODULE_2_angular___default.a.module('grafana.directives').directive('gfDashboardHistory', dashboardHistoryDirective);


/***/ }),

/***/ 1366:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export HistorySrv */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_app_core_core_module__ = __webpack_require__(2);
///<reference path="../../../headers/common.d.ts" />


var HistorySrv = /** @class */ (function () {
    /** @ngInject */
    HistorySrv.$inject = ["backendSrv", "$q"];
    function HistorySrv(backendSrv, $q) {
        this.backendSrv = backendSrv;
        this.$q = $q;
    }
    HistorySrv.prototype.getHistoryList = function (dashboard, options) {
        var id = dashboard && dashboard.id ? dashboard.id : void 0;
        return id ? this.backendSrv.get("api/dashboards/id/" + id + "/versions", options) : this.$q.when([]);
    };
    HistorySrv.prototype.calculateDiff = function (options) {
        return this.backendSrv.post('api/dashboards/calculate-diff', options);
    };
    HistorySrv.prototype.restoreDashboard = function (dashboard, version) {
        var id = dashboard && dashboard.id ? dashboard.id : void 0;
        var url = "api/dashboards/id/" + id + "/restore";
        return id && __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.isNumber(version) ? this.backendSrv.post(url, { version: version }) : this.$q.when({});
    };
    return HistorySrv;
}());

__WEBPACK_IMPORTED_MODULE_1_app_core_core_module__["default"].service('historySrv', HistorySrv);


/***/ }),

/***/ 1367:
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
  __webpack_require__(12),
  __webpack_require__(1),
  __webpack_require__(7),
  __webpack_require__(13),
  __webpack_require__(464),
  __webpack_require__(467),
  __webpack_require__(1312)
], __WEBPACK_AMD_DEFINE_RESULT__ = function (angular, moment, _, $, kbn, dateMath, impressionStore) {
  'use strict';

  kbn = kbn.default;

  var module = angular.module('grafana.services');

  module.service('dashboardLoaderSrv', ["backendSrv", "dashboardSrv", "datasourceSrv", "$http", "$q", "$timeout", "contextSrv", "$routeParams", "$rootScope", function(backendSrv,
                                                   dashboardSrv,
                                                   datasourceSrv,
                                                   $http, $q, $timeout,
                                                   contextSrv, $routeParams,
                                                   $rootScope) {
    var self = this;

    this._dashboardLoadFailed = function(title, snapshot) {
      snapshot = snapshot || false;
      return {
        meta: { canStar: false, isSnapshot: snapshot, canDelete: false, canSave: false, canEdit: false, dashboardNotFound: true },
        dashboard: {title: title }
      };
    };

    this.loadDashboard = function(type, slug) {
      var promise;

      if (type === 'script') {
        promise = this._loadScriptedDashboard(slug);
      } else if (type === 'snapshot') {
        promise = backendSrv.get('/api/snapshots/' + $routeParams.slug)
          .catch(function() {
            return self._dashboardLoadFailed("Snapshot not found", true);
          });
      } else {
        promise = backendSrv.getDashboard($routeParams.type, $routeParams.slug)
          .catch(function() {
            return self._dashboardLoadFailed("Not found");
          });
      }

      promise.then(function(result) {

        if (result.meta.dashboardNotFound !== true) {
          impressionStore.impressions.addDashboardImpression(result.dashboard.id);
        }

        return result;
      });

      return promise;
    };

    this._loadScriptedDashboard = function(file) {
      var url = 'public/dashboards/'+file.replace(/\.(?!js)/,"/") + '?' + new Date().getTime();

      return $http({ url: url, method: "GET" })
      .then(this._executeScript).then(function(result) {
        return { meta: { fromScript: true, canDelete: false, canSave: false, canStar: false}, dashboard: result.data };
      }, function(err) {
        console.log('Script dashboard error '+ err);
        $rootScope.appEvent('alert-error', ["Script Error", "Please make sure it exists and returns a valid dashboard"]);
        return self._dashboardLoadFailed('Scripted dashboard');
      });
    };

    this._executeScript = function(result) {
      var services = {
        dashboardSrv: dashboardSrv,
        datasourceSrv: datasourceSrv,
        $q: $q,
      };

      /*jshint -W054 */
      var script_func = new Function('ARGS','kbn','dateMath','_','moment','window','document','$','jQuery', 'services', result.data);
      var script_result = script_func($routeParams, kbn, dateMath, _ , moment, window, document, $, $, services);

      // Handle async dashboard scripts
      if (_.isFunction(script_result)) {
        var deferred = $q.defer();
        script_result(function(dashboard) {
          $timeout(function() {
            deferred.resolve({ data: dashboard });
          });
        });
        return deferred.promise;
      }

      return { data: script_result };
    };

  }]);
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(201)(module)))

/***/ }),

/***/ 1368:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DashNavCtrl", function() { return DashNavCtrl; });
/* harmony export (immutable) */ __webpack_exports__["dashNavDirective"] = dashNavDirective;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_moment__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_moment___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_moment__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_angular__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_angular___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_angular__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_app_core_core__ = __webpack_require__(465);
///<reference path="../../../headers/common.d.ts" />




var DashNavCtrl = /** @class */ (function () {
    /** @ngInject */
    DashNavCtrl.$inject = ["$scope", "$rootScope", "dashboardSrv", "$location", "backendSrv", "contextSrv", "playlistSrv", "navModelSrv"];
    function DashNavCtrl($scope, $rootScope, dashboardSrv, $location, backendSrv, contextSrv, playlistSrv, navModelSrv) {
        this.$scope = $scope;
        this.$rootScope = $rootScope;
        this.dashboardSrv = dashboardSrv;
        this.$location = $location;
        this.backendSrv = backendSrv;
        this.contextSrv = contextSrv;
        this.playlistSrv = playlistSrv;
        this.navModel = navModelSrv.getDashboardNav(this.dashboard, this);
        __WEBPACK_IMPORTED_MODULE_3_app_core_core__["appEvents"].on('save-dashboard', this.saveDashboard.bind(this), $scope);
        __WEBPACK_IMPORTED_MODULE_3_app_core_core__["appEvents"].on('delete-dashboard', this.deleteDashboard.bind(this), $scope);
        if (this.dashboard.meta.isSnapshot) {
            var meta = this.dashboard.meta;
            this.titleTooltip = 'Created: &nbsp;' + __WEBPACK_IMPORTED_MODULE_1_moment___default()(meta.created).calendar();
            if (meta.expires) {
                this.titleTooltip += '<br>Expires: &nbsp;' + __WEBPACK_IMPORTED_MODULE_1_moment___default()(meta.expires).fromNow() + '<br>';
            }
        }
    }
    DashNavCtrl.prototype.toggleSideMenu = function () {
        this.contextSrv.toggleSideMenu();
    };
    DashNavCtrl.prototype.openEditView = function (editview) {
        var search = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.extend(this.$location.search(), { editview: editview });
        this.$location.search(search);
    };
    DashNavCtrl.prototype.showHelpModal = function () {
        __WEBPACK_IMPORTED_MODULE_3_app_core_core__["appEvents"].emit('show-modal', { templateHtml: '<help-modal></help-modal>' });
    };
    DashNavCtrl.prototype.starDashboard = function () {
        var _this = this;
        this.dashboardSrv.starDashboard(this.dashboard.id, this.dashboard.meta.isStarred)
            .then(function (newState) {
            _this.dashboard.meta.isStarred = newState;
        });
    };
    DashNavCtrl.prototype.shareDashboard = function (tabIndex) {
        var modalScope = this.$scope.$new();
        modalScope.tabIndex = tabIndex;
        modalScope.dashboard = this.dashboard;
        __WEBPACK_IMPORTED_MODULE_3_app_core_core__["appEvents"].emit('show-modal', {
            src: 'public/app/features/dashboard/partials/shareModal.html',
            scope: modalScope
        });
    };
    DashNavCtrl.prototype.hideTooltip = function (evt) {
        __WEBPACK_IMPORTED_MODULE_2_angular___default.a.element(evt.currentTarget).tooltip('hide');
    };
    DashNavCtrl.prototype.makeEditable = function () {
        this.dashboard.editable = true;
        return this.dashboardSrv.saveDashboard({ makeEditable: true, overwrite: false }).then(function () {
            // force refresh whole page
            window.location.href = window.location.href;
        });
    };
    DashNavCtrl.prototype.exitFullscreen = function () {
        this.$rootScope.appEvent('panel-change-view', { fullscreen: false, edit: false });
    };
    DashNavCtrl.prototype.saveDashboard = function () {
        return this.dashboardSrv.saveDashboard();
    };
    DashNavCtrl.prototype.deleteDashboard = function () {
        var _this = this;
        var confirmText = "";
        var text2 = this.dashboard.title;
        var alerts = this.dashboard.rows.reduce(function (memo, row) {
            memo += row.panels.filter(function (panel) { return panel.alert; }).length;
            return memo;
        }, 0);
        if (alerts > 0) {
            confirmText = 'DELETE';
            text2 = "This dashboad contains " + alerts + " alerts. Deleting this dashboad will also delete those alerts";
        }
        __WEBPACK_IMPORTED_MODULE_3_app_core_core__["appEvents"].emit('confirm-modal', {
            title: 'Delete',
            text: 'Do you want to delete this dashboard?',
            text2: text2,
            icon: 'fa-trash',
            confirmText: confirmText,
            yesText: 'Delete',
            onConfirm: function () {
                _this.dashboard.meta.canSave = false;
                _this.deleteDashboardConfirmed();
            }
        });
    };
    DashNavCtrl.prototype.deleteDashboardConfirmed = function () {
        var _this = this;
        this.backendSrv.delete('/api/dashboards/db/' + this.dashboard.meta.slug).then(function () {
            __WEBPACK_IMPORTED_MODULE_3_app_core_core__["appEvents"].emit('alert-success', ['Dashboard Deleted', _this.dashboard.title + ' has been deleted']);
            _this.$location.url('/');
        });
    };
    DashNavCtrl.prototype.saveDashboardAs = function () {
        return this.dashboardSrv.showSaveAsModal();
    };
    DashNavCtrl.prototype.viewJson = function () {
        var clone = this.dashboard.getSaveModelClone();
        this.$rootScope.appEvent('show-json-editor', {
            object: clone,
        });
    };
    DashNavCtrl.prototype.showSearch = function () {
        this.$rootScope.appEvent('show-dash-search');
    };
    DashNavCtrl.prototype.navItemClicked = function (navItem, evt) {
        if (navItem.clickHandler) {
            navItem.clickHandler();
            evt.preventDefault();
        }
    };
    return DashNavCtrl;
}());

function dashNavDirective() {
    return {
        restrict: 'E',
        templateUrl: 'public/app/features/dashboard/dashnav/dashnav.html',
        controller: DashNavCtrl,
        bindToController: true,
        controllerAs: 'ctrl',
        transclude: true,
        scope: { dashboard: "=" }
    };
}
__WEBPACK_IMPORTED_MODULE_2_angular___default.a.module('grafana.directives').directive('dashnav', dashNavDirective);


/***/ }),

/***/ 1369:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SubmenuCtrl", function() { return SubmenuCtrl; });
/* harmony export (immutable) */ __webpack_exports__["submenuDirective"] = submenuDirective;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_angular__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_angular___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_angular__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_lodash__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_lodash__);
///<reference path="../../../headers/common.d.ts" />


var SubmenuCtrl = /** @class */ (function () {
    /** @ngInject */
    SubmenuCtrl.$inject = ["$rootScope", "variableSrv", "$location"];
    function SubmenuCtrl($rootScope, variableSrv, $location) {
        this.$rootScope = $rootScope;
        this.variableSrv = variableSrv;
        this.$location = $location;
        this.annotations = this.dashboard.templating.list;
        this.variables = this.variableSrv.variables;
    }
    SubmenuCtrl.prototype.annotationStateChanged = function () {
        this.$rootScope.$broadcast('refresh');
    };
    SubmenuCtrl.prototype.variableUpdated = function (variable) {
        this.variableSrv.variableUpdated(variable, true);
    };
    SubmenuCtrl.prototype.openEditView = function (editview) {
        var search = __WEBPACK_IMPORTED_MODULE_1_lodash___default.a.extend(this.$location.search(), { editview: editview });
        this.$location.search(search);
    };
    return SubmenuCtrl;
}());

function submenuDirective() {
    return {
        restrict: 'E',
        templateUrl: 'public/app/features/dashboard/submenu/submenu.html',
        controller: SubmenuCtrl,
        bindToController: true,
        controllerAs: 'ctrl',
        scope: {
            dashboard: "=",
        }
    };
}
__WEBPACK_IMPORTED_MODULE_0_angular___default.a.module('grafana.directives').directive('dashboardSubmenu', submenuDirective);


/***/ }),

/***/ 1370:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SaveDashboardAsModalCtrl", function() { return SaveDashboardAsModalCtrl; });
/* harmony export (immutable) */ __webpack_exports__["saveDashboardAsDirective"] = saveDashboardAsDirective;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_app_core_core_module__ = __webpack_require__(2);
///<reference path="../../headers/common.d.ts" />

var template = "\n<div class=\"modal-body\">\n\t<div class=\"modal-header\">\n\t\t<h2 class=\"modal-header-title\">\n\t\t\t<i class=\"fa fa-copy\"></i>\n\t\t\t<span class=\"p-l-1\">Save As...</span>\n\t\t</h2>\n\n\t\t<a class=\"modal-header-close\" ng-click=\"ctrl.dismiss();\">\n\t\t\t<i class=\"fa fa-remove\"></i>\n\t\t</a>\n\t</div>\n\n\t<form name=\"ctrl.saveForm\" ng-submit=\"ctrl.save()\" class=\"modal-content\" novalidate>\n\t\t<div class=\"p-t-2\">\n\t\t\t<div class=\"gf-form\">\n\t\t\t\t<label class=\"gf-form-label\">New name</label>\n\t\t\t\t<input type=\"text\" class=\"gf-form-input\" ng-model=\"ctrl.clone.title\" give-focus=\"true\" required>\n\t\t\t</div>\n\t\t</div>\n\n\t\t<div class=\"gf-form-button-row text-center\">\n\t\t\t<button type=\"submit\" class=\"btn btn-success\" ng-disabled=\"ctrl.saveForm.$invalid\">Save</button>\n\t\t\t<a class=\"btn-text\" ng-click=\"ctrl.dismiss();\">Cancel</a>\n\t\t</div>\n\t</form>\n</div>\n";
var SaveDashboardAsModalCtrl = /** @class */ (function () {
    /** @ngInject */
    SaveDashboardAsModalCtrl.$inject = ["dashboardSrv"];
    function SaveDashboardAsModalCtrl(dashboardSrv) {
        this.dashboardSrv = dashboardSrv;
        var dashboard = this.dashboardSrv.getCurrent();
        this.clone = dashboard.getSaveModelClone();
        this.clone.id = null;
        this.clone.title += ' Copy';
        this.clone.editable = true;
        this.clone.hideControls = false;
        // remove alerts if source dashboard is already persisted
        // do not want to create alert dupes
        if (dashboard.id > 0) {
            this.clone.rows.forEach(function (row) {
                row.panels.forEach(function (panel) {
                    if (panel.type === "graph" && panel.alert) {
                        delete panel.thresholds;
                    }
                    delete panel.alert;
                });
            });
        }
        delete this.clone.autoUpdate;
    }
    SaveDashboardAsModalCtrl.prototype.save = function () {
        return this.dashboardSrv.save(this.clone).then(this.dismiss);
    };
    SaveDashboardAsModalCtrl.prototype.keyDown = function (evt) {
        if (evt.keyCode === 13) {
            this.save();
        }
    };
    return SaveDashboardAsModalCtrl;
}());

function saveDashboardAsDirective() {
    return {
        restrict: 'E',
        template: template,
        controller: SaveDashboardAsModalCtrl,
        bindToController: true,
        controllerAs: 'ctrl',
        scope: { dismiss: "&" }
    };
}
__WEBPACK_IMPORTED_MODULE_0_app_core_core_module__["default"].directive('saveDashboardAsModal', saveDashboardAsDirective);


/***/ }),

/***/ 1371:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SaveDashboardModalCtrl", function() { return SaveDashboardModalCtrl; });
/* harmony export (immutable) */ __webpack_exports__["saveDashboardModalDirective"] = saveDashboardModalDirective;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_app_core_core_module__ = __webpack_require__(2);
///<reference path="../../headers/common.d.ts" />

var template = "\n<div class=\"modal-body\">\n\t<div class=\"modal-header\">\n\t\t<h2 class=\"modal-header-title\">\n\t\t\t<i class=\"fa fa-save\"></i>\n\t\t\t<span class=\"p-l-1\">Save changes</span>\n\t\t</h2>\n\n\t\t<a class=\"modal-header-close\" ng-click=\"ctrl.dismiss();\">\n\t\t\t<i class=\"fa fa-remove\"></i>\n\t\t</a>\n\t</div>\n\n\t<form name=\"ctrl.saveForm\" ng-submit=\"ctrl.save()\" class=\"modal-content\" novalidate>\n\t\t<h6 class=\"text-center\">Add a note to describe your changes</h6>\n\t\t<div class=\"p-t-2\">\n\t\t\t<div class=\"gf-form\">\n\t\t\t\t<label class=\"gf-form-hint\">\n\t\t\t\t\t<input\n\t\t\t\t\t\ttype=\"text\"\n\t\t\t\t\t\tname=\"message\"\n\t\t\t\t\t\tclass=\"gf-form-input\"\n\t\t\t\t\t\tplaceholder=\"Updates to &hellip;\"\n\t\t\t\t\t\tgive-focus=\"true\"\n\t\t\t\t\t\tng-model=\"ctrl.message\"\n\t\t\t\t\t\tng-model-options=\"{allowInvalid: true}\"\n\t\t\t\t\t\tng-maxlength=\"this.max\"\n\t\t\t\t\t\tautocomplete=\"off\" />\n\t\t\t\t\t<small class=\"gf-form-hint-text muted\" ng-cloak>\n\t\t\t\t\t\t<span ng-class=\"{'text-error': ctrl.saveForm.message.$invalid && ctrl.saveForm.message.$dirty }\">\n\t\t\t\t\t\t\t{{ctrl.message.length || 0}}\n\t\t\t\t\t\t</span>\n\t\t\t\t\t\t/ {{ctrl.max}} characters\n\t\t\t\t\t</small>\n\t\t\t\t</label>\n\t\t\t</div>\n\t\t</div>\n\n\t\t<div class=\"gf-form-button-row text-center\">\n\t\t\t<button type=\"submit\" class=\"btn btn-success\" ng-disabled=\"ctrl.saveForm.$invalid\">Save</button>\n\t\t\t<button class=\"btn btn-inverse\" ng-click=\"ctrl.dismiss();\">Cancel</button>\n\t\t</div>\n\t</form>\n</div>\n";
var SaveDashboardModalCtrl = /** @class */ (function () {
    /** @ngInject */
    SaveDashboardModalCtrl.$inject = ["dashboardSrv"];
    function SaveDashboardModalCtrl(dashboardSrv) {
        this.dashboardSrv = dashboardSrv;
        this.message = '';
        this.max = 64;
    }
    SaveDashboardModalCtrl.prototype.save = function () {
        if (!this.saveForm.$valid) {
            return;
        }
        var dashboard = this.dashboardSrv.getCurrent();
        var saveModel = dashboard.getSaveModelClone();
        var options = { message: this.message };
        return this.dashboardSrv.save(saveModel, options).then(this.dismiss);
    };
    return SaveDashboardModalCtrl;
}());

function saveDashboardModalDirective() {
    return {
        restrict: 'E',
        template: template,
        controller: SaveDashboardModalCtrl,
        bindToController: true,
        controllerAs: 'ctrl',
        scope: { dismiss: "&" }
    };
}
__WEBPACK_IMPORTED_MODULE_0_app_core_core_module__["default"].directive('saveDashboardModal', saveDashboardModalDirective);


/***/ }),

/***/ 1372:
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(12),
  __webpack_require__(7),
  __webpack_require__(13),
  __webpack_require__(1),
  __webpack_require__(27),
], __WEBPACK_AMD_DEFINE_RESULT__ = function (angular, _, $, moment, config) {
  'use strict';

  config = config.default;

  var module = angular.module('grafana.controllers');

  module.controller('ShareModalCtrl', ["$scope", "$rootScope", "$location", "$timeout", "timeSrv", "templateSrv", "linkSrv", function($scope, $rootScope, $location, $timeout, timeSrv, templateSrv, linkSrv) {

    $scope.options = { forCurrent: true, includeTemplateVars: true, theme: 'current' };
    $scope.editor = { index: $scope.tabIndex || 0};

    $scope.init = function() {
      $scope.modeSharePanel = $scope.panel ? true : false;

      $scope.tabs = [{title: 'Link', src: 'shareLink.html'}];

      if ($scope.modeSharePanel) {
        $scope.modalTitle = 'Share Panel';
        $scope.tabs.push({title: 'Embed', src: 'shareEmbed.html'});
      } else {
        $scope.modalTitle = 'Share';
      }

      if (!$scope.dashboard.meta.isSnapshot) {
        $scope.tabs.push({title: 'Snapshot', src: 'shareSnapshot.html'});
      }

      if (!$scope.dashboard.meta.isSnapshot && !$scope.modeSharePanel) {
        $scope.tabs.push({title: 'Export', src: 'shareExport.html'});
      }

      $scope.buildUrl();
    };

    $scope.buildUrl = function() {
      var baseUrl = $location.absUrl();
      var queryStart = baseUrl.indexOf('?');

      if (queryStart !== -1) {
        baseUrl = baseUrl.substring(0, queryStart);
      }

      var params = angular.copy($location.search());

      var range = timeSrv.timeRange();
      params.from = range.from.valueOf();
      params.to = range.to.valueOf();
      params.orgId = config.bootData.user.orgId;

      if ($scope.options.includeTemplateVars) {
        templateSrv.fillVariableValuesForUrl(params);
      }

      if (!$scope.options.forCurrent) {
        delete params.from;
        delete params.to;
      }

      if ($scope.options.theme !== 'current') {
        params.theme = $scope.options.theme;
      }

      if ($scope.modeSharePanel) {
        params.panelId = $scope.panel.id;
        params.fullscreen = true;
      } else {
        delete params.panelId;
        delete params.fullscreen;
      }

      $scope.shareUrl = linkSrv.addParamsToUrl(baseUrl, params);

      var soloUrl = baseUrl.replace(config.appSubUrl + '/dashboard/', config.appSubUrl + '/dashboard-solo/');
      delete params.fullscreen;
      delete params.edit;
      soloUrl = linkSrv.addParamsToUrl(soloUrl, params);

      $scope.iframeHtml = '<iframe src="' + soloUrl + '" width="450" height="200" frameborder="0"></iframe>';

      $scope.imageUrl = soloUrl.replace(config.appSubUrl + '/dashboard-solo/', config.appSubUrl + '/render/dashboard-solo/');
      $scope.imageUrl += '&width=1000';
      $scope.imageUrl += '&height=500';
      $scope.imageUrl += '&tz=UTC' + encodeURIComponent(moment().format("Z"));
    };

    $scope.getShareUrl = function() {
      return $scope.shareUrl;
    };

  }]);

}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(201)(module)))

/***/ }),

/***/ 1373:
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
  __webpack_require__(12),
  __webpack_require__(7),
], __WEBPACK_AMD_DEFINE_RESULT__ = function (angular, _) {
  'use strict';

  var module = angular.module('grafana.controllers');

  module.controller('ShareSnapshotCtrl', ["$scope", "$rootScope", "$location", "backendSrv", "$timeout", "timeSrv", function($scope, $rootScope, $location, backendSrv, $timeout, timeSrv) {

    $scope.snapshot = {
      name: $scope.dashboard.title,
      expires: 0,
      timeoutSeconds: 4,
    };

    $scope.step = 1;

    $scope.expireOptions = [
      {text: '1 Hour', value: 60*60},
      {text: '1 Day',  value: 60*60*24},
      {text: '7 Days', value: 60*60*24*7},
      {text: 'Never',  value: 0},
    ];

    $scope.accessOptions = [
      {text: 'Anyone with the link', value: 1},
      {text: 'Organization users',  value: 2},
      {text: 'Public on the web', value: 3},
    ];

    $scope.init = function() {
      backendSrv.get('/api/snapshot/shared-options').then(function(options) {
        $scope.externalUrl = options['externalSnapshotURL'];
        $scope.sharingButtonText = options['externalSnapshotName'];
        $scope.externalEnabled = options['externalEnabled'];
      });
    };

    $scope.apiUrl = '/api/snapshots';

    $scope.createSnapshot = function(external) {
      $scope.dashboard.snapshot = {
        timestamp: new Date()
      };

      if (!external) {
        $scope.dashboard.snapshot.originalUrl = $location.absUrl();
      }

      $scope.loading = true;
      $scope.snapshot.external = external;

      $rootScope.$broadcast('refresh');

      $timeout(function() {
        $scope.saveSnapshot(external);
      }, $scope.snapshot.timeoutSeconds * 1000);
    };

    $scope.saveSnapshot = function(external) {
      var dash = $scope.dashboard.getSaveModelClone();
      $scope.scrubDashboard(dash);

      var cmdData = {
        dashboard: dash,
        name: dash.title,
        expires: $scope.snapshot.expires,
      };

      var postUrl = external ? $scope.externalUrl + $scope.apiUrl : $scope.apiUrl;

      backendSrv.post(postUrl, cmdData).then(function(results) {
        $scope.loading = false;

        if (external) {
          $scope.deleteUrl = results.deleteUrl;
          $scope.snapshotUrl = results.url;
          $scope.saveExternalSnapshotRef(cmdData, results);
        } else {
          var url = $location.url();
          var baseUrl = $location.absUrl();

          if (url !== '/') {
            baseUrl = baseUrl.replace(url, '') + '/';
          }

          $scope.snapshotUrl = baseUrl + 'dashboard/snapshot/' + results.key;
          $scope.deleteUrl = baseUrl + 'api/snapshots-delete/' + results.deleteKey;
        }

        $scope.step = 2;
      }, function() {
        $scope.loading = false;
      });
    };

    $scope.getSnapshotUrl = function() {
      return $scope.snapshotUrl;
    };

    $scope.scrubDashboard = function(dash) {
      // change title
      dash.title = $scope.snapshot.name;
      // make relative times absolute
      dash.time = timeSrv.timeRange();
      // remove panel queries & links
      dash.forEachPanel(function(panel) {
        panel.targets = [];
        panel.links = [];
        panel.datasource = null;
      });
      // remove annotation queries
      dash.annotations.list = _.chain(dash.annotations.list)
      .filter(function(annotation) {
        return annotation.enable;
      })
      .map(function(annotation) {
        return {
          name: annotation.name,
          enable: annotation.enable,
          iconColor: annotation.iconColor,
          snapshotData: annotation.snapshotData
        };
      }).value();
      // remove template queries
      _.each(dash.templating.list, function(variable) {
        variable.query = "";
        variable.options = variable.current;
        variable.refresh = false;
      });

      // snapshot single panel
      if ($scope.modeSharePanel) {
        var singlePanel = dash.getPanelById($scope.panel.id);
        singlePanel.span = 12;
        dash.rows = [{ height: '500px', span: 12, panels: [singlePanel] }];
      }

      // cleanup snapshotData
      delete $scope.dashboard.snapshot;
      $scope.dashboard.forEachPanel(function(panel) {
        delete panel.snapshotData;
      });
      _.each($scope.dashboard.annotations.list, function(annotation) {
        delete annotation.snapshotData;
      });
    };

    $scope.deleteSnapshot = function() {
      backendSrv.get($scope.deleteUrl).then(function() {
        $scope.step = 3;
      });
    };

    $scope.saveExternalSnapshotRef = function(cmdData, results) {
      // save external in local instance as well
      cmdData.external = true;
      cmdData.key = results.key;
      cmdData.deleteKey = results.deleteKey;
      backendSrv.post('/api/snapshots/', cmdData);
    };

  }]);

}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(201)(module)))

/***/ }),

/***/ 1374:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DashboardSrv", function() { return DashboardSrv; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_app_core_core_module__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__model__ = __webpack_require__(1375);
///<reference path="../../headers/common.d.ts" />


var DashboardSrv = /** @class */ (function () {
    /** @ngInject */
    DashboardSrv.$inject = ["backendSrv", "$rootScope", "$location"];
    function DashboardSrv(backendSrv, $rootScope, $location) {
        this.backendSrv = backendSrv;
        this.$rootScope = $rootScope;
        this.$location = $location;
    }
    DashboardSrv.prototype.create = function (dashboard, meta) {
        return new __WEBPACK_IMPORTED_MODULE_1__model__["a" /* DashboardModel */](dashboard, meta);
    };
    DashboardSrv.prototype.setCurrent = function (dashboard) {
        this.dash = dashboard;
    };
    DashboardSrv.prototype.getCurrent = function () {
        return this.dash;
    };
    DashboardSrv.prototype.handleSaveDashboardError = function (clone, err) {
        var _this = this;
        if (err.data && err.data.status === "version-mismatch") {
            err.isHandled = true;
            this.$rootScope.appEvent('confirm-modal', {
                title: 'Conflict',
                text: 'Someone else has updated this dashboard.',
                text2: 'Would you still like to save this dashboard?',
                yesText: "Save & Overwrite",
                icon: "fa-warning",
                onConfirm: function () {
                    _this.save(clone, { overwrite: true });
                }
            });
        }
        if (err.data && err.data.status === "name-exists") {
            err.isHandled = true;
            this.$rootScope.appEvent('confirm-modal', {
                title: 'Conflict',
                text: 'Dashboard with the same name exists.',
                text2: 'Would you still like to save this dashboard?',
                yesText: "Save & Overwrite",
                icon: "fa-warning",
                onConfirm: function () {
                    _this.save(clone, { overwrite: true });
                }
            });
        }
        if (err.data && err.data.status === "plugin-dashboard") {
            err.isHandled = true;
            this.$rootScope.appEvent('confirm-modal', {
                title: 'Plugin Dashboard',
                text: err.data.message,
                text2: 'Your changes will be lost when you update the plugin. Use Save As to create custom version.',
                yesText: "Overwrite",
                icon: "fa-warning",
                altActionText: "Save As",
                onAltAction: function () {
                    _this.showSaveAsModal();
                },
                onConfirm: function () {
                    _this.save(clone, { overwrite: true });
                }
            });
        }
    };
    DashboardSrv.prototype.postSave = function (clone, data) {
        this.dash.version = data.version;
        var dashboardUrl = '/dashboard/db/' + data.slug;
        if (dashboardUrl !== this.$location.path()) {
            this.$location.url(dashboardUrl);
        }
        this.$rootScope.appEvent('dashboard-saved', this.dash);
        this.$rootScope.appEvent('alert-success', ['Dashboard saved']);
    };
    DashboardSrv.prototype.save = function (clone, options) {
        return this.backendSrv.saveDashboard(clone, options)
            .then(this.postSave.bind(this, clone))
            .catch(this.handleSaveDashboardError.bind(this, clone));
    };
    DashboardSrv.prototype.saveDashboard = function (options, clone) {
        if (clone) {
            this.setCurrent(this.create(clone, this.dash.meta));
        }
        if (!this.dash.meta.canSave && options.makeEditable !== true) {
            return Promise.resolve();
        }
        if (this.dash.title === 'New dashboard') {
            return this.showSaveAsModal();
        }
        if (this.dash.version > 0) {
            return this.showSaveModal();
        }
        return this.save(this.dash.getSaveModelClone(), options);
    };
    DashboardSrv.prototype.showSaveAsModal = function () {
        var newScope = this.$rootScope.$new();
        newScope.clone = this.dash.getSaveModelClone();
        newScope.clone.editable = true;
        newScope.clone.hideControls = false;
        this.$rootScope.appEvent('show-modal', {
            templateHtml: '<save-dashboard-as-modal dismiss="dismiss()"></save-dashboard-as-modal>',
            scope: newScope,
            modalClass: 'modal--narrow'
        });
    };
    DashboardSrv.prototype.showSaveModal = function () {
        this.$rootScope.appEvent('show-modal', {
            templateHtml: '<save-dashboard-modal dismiss="dismiss()"></save-dashboard-modal>',
            scope: this.$rootScope.$new(),
            modalClass: 'modal--narrow'
        });
    };
    DashboardSrv.prototype.starDashboard = function (dashboardId, isStarred) {
        var _this = this;
        var promise;
        if (isStarred) {
            promise = this.backendSrv.delete('/api/user/stars/dashboard/' + dashboardId).then(function () {
                return false;
            });
        }
        else {
            promise = this.backendSrv.post('/api/user/stars/dashboard/' + dashboardId).then(function () {
                return true;
            });
        }
        return promise.then(function (res) {
            if (_this.dash && _this.dash.id === dashboardId) {
                _this.dash.meta.isStarred = res;
            }
            return res;
        });
    };
    return DashboardSrv;
}());

__WEBPACK_IMPORTED_MODULE_0_app_core_core_module__["default"].service('dashboardSrv', DashboardSrv);


/***/ }),

/***/ 1375:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return DashboardModel; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_angular__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_angular___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_angular__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_moment__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_moment___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_moment__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_lodash__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_jquery__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_jquery___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_jquery__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_app_core_utils_colors__ = __webpack_require__(202);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_app_core_core__ = __webpack_require__(465);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__row_row_model__ = __webpack_require__(1322);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_app_core_utils_sort_by_keys__ = __webpack_require__(1376);
///<reference path="../../headers/common.d.ts" />








var DashboardModel = /** @class */ (function () {
    function DashboardModel(data, meta) {
        if (!data) {
            data = {};
        }
        this.events = new __WEBPACK_IMPORTED_MODULE_5_app_core_core__["Emitter"]();
        this.id = data.id || null;
        this.revision = data.revision;
        this.title = data.title || 'No Title';
        this.autoUpdate = data.autoUpdate;
        this.description = data.description;
        this.tags = data.tags || [];
        this.style = data.style || "dark";
        this.timezone = data.timezone || '';
        this.editable = data.editable !== false;
        this.graphTooltip = data.graphTooltip || 0;
        this.hideControls = data.hideControls || false;
        this.time = data.time || { from: 'now-6h', to: 'now' };
        this.timepicker = data.timepicker || {};
        this.templating = this.ensureListExist(data.templating);
        this.annotations = this.ensureListExist(data.annotations);
        this.refresh = data.refresh;
        this.snapshot = data.snapshot;
        this.schemaVersion = data.schemaVersion || 0;
        this.version = data.version || 0;
        this.links = data.links || [];
        this.gnetId = data.gnetId || null;
        this.rows = [];
        if (data.rows) {
            for (var _i = 0, _a = data.rows; _i < _a.length; _i++) {
                var row = _a[_i];
                this.rows.push(new __WEBPACK_IMPORTED_MODULE_6__row_row_model__["a" /* DashboardRow */](row));
            }
        }
        this.addBuiltInAnnotationQuery();
        this.updateSchema(data);
        this.initMeta(meta);
    }
    DashboardModel.prototype.addBuiltInAnnotationQuery = function () {
        var found = false;
        for (var _i = 0, _a = this.annotations.list; _i < _a.length; _i++) {
            var item = _a[_i];
            if (item.builtIn === 1) {
                found = true;
                break;
            }
        }
        if (found) {
            return;
        }
        this.annotations.list.unshift({
            datasource: '-- Grafana --',
            name: 'Annotations & Alerts',
            type: 'dashboard',
            iconColor: __WEBPACK_IMPORTED_MODULE_4_app_core_utils_colors__["b" /* DEFAULT_ANNOTATION_COLOR */],
            enable: true,
            hide: true,
            builtIn: 1,
        });
    };
    DashboardModel.prototype.initMeta = function (meta) {
        meta = meta || {};
        meta.canShare = meta.canShare !== false;
        meta.canSave = meta.canSave !== false;
        meta.canStar = meta.canStar !== false;
        meta.canEdit = meta.canEdit !== false;
        if (!this.editable) {
            meta.canEdit = false;
            meta.canDelete = false;
            meta.canSave = false;
        }
        this.meta = meta;
    };
    // cleans meta data and other non peristent state
    DashboardModel.prototype.getSaveModelClone = function () {
        // temp remove stuff
        var events = this.events;
        var meta = this.meta;
        var rows = this.rows;
        var variables = this.templating.list;
        delete this.events;
        delete this.meta;
        // prepare save model
        this.rows = __WEBPACK_IMPORTED_MODULE_2_lodash___default.a.map(rows, function (row) { return row.getSaveModel(); });
        this.templating.list = __WEBPACK_IMPORTED_MODULE_2_lodash___default.a.map(variables, function (variable) { return variable.getSaveModel ? variable.getSaveModel() : variable; });
        // make clone
        var copy = __WEBPACK_IMPORTED_MODULE_3_jquery___default.a.extend(true, {}, this);
        //  sort clone
        copy = Object(__WEBPACK_IMPORTED_MODULE_7_app_core_utils_sort_by_keys__["a" /* default */])(copy);
        // restore properties
        this.events = events;
        this.meta = meta;
        this.rows = rows;
        this.templating.list = variables;
        return copy;
    };
    DashboardModel.prototype.addEmptyRow = function () {
        this.rows.push(new __WEBPACK_IMPORTED_MODULE_6__row_row_model__["a" /* DashboardRow */]({ isNew: true }));
    };
    DashboardModel.prototype.ensureListExist = function (data) {
        if (!data) {
            data = {};
        }
        if (!data.list) {
            data.list = [];
        }
        return data;
    };
    DashboardModel.prototype.getNextPanelId = function () {
        var i, j, row, panel, max = 0;
        for (i = 0; i < this.rows.length; i++) {
            row = this.rows[i];
            for (j = 0; j < row.panels.length; j++) {
                panel = row.panels[j];
                if (panel.id > max) {
                    max = panel.id;
                }
            }
        }
        return max + 1;
    };
    DashboardModel.prototype.forEachPanel = function (callback) {
        var i, j, row;
        for (i = 0; i < this.rows.length; i++) {
            row = this.rows[i];
            for (j = 0; j < row.panels.length; j++) {
                callback(row.panels[j], j, row, i);
            }
        }
    };
    DashboardModel.prototype.getPanelById = function (id) {
        for (var i = 0; i < this.rows.length; i++) {
            var row = this.rows[i];
            for (var j = 0; j < row.panels.length; j++) {
                var panel = row.panels[j];
                if (panel.id === id) {
                    return panel;
                }
            }
        }
        return null;
    };
    DashboardModel.prototype.addPanel = function (panel, row) {
        panel.id = this.getNextPanelId();
        row.addPanel(panel);
    };
    DashboardModel.prototype.removeRow = function (row, force) {
        var _this = this;
        var index = __WEBPACK_IMPORTED_MODULE_2_lodash___default.a.indexOf(this.rows, row);
        if (!row.panels.length || force) {
            this.rows.splice(index, 1);
            row.destroy();
            return;
        }
        __WEBPACK_IMPORTED_MODULE_5_app_core_core__["appEvents"].emit('confirm-modal', {
            title: 'Remove Row',
            text: 'Are you sure you want to remove this row?',
            icon: 'fa-trash',
            yesText: 'Delete',
            onConfirm: function () {
                _this.rows.splice(index, 1);
                row.destroy();
            }
        });
    };
    DashboardModel.prototype.setPanelFocus = function (id) {
        this.meta.focusPanelId = id;
    };
    DashboardModel.prototype.updateSubmenuVisibility = function () {
        var _this = this;
        this.meta.submenuEnabled = (function () {
            if (_this.links.length > 0) {
                return true;
            }
            var visibleVars = __WEBPACK_IMPORTED_MODULE_2_lodash___default.a.filter(_this.templating.list, function (variable) { return variable.hide !== 2; });
            if (visibleVars.length > 0) {
                return true;
            }
            var visibleAnnotations = __WEBPACK_IMPORTED_MODULE_2_lodash___default.a.filter(_this.annotations.list, function (annotation) { return annotation.hide !== true; });
            if (visibleAnnotations.length > 0) {
                return true;
            }
            return false;
        })();
    };
    DashboardModel.prototype.getPanelInfoById = function (panelId) {
        var result = {};
        __WEBPACK_IMPORTED_MODULE_2_lodash___default.a.each(this.rows, function (row) {
            __WEBPACK_IMPORTED_MODULE_2_lodash___default.a.each(row.panels, function (panel, index) {
                if (panel.id === panelId) {
                    result.panel = panel;
                    result.row = row;
                    result.index = index;
                }
            });
        });
        if (!result.panel) {
            return null;
        }
        return result;
    };
    DashboardModel.prototype.duplicatePanel = function (panel, row) {
        var newPanel = __WEBPACK_IMPORTED_MODULE_0_angular___default.a.copy(panel);
        newPanel.id = this.getNextPanelId();
        delete newPanel.repeat;
        delete newPanel.repeatIteration;
        delete newPanel.repeatPanelId;
        delete newPanel.scopedVars;
        if (newPanel.alert) {
            delete newPanel.thresholds;
        }
        delete newPanel.alert;
        row.addPanel(newPanel);
        return newPanel;
    };
    DashboardModel.prototype.formatDate = function (date, format) {
        date = __WEBPACK_IMPORTED_MODULE_1_moment___default.a.isMoment(date) ? date : __WEBPACK_IMPORTED_MODULE_1_moment___default()(date);
        format = format || 'YYYY-MM-DD HH:mm:ss';
        var timezone = this.getTimezone();
        return timezone === 'browser' ?
            __WEBPACK_IMPORTED_MODULE_1_moment___default()(date).format(format) :
            __WEBPACK_IMPORTED_MODULE_1_moment___default.a.utc(date).format(format);
    };
    DashboardModel.prototype.destroy = function () {
        this.events.removeAllListeners();
        for (var _i = 0, _a = this.rows; _i < _a.length; _i++) {
            var row = _a[_i];
            row.destroy();
        }
    };
    DashboardModel.prototype.cycleGraphTooltip = function () {
        this.graphTooltip = (this.graphTooltip + 1) % 3;
    };
    DashboardModel.prototype.sharedTooltipModeEnabled = function () {
        return this.graphTooltip > 0;
    };
    DashboardModel.prototype.sharedCrosshairModeOnly = function () {
        return this.graphTooltip === 1;
    };
    DashboardModel.prototype.getRelativeTime = function (date) {
        date = __WEBPACK_IMPORTED_MODULE_1_moment___default.a.isMoment(date) ? date : __WEBPACK_IMPORTED_MODULE_1_moment___default()(date);
        return this.timezone === 'browser' ?
            __WEBPACK_IMPORTED_MODULE_1_moment___default()(date).fromNow() :
            __WEBPACK_IMPORTED_MODULE_1_moment___default.a.utc(date).fromNow();
    };
    DashboardModel.prototype.getNextQueryLetter = function (panel) {
        var letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
        return __WEBPACK_IMPORTED_MODULE_2_lodash___default.a.find(letters, function (refId) {
            return __WEBPACK_IMPORTED_MODULE_2_lodash___default.a.every(panel.targets, function (other) {
                return other.refId !== refId;
            });
        });
    };
    DashboardModel.prototype.isTimezoneUtc = function () {
        return this.getTimezone() === 'utc';
    };
    DashboardModel.prototype.getTimezone = function () {
        return this.timezone ? this.timezone : __WEBPACK_IMPORTED_MODULE_5_app_core_core__["contextSrv"].user.timezone;
    };
    DashboardModel.prototype.updateSchema = function (old) {
        var i, j, k;
        var oldVersion = this.schemaVersion;
        var panelUpgrades = [];
        this.schemaVersion = 14;
        if (oldVersion === this.schemaVersion) {
            return;
        }
        // version 2 schema changes
        if (oldVersion < 2) {
            if (old.services) {
                if (old.services.filter) {
                    this.time = old.services.filter.time;
                    this.templating.list = old.services.filter.list || [];
                }
            }
            panelUpgrades.push(function (panel) {
                // rename panel type
                if (panel.type === 'graphite') {
                    panel.type = 'graph';
                }
                if (panel.type !== 'graph') {
                    return;
                }
                if (__WEBPACK_IMPORTED_MODULE_2_lodash___default.a.isBoolean(panel.legend)) {
                    panel.legend = { show: panel.legend };
                }
                if (panel.grid) {
                    if (panel.grid.min) {
                        panel.grid.leftMin = panel.grid.min;
                        delete panel.grid.min;
                    }
                    if (panel.grid.max) {
                        panel.grid.leftMax = panel.grid.max;
                        delete panel.grid.max;
                    }
                }
                if (panel.y_format) {
                    panel.y_formats[0] = panel.y_format;
                    delete panel.y_format;
                }
                if (panel.y2_format) {
                    panel.y_formats[1] = panel.y2_format;
                    delete panel.y2_format;
                }
            });
        }
        // schema version 3 changes
        if (oldVersion < 3) {
            // ensure panel ids
            var maxId = this.getNextPanelId();
            panelUpgrades.push(function (panel) {
                if (!panel.id) {
                    panel.id = maxId;
                    maxId += 1;
                }
            });
        }
        // schema version 4 changes
        if (oldVersion < 4) {
            // move aliasYAxis changes
            panelUpgrades.push(function (panel) {
                if (panel.type !== 'graph') {
                    return;
                }
                __WEBPACK_IMPORTED_MODULE_2_lodash___default.a.each(panel.aliasYAxis, function (value, key) {
                    panel.seriesOverrides = [{ alias: key, yaxis: value }];
                });
                delete panel.aliasYAxis;
            });
        }
        if (oldVersion < 6) {
            // move pulldowns to new schema
            var annotations = __WEBPACK_IMPORTED_MODULE_2_lodash___default.a.find(old.pulldowns, { type: 'annotations' });
            if (annotations) {
                this.annotations = {
                    list: annotations.annotations || [],
                };
            }
            // update template variables
            for (i = 0; i < this.templating.list.length; i++) {
                var variable = this.templating.list[i];
                if (variable.datasource === void 0) {
                    variable.datasource = null;
                }
                if (variable.type === 'filter') {
                    variable.type = 'query';
                }
                if (variable.type === void 0) {
                    variable.type = 'query';
                }
                if (variable.allFormat === void 0) {
                    variable.allFormat = 'glob';
                }
            }
        }
        if (oldVersion < 7) {
            if (old.nav && old.nav.length) {
                this.timepicker = old.nav[0];
            }
            // ensure query refIds
            panelUpgrades.push(function (panel) {
                __WEBPACK_IMPORTED_MODULE_2_lodash___default.a.each(panel.targets, function (target) {
                    if (!target.refId) {
                        target.refId = this.getNextQueryLetter(panel);
                    }
                }.bind(this));
            });
        }
        if (oldVersion < 8) {
            panelUpgrades.push(function (panel) {
                __WEBPACK_IMPORTED_MODULE_2_lodash___default.a.each(panel.targets, function (target) {
                    // update old influxdb query schema
                    if (target.fields && target.tags && target.groupBy) {
                        if (target.rawQuery) {
                            delete target.fields;
                            delete target.fill;
                        }
                        else {
                            target.select = __WEBPACK_IMPORTED_MODULE_2_lodash___default.a.map(target.fields, function (field) {
                                var parts = [];
                                parts.push({ type: 'field', params: [field.name] });
                                parts.push({ type: field.func, params: [] });
                                if (field.mathExpr) {
                                    parts.push({ type: 'math', params: [field.mathExpr] });
                                }
                                if (field.asExpr) {
                                    parts.push({ type: 'alias', params: [field.asExpr] });
                                }
                                return parts;
                            });
                            delete target.fields;
                            __WEBPACK_IMPORTED_MODULE_2_lodash___default.a.each(target.groupBy, function (part) {
                                if (part.type === 'time' && part.interval) {
                                    part.params = [part.interval];
                                    delete part.interval;
                                }
                                if (part.type === 'tag' && part.key) {
                                    part.params = [part.key];
                                    delete part.key;
                                }
                            });
                            if (target.fill) {
                                target.groupBy.push({ type: 'fill', params: [target.fill] });
                                delete target.fill;
                            }
                        }
                    }
                });
            });
        }
        // schema version 9 changes
        if (oldVersion < 9) {
            // move aliasYAxis changes
            panelUpgrades.push(function (panel) {
                if (panel.type !== 'singlestat' && panel.thresholds !== "") {
                    return;
                }
                if (panel.thresholds) {
                    var k = panel.thresholds.split(",");
                    if (k.length >= 3) {
                        k.shift();
                        panel.thresholds = k.join(",");
                    }
                }
            });
        }
        // schema version 10 changes
        if (oldVersion < 10) {
            // move aliasYAxis changes
            panelUpgrades.push(function (panel) {
                if (panel.type !== 'table') {
                    return;
                }
                __WEBPACK_IMPORTED_MODULE_2_lodash___default.a.each(panel.styles, function (style) {
                    if (style.thresholds && style.thresholds.length >= 3) {
                        var k = style.thresholds;
                        k.shift();
                        style.thresholds = k;
                    }
                });
            });
        }
        if (oldVersion < 12) {
            // update template variables
            __WEBPACK_IMPORTED_MODULE_2_lodash___default.a.each(this.templating.list, function (templateVariable) {
                if (templateVariable.refresh) {
                    templateVariable.refresh = 1;
                }
                if (!templateVariable.refresh) {
                    templateVariable.refresh = 0;
                }
                if (templateVariable.hideVariable) {
                    templateVariable.hide = 2;
                }
                else if (templateVariable.hideLabel) {
                    templateVariable.hide = 1;
                }
            });
        }
        if (oldVersion < 12) {
            // update graph yaxes changes
            panelUpgrades.push(function (panel) {
                if (panel.type !== 'graph') {
                    return;
                }
                if (!panel.grid) {
                    return;
                }
                if (!panel.yaxes) {
                    panel.yaxes = [
                        {
                            show: panel['y-axis'],
                            min: panel.grid.leftMin,
                            max: panel.grid.leftMax,
                            logBase: panel.grid.leftLogBase,
                            format: panel.y_formats[0],
                            label: panel.leftYAxisLabel,
                        },
                        {
                            show: panel['y-axis'],
                            min: panel.grid.rightMin,
                            max: panel.grid.rightMax,
                            logBase: panel.grid.rightLogBase,
                            format: panel.y_formats[1],
                            label: panel.rightYAxisLabel,
                        }
                    ];
                    panel.xaxis = {
                        show: panel['x-axis'],
                    };
                    delete panel.grid.leftMin;
                    delete panel.grid.leftMax;
                    delete panel.grid.leftLogBase;
                    delete panel.grid.rightMin;
                    delete panel.grid.rightMax;
                    delete panel.grid.rightLogBase;
                    delete panel.y_formats;
                    delete panel.leftYAxisLabel;
                    delete panel.rightYAxisLabel;
                    delete panel['y-axis'];
                    delete panel['x-axis'];
                }
            });
        }
        if (oldVersion < 13) {
            // update graph yaxes changes
            panelUpgrades.push(function (panel) {
                if (panel.type !== 'graph') {
                    return;
                }
                if (!panel.grid) {
                    return;
                }
                panel.thresholds = [];
                var t1 = {}, t2 = {};
                if (panel.grid.threshold1 !== null) {
                    t1.value = panel.grid.threshold1;
                    if (panel.grid.thresholdLine) {
                        t1.line = true;
                        t1.lineColor = panel.grid.threshold1Color;
                        t1.colorMode = 'custom';
                    }
                    else {
                        t1.fill = true;
                        t1.fillColor = panel.grid.threshold1Color;
                        t1.colorMode = 'custom';
                    }
                }
                if (panel.grid.threshold2 !== null) {
                    t2.value = panel.grid.threshold2;
                    if (panel.grid.thresholdLine) {
                        t2.line = true;
                        t2.lineColor = panel.grid.threshold2Color;
                        t2.colorMode = 'custom';
                    }
                    else {
                        t2.fill = true;
                        t2.fillColor = panel.grid.threshold2Color;
                        t2.colorMode = 'custom';
                    }
                }
                if (__WEBPACK_IMPORTED_MODULE_2_lodash___default.a.isNumber(t1.value)) {
                    if (__WEBPACK_IMPORTED_MODULE_2_lodash___default.a.isNumber(t2.value)) {
                        if (t1.value > t2.value) {
                            t1.op = t2.op = 'lt';
                            panel.thresholds.push(t1);
                            panel.thresholds.push(t2);
                        }
                        else {
                            t1.op = t2.op = 'gt';
                            panel.thresholds.push(t1);
                            panel.thresholds.push(t2);
                        }
                    }
                    else {
                        t1.op = 'gt';
                        panel.thresholds.push(t1);
                    }
                }
                delete panel.grid.threshold1;
                delete panel.grid.threshold1Color;
                delete panel.grid.threshold2;
                delete panel.grid.threshold2Color;
                delete panel.grid.thresholdLine;
            });
        }
        if (oldVersion < 14) {
            this.graphTooltip = old.sharedCrosshair ? 1 : 0;
        }
        if (panelUpgrades.length === 0) {
            return;
        }
        for (i = 0; i < this.rows.length; i++) {
            var row = this.rows[i];
            for (j = 0; j < row.panels.length; j++) {
                for (k = 0; k < panelUpgrades.length; k++) {
                    panelUpgrades[k].call(this, row.panels[j]);
                }
            }
        }
    };
    return DashboardModel;
}());



/***/ }),

/***/ 1376:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = sortByKeys;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_lodash__);

function sortByKeys(input) {
    if (__WEBPACK_IMPORTED_MODULE_0_lodash___default.a.isArray(input)) {
        return input.map(sortByKeys);
    }
    if (__WEBPACK_IMPORTED_MODULE_0_lodash___default.a.isPlainObject(input)) {
        var sortedObject = {};
        for (var _i = 0, _a = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.keys(input).sort(); _i < _a.length; _i++) {
            var key = _a[_i];
            sortedObject[key] = sortByKeys(input[key]);
        }
        return sortedObject;
    }
    return input;
}


/***/ }),

/***/ 1377:
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
  __webpack_require__(12),
  __webpack_require__(7),
  __webpack_require__(13),
  __webpack_require__(27)
], __WEBPACK_AMD_DEFINE_RESULT__ = function (angular, _, $, config) {
  'use strict';

  config = config.default;
  var module = angular.module('grafana.services');

  module.factory('dashboardViewStateSrv', ["$location", "$timeout", function($location, $timeout) {

    // represents the transient view state
    // like fullscreen panel & edit
    function DashboardViewState($scope) {
      var self = this;
      self.state = {};
      self.panelScopes = [];
      self.$scope = $scope;
      self.dashboard = $scope.dashboard;

      $scope.onAppEvent('$routeUpdate', function() {
        var urlState = self.getQueryStringState();
        if (self.needsSync(urlState)) {
          self.update(urlState, true);
        }
      });

      $scope.onAppEvent('panel-change-view', function(evt, payload) {
        self.update(payload);
      });

      $scope.onAppEvent('panel-initialized', function(evt, payload) {
        self.registerPanel(payload.scope);
      });

      // this marks changes to location during this digest cycle as not to add history item
      // dont want url changes like adding orgId to add browser history
      $location.replace();
      this.update(this.getQueryStringState());
      this.expandRowForPanel();
    }

    DashboardViewState.prototype.expandRowForPanel = function() {
      if (!this.state.panelId) { return; }

      var panelInfo = this.$scope.dashboard.getPanelInfoById(this.state.panelId);
      if (panelInfo) {
        panelInfo.row.collapse = false;
      }
    };

    DashboardViewState.prototype.needsSync = function(urlState) {
      return _.isEqual(this.state, urlState) === false;
    };

    DashboardViewState.prototype.getQueryStringState = function() {
      var state = $location.search();
      state.panelId = parseInt(state.panelId) || null;
      state.fullscreen = state.fullscreen ? true : null;
      state.edit =  (state.edit === "true" || state.edit === true) || null;
      state.editview = state.editview || null;
      state.orgId = config.bootData.user.orgId;
      return state;
    };

    DashboardViewState.prototype.serializeToUrl = function() {
      var urlState = _.clone(this.state);
      urlState.fullscreen = this.state.fullscreen ? true : null;
      urlState.edit = this.state.edit ? true : null;
      return urlState;
    };

    DashboardViewState.prototype.update = function(state, fromRouteUpdated) {
      // implement toggle logic
      if (state.toggle) {
        delete state.toggle;
        if (this.state.fullscreen && state.fullscreen) {
          if (this.state.edit === state.edit) {
            state.fullscreen = !state.fullscreen;
          }
        }
      }

      // remember if editStateChanged
      this.editStateChanged = state.edit !== this.state.edit;

      _.extend(this.state, state);
      this.dashboard.meta.fullscreen = this.state.fullscreen;

      if (!this.state.fullscreen) {
        this.state.fullscreen = null;
        this.state.edit = null;
        // clear panel id unless in solo mode
        if (!this.dashboard.meta.soloMode) {
          this.state.panelId = null;
        }
      }

      // if no edit state cleanup tab parm
      if (!this.state.edit) {
        delete this.state.tab;
      }

      // do not update url params if we are here
      // from routeUpdated event
      if (fromRouteUpdated !== true) {
        $location.search(this.serializeToUrl());
      }

      this.syncState();
    };

    DashboardViewState.prototype.syncState = function() {
      if (this.panelScopes.length === 0) { return; }

      if (this.dashboard.meta.fullscreen) {
        var panelScope = this.getPanelScope(this.state.panelId);
        if (!panelScope) {
          return;
        }

        if (this.fullscreenPanel) {
          // if already fullscreen
          if (this.fullscreenPanel === panelScope && this.editStateChanged === false) {
            return;
          } else {
            this.leaveFullscreen(false);
          }
        }

        if (!panelScope.ctrl.editModeInitiated) {
          panelScope.ctrl.initEditMode();
        }

        if (!panelScope.ctrl.fullscreen) {
          this.enterFullscreen(panelScope);
        }
      } else if (this.fullscreenPanel) {
        this.leaveFullscreen(true);
      }
    };

    DashboardViewState.prototype.getPanelScope = function(id) {
      return _.find(this.panelScopes, function(panelScope) {
        return panelScope.ctrl.panel.id === id;
      });
    };

    DashboardViewState.prototype.leaveFullscreen = function(render) {
      var self = this;
      var ctrl = self.fullscreenPanel.ctrl;

      ctrl.editMode = false;
      ctrl.fullscreen = false;

      this.$scope.appEvent('panel-fullscreen-exit', {panelId: ctrl.panel.id});

      if (!render) { return false;}

      $timeout(function() {
        if (self.oldTimeRange !== ctrl.range) {
          self.$scope.broadcastRefresh();
        } else {
          self.$scope.$broadcast('render');
        }
        delete self.fullscreenPanel;
      });
    };

    DashboardViewState.prototype.enterFullscreen = function(panelScope) {
      var ctrl = panelScope.ctrl;

      ctrl.editMode = this.state.edit && this.dashboard.meta.canEdit;
      ctrl.fullscreen = true;

      this.oldTimeRange = ctrl.range;
      this.fullscreenPanel = panelScope;

      $(window).scrollTop(0);

      this.$scope.appEvent('panel-fullscreen-enter', {panelId: ctrl.panel.id});

      $timeout(function() {
        ctrl.render();
      });
    };

    DashboardViewState.prototype.registerPanel = function(panelScope) {
      var self = this;
      self.panelScopes.push(panelScope);

      if (!self.dashboard.meta.soloMode) {
        if (self.state.panelId === panelScope.ctrl.panel.id) {
          if (self.state.edit) {
            panelScope.ctrl.editPanel();
          } else {
            panelScope.ctrl.viewPanel();
          }
        }
      }

      var unbind = panelScope.$on('$destroy', function() {
        self.panelScopes = _.without(self.panelScopes, panelScope);
        unbind();
      });
    };

    return {
      create: function($scope) {
        return new DashboardViewState($scope);
      }
    };

  }]);
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(201)(module)))

/***/ }),

/***/ 1378:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AlertingSrv", function() { return AlertingSrv; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_app_core_core_module__ = __webpack_require__(2);
///<reference path="../../headers/common.d.ts" />

var AlertingSrv = /** @class */ (function () {
    function AlertingSrv() {
    }
    AlertingSrv.prototype.init = function (dashboard, alerts) {
        this.dashboard = dashboard;
        this.alerts = alerts || [];
    };
    return AlertingSrv;
}());

__WEBPACK_IMPORTED_MODULE_0_app_core_core_module__["default"].service('alertingSrv', AlertingSrv);


/***/ }),

/***/ 1379:
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
  __webpack_require__(12),
  __webpack_require__(7),
], __WEBPACK_AMD_DEFINE_RESULT__ = function(angular, _) {
  'use strict';

  var module = angular.module('grafana.services');

  module.service('unsavedChangesSrv', ["$rootScope", "$q", "$location", "$timeout", "contextSrv", "dashboardSrv", "$window", function($rootScope, $q, $location, $timeout, contextSrv, dashboardSrv, $window) {

    function Tracker(dashboard, scope, originalCopyDelay) {
      var self = this;

      this.current = dashboard;
      this.originalPath = $location.path();
      this.scope = scope;

      // register events
      scope.onAppEvent('dashboard-saved', function() {
        this.original = this.current.getSaveModelClone();
        this.originalPath = $location.path();
      }.bind(this));

      $window.onbeforeunload = function() {
        if (self.ignoreChanges()) { return; }
        if (self.hasChanges()) {
          return "There are unsaved changes to this dashboard";
        }
      };

      scope.$on("$locationChangeStart", function(event, next) {
        // check if we should look for changes
        if (self.originalPath === $location.path()) { return true; }
        if (self.ignoreChanges()) { return true; }

        if (self.hasChanges()) {
          event.preventDefault();
          self.next = next;

          $timeout(function() {
            self.open_modal();
          });
        }
      });

      if (originalCopyDelay) {
        $timeout(function() {
          // wait for different services to patch the dashboard (missing properties)
          self.original = dashboard.getSaveModelClone();
        }, originalCopyDelay);
      } else {
        self.original = dashboard.getSaveModelClone();
      }
    }

    var p = Tracker.prototype;

    // for some dashboards and users
    // changes should be ignored
    p.ignoreChanges = function() {
      if (!this.original) { return true; }
      if (!contextSrv.isEditor) { return true; }
      if (!this.current || !this.current.meta) { return true; }

      var meta = this.current.meta;
      return !meta.canSave || meta.fromScript || meta.fromFile;
    };

    // remove stuff that should not count in diff
    p.cleanDashboardFromIgnoredChanges = function(dash) {
      // ignore time and refresh
      dash.time = 0;
      dash.refresh = 0;
      dash.schemaVersion = 0;

      // filter row and panels properties that should be ignored
      dash.rows = _.filter(dash.rows, function(row) {
        if (row.repeatRowId) {
          return false;
        }

        row.panels = _.filter(row.panels, function(panel) {
          if (panel.repeatPanelId) {
            return false;
          }

          // remove scopedVars
          panel.scopedVars = null;

          // ignore span changes
          panel.span = null;

          // ignore panel legend sort
          if (panel.legend)  {
            delete panel.legend.sort;
            delete panel.legend.sortDesc;
          }

          return true;
        });

        // ignore collapse state
        row.collapse = false;
        return true;
      });

      // ignore template variable values
      _.each(dash.templating.list, function(value) {
        value.current = null;
        value.options = null;
        value.filters = null;
      });
    };

    p.hasChanges = function() {
      var current = this.current.getSaveModelClone();
      var original = this.original;

      this.cleanDashboardFromIgnoredChanges(current);
      this.cleanDashboardFromIgnoredChanges(original);

      var currentTimepicker = _.find(current.nav, { type: 'timepicker' });
      var originalTimepicker = _.find(original.nav, { type: 'timepicker' });

      if (currentTimepicker && originalTimepicker) {
        currentTimepicker.now = originalTimepicker.now;
      }

      var currentJson = angular.toJson(current);
      var originalJson = angular.toJson(original);

      return currentJson !== originalJson;
    };

    p.discardChanges = function() {
      this.original = null;
      this.gotoNext();
    };

    p.open_modal = function() {
      $rootScope.appEvent('show-modal', {
        templateHtml: '<unsaved-changes-modal dismiss="dismiss()"></unsaved-changes-modal>',
        modalClass: 'modal--narrow confirm-modal'
      });
    };

    p.saveChanges = function() {
      var self = this;
      var cancel = $rootScope.$on('dashboard-saved', function() {
        cancel();
        $timeout(function() {
          self.gotoNext();
        });
      });

      $rootScope.appEvent('save-dashboard');
    };

    p.gotoNext = function() {
      var baseLen = $location.absUrl().length - $location.url().length;
      var nextUrl = this.next.substring(baseLen);
      $location.url(nextUrl);
    };

    this.Tracker = Tracker;
    this.init = function(dashboard, scope) {
      this.tracker = new Tracker(dashboard, scope, 1000);
      return this.tracker;
    };
  }]);
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(201)(module)))

/***/ }),

/***/ 1380:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UnsavedChangesModalCtrl", function() { return UnsavedChangesModalCtrl; });
/* harmony export (immutable) */ __webpack_exports__["unsavedChangesModalDirective"] = unsavedChangesModalDirective;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_app_core_core_module__ = __webpack_require__(2);
///<reference path="../../headers/common.d.ts" />

var template = "\n<div class=\"modal-body\">\n  <div class=\"modal-header\">\n    <h2 class=\"modal-header-title\">\n      <i class=\"fa fa-exclamation\"></i>\n      <span class=\"p-l-1\">Unsaved changes</span>\n    </h2>\n\n    <a class=\"modal-header-close\" ng-click=\"ctrl.dismiss();\">\n      <i class=\"fa fa-remove\"></i>\n    </a>\n  </div>\n\n  <div class=\"modal-content text-center\">\n\n    <div class=\"confirm-modal-text\">\n      Do you want to save your changes?\n    </div>\n\n    <div class=\"confirm-modal-buttons\">\n      <button type=\"button\" class=\"btn btn-inverse\" ng-click=\"ctrl.dismiss()\">Cancel</button>\n      <button type=\"button\" class=\"btn btn-danger\" ng-click=\"ctrl.discard()\">Discard</button>\n      <button type=\"button\" class=\"btn btn-success\" ng-click=\"ctrl.save()\">Save</button>\n    </div>\n  </div>\n</div>\n";
var UnsavedChangesModalCtrl = /** @class */ (function () {
    /** @ngInject */
    UnsavedChangesModalCtrl.$inject = ["unsavedChangesSrv"];
    function UnsavedChangesModalCtrl(unsavedChangesSrv) {
        this.unsavedChangesSrv = unsavedChangesSrv;
    }
    UnsavedChangesModalCtrl.prototype.discard = function () {
        this.dismiss();
        this.unsavedChangesSrv.tracker.discardChanges();
    };
    UnsavedChangesModalCtrl.prototype.save = function () {
        this.dismiss();
        this.unsavedChangesSrv.tracker.saveChanges();
    };
    return UnsavedChangesModalCtrl;
}());

function unsavedChangesModalDirective() {
    return {
        restrict: 'E',
        template: template,
        controller: UnsavedChangesModalCtrl,
        bindToController: true,
        controllerAs: 'ctrl',
        scope: { dismiss: "&" }
    };
}
__WEBPACK_IMPORTED_MODULE_0_app_core_core_module__["default"].directive('unsavedChangesModal', unsavedChangesModalDirective);


/***/ }),

/***/ 1381:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TimePickerCtrl", function() { return TimePickerCtrl; });
/* harmony export (immutable) */ __webpack_exports__["settingsDirective"] = settingsDirective;
/* harmony export (immutable) */ __webpack_exports__["timePickerDirective"] = timePickerDirective;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_angular__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_angular___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_angular__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_moment__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_moment___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_moment__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_app_core_utils_rangeutil__ = __webpack_require__(471);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__input_date__ = __webpack_require__(1382);
///<reference path="../../../headers/common.d.ts" />




var TimePickerCtrl = /** @class */ (function () {
    /** @ngInject */
    TimePickerCtrl.$inject = ["$scope", "$rootScope", "timeSrv"];
    function TimePickerCtrl($scope, $rootScope, timeSrv) {
        var _this = this;
        this.$scope = $scope;
        this.$rootScope = $rootScope;
        this.timeSrv = timeSrv;
        $scope.ctrl = this;
        $rootScope.onAppEvent('shift-time-forward', function () { return _this.move(1); }, $scope);
        $rootScope.onAppEvent('shift-time-backward', function () { return _this.move(-1); }, $scope);
        $rootScope.onAppEvent('refresh', this.onRefresh.bind(this), $scope);
        // init options
        this.panel = this.dashboard.timepicker;
        __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.defaults(this.panel, TimePickerCtrl.defaults);
        this.firstDayOfWeek = __WEBPACK_IMPORTED_MODULE_2_moment___default.a.localeData().firstDayOfWeek();
        // init time stuff
        this.onRefresh();
    }
    TimePickerCtrl.prototype.onRefresh = function () {
        var time = __WEBPACK_IMPORTED_MODULE_1_angular___default.a.copy(this.timeSrv.timeRange());
        var timeRaw = __WEBPACK_IMPORTED_MODULE_1_angular___default.a.copy(time.raw);
        if (!this.dashboard.isTimezoneUtc()) {
            time.from.local();
            time.to.local();
            if (__WEBPACK_IMPORTED_MODULE_2_moment___default.a.isMoment(timeRaw.from)) {
                timeRaw.from.local();
            }
            if (__WEBPACK_IMPORTED_MODULE_2_moment___default.a.isMoment(timeRaw.to)) {
                timeRaw.to.local();
            }
            this.isUtc = false;
        }
        else {
            this.isUtc = true;
        }
        this.rangeString = __WEBPACK_IMPORTED_MODULE_3_app_core_utils_rangeutil__["b" /* describeTimeRange */](timeRaw);
        this.absolute = { fromJs: time.from.toDate(), toJs: time.to.toDate() };
        this.tooltip = this.dashboard.formatDate(time.from) + ' <br>to<br>';
        this.tooltip += this.dashboard.formatDate(time.to);
        this.timeRaw = timeRaw;
    };
    TimePickerCtrl.prototype.zoom = function (factor) {
        this.$rootScope.appEvent('zoom-out', 2);
    };
    TimePickerCtrl.prototype.move = function (direction) {
        var range = this.timeSrv.timeRange();
        var timespan = (range.to.valueOf() - range.from.valueOf()) / 2;
        var to, from;
        if (direction === -1) {
            to = range.to.valueOf() - timespan;
            from = range.from.valueOf() - timespan;
        }
        else if (direction === 1) {
            to = range.to.valueOf() + timespan;
            from = range.from.valueOf() + timespan;
            if (to > Date.now() && range.to < Date.now()) {
                to = Date.now();
                from = range.from.valueOf();
            }
        }
        else {
            to = range.to.valueOf();
            from = range.from.valueOf();
        }
        this.timeSrv.setTime({ from: __WEBPACK_IMPORTED_MODULE_2_moment___default.a.utc(from), to: __WEBPACK_IMPORTED_MODULE_2_moment___default.a.utc(to) });
    };
    TimePickerCtrl.prototype.openDropdown = function () {
        this.onRefresh();
        this.editTimeRaw = this.timeRaw;
        this.timeOptions = __WEBPACK_IMPORTED_MODULE_3_app_core_utils_rangeutil__["c" /* getRelativeTimesList */](this.panel, this.rangeString);
        this.refresh = {
            value: this.dashboard.refresh,
            options: __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.map(this.panel.refresh_intervals, function (interval) {
                return { text: interval, value: interval };
            })
        };
        this.refresh.options.unshift({ text: 'off' });
        this.$rootScope.appEvent('show-dash-editor', {
            editview: 'timepicker',
            scope: this.$scope,
            cssClass: 'gf-timepicker-dropdown',
        });
    };
    TimePickerCtrl.prototype.applyCustom = function () {
        if (this.refresh.value !== this.dashboard.refresh) {
            this.timeSrv.setAutoRefresh(this.refresh.value);
        }
        this.timeSrv.setTime(this.editTimeRaw);
        this.$rootScope.appEvent('hide-dash-editor');
    };
    TimePickerCtrl.prototype.absoluteFromChanged = function () {
        this.editTimeRaw.from = this.getAbsoluteMomentForTimezone(this.absolute.fromJs);
    };
    TimePickerCtrl.prototype.absoluteToChanged = function () {
        this.editTimeRaw.to = this.getAbsoluteMomentForTimezone(this.absolute.toJs);
    };
    TimePickerCtrl.prototype.getAbsoluteMomentForTimezone = function (jsDate) {
        return this.dashboard.isTimezoneUtc() ? __WEBPACK_IMPORTED_MODULE_2_moment___default()(jsDate).utc() : __WEBPACK_IMPORTED_MODULE_2_moment___default()(jsDate);
    };
    TimePickerCtrl.prototype.setRelativeFilter = function (timespan) {
        var range = { from: timespan.from, to: timespan.to };
        if (this.panel.nowDelay && range.to === 'now') {
            range.to = 'now-' + this.panel.nowDelay;
        }
        this.timeSrv.setTime(range);
        this.$rootScope.appEvent('hide-dash-editor');
    };
    TimePickerCtrl.tooltipFormat = 'MMM D, YYYY HH:mm:ss';
    TimePickerCtrl.defaults = {
        time_options: ['5m', '15m', '1h', '6h', '12h', '24h', '2d', '7d', '30d'],
        refresh_intervals: ['5s', '10s', '30s', '1m', '5m', '15m', '30m', '1h', '2h', '1d'],
    };
    return TimePickerCtrl;
}());

function settingsDirective() {
    return {
        restrict: 'E',
        templateUrl: 'public/app/features/dashboard/timepicker/settings.html',
        controller: TimePickerCtrl,
        bindToController: true,
        controllerAs: 'ctrl',
        scope: {
            dashboard: "="
        }
    };
}
function timePickerDirective() {
    return {
        restrict: 'E',
        templateUrl: 'public/app/features/dashboard/timepicker/timepicker.html',
        controller: TimePickerCtrl,
        bindToController: true,
        controllerAs: 'ctrl',
        scope: {
            dashboard: "="
        }
    };
}
__WEBPACK_IMPORTED_MODULE_1_angular___default.a.module('grafana.directives').directive('gfTimePickerSettings', settingsDirective);
__WEBPACK_IMPORTED_MODULE_1_angular___default.a.module('grafana.directives').directive('gfTimePicker', timePickerDirective);

__WEBPACK_IMPORTED_MODULE_1_angular___default.a.module("grafana.directives").directive('inputDatetime', __WEBPACK_IMPORTED_MODULE_4__input_date__["a" /* inputDateDirective */]);


/***/ }),

/***/ 1382:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = inputDateDirective;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_moment__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_moment___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_moment__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_app_core_utils_datemath__ = __webpack_require__(467);


function inputDateDirective() {
    return {
        restrict: 'A',
        require: 'ngModel',
        link: function ($scope, $elem, attrs, ngModel) {
            var format = 'YYYY-MM-DD HH:mm:ss';
            var fromUser = function (text) {
                if (text.indexOf('now') !== -1) {
                    if (!__WEBPACK_IMPORTED_MODULE_1_app_core_utils_datemath__["isValid"](text)) {
                        ngModel.$setValidity('error', false);
                        return undefined;
                    }
                    ngModel.$setValidity('error', true);
                    return text;
                }
                var parsed;
                if ($scope.ctrl.isUtc) {
                    parsed = __WEBPACK_IMPORTED_MODULE_0_moment___default.a.utc(text, format);
                }
                else {
                    parsed = __WEBPACK_IMPORTED_MODULE_0_moment___default()(text, format);
                }
                if (!parsed.isValid()) {
                    ngModel.$setValidity('error', false);
                    return undefined;
                }
                ngModel.$setValidity('error', true);
                return parsed;
            };
            var toUser = function (currentValue) {
                if (__WEBPACK_IMPORTED_MODULE_0_moment___default.a.isMoment(currentValue)) {
                    return currentValue.format(format);
                }
                else {
                    return currentValue;
                }
            };
            ngModel.$parsers.push(fromUser);
            ngModel.$formatters.push(toUser);
        },
    };
}


/***/ }),

/***/ 1383:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
uploadDashboardDirective.$inject = ["timer", "alertSrv", "$location"];
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_app_core_core_module__ = __webpack_require__(2);
///<reference path="../../headers/common.d.ts" />

var template = "\n<input type=\"file\" id=\"dashupload\" name=\"dashupload\" class=\"hide\"/>\n<label class=\"btn btn-secondary\" for=\"dashupload\">\n  <i class=\"fa fa-upload\"></i>\n  Upload .json File\n</label>\n";
/** @ngInject */
function uploadDashboardDirective(timer, alertSrv, $location) {
    return {
        restrict: 'E',
        template: template,
        scope: {
            onUpload: '&',
        },
        link: function (scope) {
            function file_selected(evt) {
                var files = evt.target.files; // FileList object
                var readerOnload = function () {
                    return function (e) {
                        var dash;
                        try {
                            dash = JSON.parse(e.target.result);
                        }
                        catch (err) {
                            console.log(err);
                            scope.appEvent('alert-error', ['Import failed', 'JSON -> JS Serialization failed: ' + err.message]);
                            return;
                        }
                        scope.$apply(function () {
                            scope.onUpload({ dash: dash });
                        });
                    };
                };
                for (var i = 0, f; f = files[i]; i++) {
                    var reader = new FileReader();
                    reader.onload = readerOnload();
                    reader.readAsText(f);
                }
            }
            var wnd = window;
            // Check for the various File API support.
            if (wnd.File && wnd.FileReader && wnd.FileList && wnd.Blob) {
                // Something
                document.getElementById('dashupload').addEventListener('change', file_selected, false);
            }
            else {
                alertSrv.set('Oops', 'Sorry, the HTML5 File APIs are not fully supported in this browser.', 'error');
            }
        }
    };
}
__WEBPACK_IMPORTED_MODULE_0_app_core_core_module__["default"].directive('dashUpload', uploadDashboardDirective);


/***/ }),

/***/ 1384:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DashImportCtrl", function() { return DashImportCtrl; });
/* harmony export (immutable) */ __webpack_exports__["dashImportDirective"] = dashImportDirective;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_app_core_core_module__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_app_core_config__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_lodash__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_lodash__);
///<reference path="../../../headers/common.d.ts" />



var DashImportCtrl = /** @class */ (function () {
    /** @ngInject */
    DashImportCtrl.$inject = ["backendSrv", "$location", "$scope", "$routeParams"];
    function DashImportCtrl(backendSrv, $location, $scope, $routeParams) {
        this.backendSrv = backendSrv;
        this.$location = $location;
        this.$scope = $scope;
        this.step = 1;
        this.nameExists = false;
        // check gnetId in url
        if ($routeParams.gnetId) {
            this.gnetUrl = $routeParams.gnetId;
            this.checkGnetDashboard();
        }
    }
    DashImportCtrl.prototype.onUpload = function (dash) {
        this.dash = dash;
        this.dash.id = null;
        this.step = 2;
        this.inputs = [];
        if (this.dash.__inputs) {
            for (var _i = 0, _a = this.dash.__inputs; _i < _a.length; _i++) {
                var input = _a[_i];
                var inputModel = {
                    name: input.name,
                    label: input.label,
                    info: input.description,
                    value: input.value,
                    type: input.type,
                    pluginId: input.pluginId,
                    options: []
                };
                if (input.type === 'datasource') {
                    this.setDatasourceOptions(input, inputModel);
                }
                else if (!inputModel.info) {
                    inputModel.info = 'Specify a string constant';
                }
                this.inputs.push(inputModel);
            }
        }
        this.inputsValid = this.inputs.length === 0;
        this.titleChanged();
    };
    DashImportCtrl.prototype.setDatasourceOptions = function (input, inputModel) {
        var sources = __WEBPACK_IMPORTED_MODULE_2_lodash___default.a.filter(__WEBPACK_IMPORTED_MODULE_1_app_core_config__["default"].datasources, function (val) {
            return val.type === input.pluginId;
        });
        if (sources.length === 0) {
            inputModel.info = "No data sources of type " + input.pluginName + " found";
        }
        else if (!inputModel.info) {
            inputModel.info = "Select a " + input.pluginName + " data source";
        }
        inputModel.options = sources.map(function (val) {
            return { text: val.name, value: val.name };
        });
    };
    DashImportCtrl.prototype.inputValueChanged = function () {
        this.inputsValid = true;
        for (var _i = 0, _a = this.inputs; _i < _a.length; _i++) {
            var input = _a[_i];
            if (!input.value) {
                this.inputsValid = false;
            }
        }
    };
    DashImportCtrl.prototype.titleChanged = function () {
        var _this = this;
        this.backendSrv.search({ query: this.dash.title }).then(function (res) {
            _this.nameExists = false;
            for (var _i = 0, res_1 = res; _i < res_1.length; _i++) {
                var hit = res_1[_i];
                if (_this.dash.title === hit.title) {
                    _this.nameExists = true;
                    break;
                }
            }
        });
    };
    DashImportCtrl.prototype.saveDashboard = function () {
        var _this = this;
        var inputs = this.inputs.map(function (input) {
            return {
                name: input.name,
                type: input.type,
                pluginId: input.pluginId,
                value: input.value
            };
        });
        return this.backendSrv.post('api/dashboards/import', {
            dashboard: this.dash,
            overwrite: true,
            inputs: inputs
        }).then(function (res) {
            _this.$location.url('dashboard/' + res.importedUri);
            _this.$scope.dismiss();
        });
    };
    DashImportCtrl.prototype.loadJsonText = function () {
        try {
            this.parseError = '';
            var dash = JSON.parse(this.jsonText);
            this.onUpload(dash);
        }
        catch (err) {
            console.log(err);
            this.parseError = err.message;
            return;
        }
    };
    DashImportCtrl.prototype.checkGnetDashboard = function () {
        var _this = this;
        this.gnetError = '';
        var match = /(^\d+$)|dashboards\/(\d+)/.exec(this.gnetUrl);
        var dashboardId;
        if (match && match[1]) {
            dashboardId = match[1];
        }
        else if (match && match[2]) {
            dashboardId = match[2];
        }
        else {
            this.gnetError = 'Could not find dashboard';
        }
        return this.backendSrv.get('api/gnet/dashboards/' + dashboardId).then(function (res) {
            _this.gnetInfo = res;
            // store reference to grafana.com
            res.json.gnetId = res.id;
            _this.onUpload(res.json);
        }).catch(function (err) {
            err.isHandled = true;
            _this.gnetError = err.data.message || err;
        });
    };
    DashImportCtrl.prototype.back = function () {
        this.gnetUrl = '';
        this.step = 1;
        this.gnetError = '';
        this.gnetInfo = '';
    };
    return DashImportCtrl;
}());

function dashImportDirective() {
    return {
        restrict: 'E',
        templateUrl: 'public/app/features/dashboard/import/dash_import.html',
        controller: DashImportCtrl,
        bindToController: true,
        controllerAs: 'ctrl',
    };
}
__WEBPACK_IMPORTED_MODULE_0_app_core_core_module__["default"].directive('dashImport', dashImportDirective);


/***/ }),

/***/ 1385:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DashExportCtrl", function() { return DashExportCtrl; });
/* harmony export (immutable) */ __webpack_exports__["dashExportDirective"] = dashExportDirective;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_angular__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_angular___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_angular__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_file_saver__ = __webpack_require__(203);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_file_saver___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_file_saver__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_app_core_core_module__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__exporter__ = __webpack_require__(1386);




var DashExportCtrl = /** @class */ (function () {
    /** @ngInject */
    DashExportCtrl.$inject = ["dashboardSrv", "datasourceSrv", "$scope"];
    function DashExportCtrl(dashboardSrv, datasourceSrv, $scope) {
        var _this = this;
        this.dashboardSrv = dashboardSrv;
        this.$scope = $scope;
        this.exporter = new __WEBPACK_IMPORTED_MODULE_3__exporter__["a" /* DashboardExporter */](datasourceSrv);
        this.exporter.makeExportable(this.dashboardSrv.getCurrent()).then(function (dash) {
            _this.$scope.$apply(function () {
                _this.dash = dash;
            });
        });
    }
    DashExportCtrl.prototype.save = function () {
        var blob = new Blob([__WEBPACK_IMPORTED_MODULE_0_angular___default.a.toJson(this.dash, true)], { type: 'application/json;charset=utf-8' });
        Object(__WEBPACK_IMPORTED_MODULE_1_file_saver__["saveAs"])(blob, this.dash.title + '-' + new Date().getTime() + '.json');
    };
    DashExportCtrl.prototype.saveJson = function () {
        var clone = this.dashboardSrv.getCurrent().getSaveModelClone();
        this.$scope.$root.appEvent('show-json-editor', {
            object: clone,
        });
        this.dismiss();
    };
    return DashExportCtrl;
}());

function dashExportDirective() {
    return {
        restrict: 'E',
        templateUrl: 'public/app/features/dashboard/export/export_modal.html',
        controller: DashExportCtrl,
        bindToController: true,
        controllerAs: 'ctrl',
        scope: { dismiss: '&' },
    };
}
__WEBPACK_IMPORTED_MODULE_2_app_core_core_module__["default"].directive('dashExportModal', dashExportDirective);


/***/ }),

/***/ 1386:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return DashboardExporter; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_app_core_config__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_lodash__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__dynamic_dashboard_srv__ = __webpack_require__(1387);
///<reference path="../../../headers/common.d.ts" />



var DashboardExporter = /** @class */ (function () {
    function DashboardExporter(datasourceSrv) {
        this.datasourceSrv = datasourceSrv;
    }
    DashboardExporter.prototype.makeExportable = function (dashboard) {
        var _this = this;
        var dynSrv = new __WEBPACK_IMPORTED_MODULE_2__dynamic_dashboard_srv__["a" /* DynamicDashboardSrv */]();
        // clean up repeated rows and panels,
        // this is done on the live real dashboard instance, not on a clone
        // so we need to undo this
        // this is pretty hacky and needs to be changed
        dynSrv.init(dashboard);
        dynSrv.process({ cleanUpOnly: true });
        var saveModel = dashboard.getSaveModelClone();
        saveModel.id = null;
        // undo repeat cleanup
        dynSrv.process();
        var inputs = [];
        var requires = {};
        var datasources = {};
        var promises = [];
        var variableLookup = {};
        for (var _i = 0, _a = saveModel.templating.list; _i < _a.length; _i++) {
            var variable = _a[_i];
            variableLookup[variable.name] = variable;
        }
        var templateizeDatasourceUsage = function (obj) {
            // ignore data source properties that contain a variable
            if (obj.datasource && obj.datasource.indexOf('$') === 0) {
                if (variableLookup[obj.datasource.substring(1)]) {
                    return;
                }
            }
            promises.push(_this.datasourceSrv.get(obj.datasource).then(function (ds) {
                if (ds.meta.builtIn) {
                    return;
                }
                var refName = 'DS_' + ds.name.replace(' ', '_').toUpperCase();
                datasources[refName] = {
                    name: refName,
                    label: ds.name,
                    description: '',
                    type: 'datasource',
                    pluginId: ds.meta.id,
                    pluginName: ds.meta.name,
                };
                obj.datasource = '${' + refName + '}';
                requires['datasource' + ds.meta.id] = {
                    type: 'datasource',
                    id: ds.meta.id,
                    name: ds.meta.name,
                    version: ds.meta.info.version || "1.0.0",
                };
            }));
        };
        // check up panel data sources
        for (var _b = 0, _c = saveModel.rows; _b < _c.length; _b++) {
            var row = _c[_b];
            for (var _d = 0, _e = row.panels; _d < _e.length; _d++) {
                var panel = _e[_d];
                if (panel.datasource !== undefined) {
                    templateizeDatasourceUsage(panel);
                }
                if (panel.targets) {
                    for (var _f = 0, _g = panel.targets; _f < _g.length; _f++) {
                        var target = _g[_f];
                        if (target.datasource !== undefined) {
                            templateizeDatasourceUsage(target);
                        }
                    }
                }
                var panelDef = __WEBPACK_IMPORTED_MODULE_0_app_core_config__["default"].panels[panel.type];
                if (panelDef) {
                    requires['panel' + panelDef.id] = {
                        type: 'panel',
                        id: panelDef.id,
                        name: panelDef.name,
                        version: panelDef.info.version,
                    };
                }
            }
        }
        // templatize template vars
        for (var _h = 0, _j = saveModel.templating.list; _h < _j.length; _h++) {
            var variable = _j[_h];
            if (variable.type === 'query') {
                templateizeDatasourceUsage(variable);
                variable.options = [];
                variable.current = {};
                variable.refresh = variable.refresh > 0 ? variable.refresh : 1;
            }
        }
        // templatize annotations vars
        for (var _k = 0, _l = saveModel.annotations.list; _k < _l.length; _k++) {
            var annotationDef = _l[_k];
            templateizeDatasourceUsage(annotationDef);
        }
        // add grafana version
        requires['grafana'] = {
            type: 'grafana',
            id: 'grafana',
            name: 'Grafana',
            version: __WEBPACK_IMPORTED_MODULE_0_app_core_config__["default"].buildInfo.version
        };
        return Promise.all(promises).then(function () {
            __WEBPACK_IMPORTED_MODULE_1_lodash___default.a.each(datasources, function (value, key) {
                inputs.push(value);
            });
            // templatize constants
            for (var _i = 0, _a = saveModel.templating.list; _i < _a.length; _i++) {
                var variable = _a[_i];
                if (variable.type === 'constant') {
                    var refName = 'VAR_' + variable.name.replace(' ', '_').toUpperCase();
                    inputs.push({
                        name: refName,
                        type: 'constant',
                        label: variable.label || variable.name,
                        value: variable.current.value,
                        description: '',
                    });
                    // update current and option
                    variable.query = '${' + refName + '}';
                    variable.options[0] = variable.current = {
                        value: variable.query,
                        text: variable.query,
                    };
                }
            }
            // make inputs and requires a top thing
            var newObj = {};
            newObj["__inputs"] = inputs;
            newObj["__requires"] = __WEBPACK_IMPORTED_MODULE_1_lodash___default.a.sortBy(requires, ['id']);
            __WEBPACK_IMPORTED_MODULE_1_lodash___default.a.defaults(newObj, saveModel);
            return newObj;
        }).catch(function (err) {
            console.log('Export failed:', err);
            return {
                error: err
            };
        });
    };
    return DashboardExporter;
}());



/***/ }),

/***/ 1387:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return DynamicDashboardSrv; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_angular__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_angular___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_angular__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_lodash__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_app_core_core_module__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__row_row_model__ = __webpack_require__(1322);
///<reference path="../../headers/common.d.ts" />




var DynamicDashboardSrv = /** @class */ (function () {
    function DynamicDashboardSrv() {
    }
    DynamicDashboardSrv.prototype.init = function (dashboard) {
        this.dashboard = dashboard;
        this.variables = dashboard.templating.list;
    };
    DynamicDashboardSrv.prototype.process = function (options) {
        if (this.dashboard.snapshot || this.variables.length === 0) {
            return;
        }
        this.iteration = (this.iteration || new Date().getTime()) + 1;
        options = options || {};
        var cleanUpOnly = options.cleanUpOnly;
        var i, j, row, panel;
        // cleanup scopedVars
        for (i = 0; i < this.dashboard.rows.length; i++) {
            row = this.dashboard.rows[i];
            delete row.scopedVars;
            for (j = 0; j < row.panels.length; j++) {
                delete row.panels[j].scopedVars;
            }
        }
        for (i = 0; i < this.dashboard.rows.length; i++) {
            row = this.dashboard.rows[i];
            // handle row repeats
            if (row.repeat) {
                if (!cleanUpOnly) {
                    this.repeatRow(row, i);
                }
            }
            else if (row.repeatRowId && row.repeatIteration !== this.iteration) {
                // clean up old left overs
                this.dashboard.removeRow(row, true);
                i = i - 1;
                continue;
            }
            // repeat panels
            for (j = 0; j < row.panels.length; j++) {
                panel = row.panels[j];
                if (panel.repeat) {
                    if (!cleanUpOnly) {
                        this.repeatPanel(panel, row);
                    }
                }
                else if (panel.repeatPanelId && panel.repeatIteration !== this.iteration) {
                    // clean up old left overs
                    row.panels = __WEBPACK_IMPORTED_MODULE_1_lodash___default.a.without(row.panels, panel);
                    j = j - 1;
                }
            }
            row.panelSpanChanged();
        }
    };
    // returns a new row clone or reuses a clone from previous iteration
    DynamicDashboardSrv.prototype.getRowClone = function (sourceRow, repeatIndex, sourceRowIndex) {
        if (repeatIndex === 0) {
            return sourceRow;
        }
        var i, panel, row, copy;
        var sourceRowId = sourceRowIndex + 1;
        // look for row to reuse
        for (i = 0; i < this.dashboard.rows.length; i++) {
            row = this.dashboard.rows[i];
            if (row.repeatRowId === sourceRowId && row.repeatIteration !== this.iteration) {
                copy = row;
                copy.copyPropertiesFromRowSource(sourceRow);
                break;
            }
        }
        if (!copy) {
            var modelCopy = __WEBPACK_IMPORTED_MODULE_0_angular___default.a.copy(sourceRow.getSaveModel());
            copy = new __WEBPACK_IMPORTED_MODULE_3__row_row_model__["a" /* DashboardRow */](modelCopy);
            this.dashboard.rows.splice(sourceRowIndex + repeatIndex, 0, copy);
            // set new panel ids
            for (i = 0; i < copy.panels.length; i++) {
                panel = copy.panels[i];
                panel.id = this.dashboard.getNextPanelId();
            }
        }
        copy.repeat = null;
        copy.repeatRowId = sourceRowId;
        copy.repeatIteration = this.iteration;
        return copy;
    };
    // returns a new row clone or reuses a clone from previous iteration
    DynamicDashboardSrv.prototype.repeatRow = function (row, rowIndex) {
        var _this = this;
        var variable = __WEBPACK_IMPORTED_MODULE_1_lodash___default.a.find(this.variables, { name: row.repeat });
        if (!variable) {
            return;
        }
        var selected, copy, i, panel;
        if (variable.current.text === 'All') {
            selected = variable.options.slice(1, variable.options.length);
        }
        else {
            selected = __WEBPACK_IMPORTED_MODULE_1_lodash___default.a.filter(variable.options, { selected: true });
        }
        __WEBPACK_IMPORTED_MODULE_1_lodash___default.a.each(selected, function (option, index) {
            copy = _this.getRowClone(row, index, rowIndex);
            copy.scopedVars = {};
            copy.scopedVars[variable.name] = option;
            for (i = 0; i < copy.panels.length; i++) {
                panel = copy.panels[i];
                panel.scopedVars = {};
                panel.scopedVars[variable.name] = option;
            }
        });
    };
    DynamicDashboardSrv.prototype.getPanelClone = function (sourcePanel, row, index) {
        // if first clone return source
        if (index === 0) {
            return sourcePanel;
        }
        var i, tmpId, panel, clone;
        // first try finding an existing clone to use
        for (i = 0; i < row.panels.length; i++) {
            panel = row.panels[i];
            if (panel.repeatIteration !== this.iteration && panel.repeatPanelId === sourcePanel.id) {
                clone = panel;
                break;
            }
        }
        if (!clone) {
            clone = { id: this.dashboard.getNextPanelId() };
            row.panels.push(clone);
        }
        // save id
        tmpId = clone.id;
        // copy properties from source
        __WEBPACK_IMPORTED_MODULE_0_angular___default.a.copy(sourcePanel, clone);
        // restore id
        clone.id = tmpId;
        clone.repeatIteration = this.iteration;
        clone.repeatPanelId = sourcePanel.id;
        clone.repeat = null;
        return clone;
    };
    DynamicDashboardSrv.prototype.repeatPanel = function (panel, row) {
        var _this = this;
        var variable = __WEBPACK_IMPORTED_MODULE_1_lodash___default.a.find(this.variables, { name: panel.repeat });
        if (!variable) {
            return;
        }
        var selected;
        if (variable.current.text === 'All') {
            selected = variable.options.slice(1, variable.options.length);
        }
        else {
            selected = __WEBPACK_IMPORTED_MODULE_1_lodash___default.a.filter(variable.options, { selected: true });
        }
        __WEBPACK_IMPORTED_MODULE_1_lodash___default.a.each(selected, function (option, index) {
            var copy = _this.getPanelClone(panel, row, index);
            copy.span = Math.max(12 / selected.length, panel.minSpan || 4);
            copy.scopedVars = copy.scopedVars || {};
            copy.scopedVars[variable.name] = option;
        });
    };
    return DynamicDashboardSrv;
}());

__WEBPACK_IMPORTED_MODULE_2_app_core_core_module__["default"].service('dynamicDashboardSrv', DynamicDashboardSrv);


/***/ }),

/***/ 1388:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ExportDataModalCtrl", function() { return ExportDataModalCtrl; });
/* harmony export (immutable) */ __webpack_exports__["exportDataModal"] = exportDataModal;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_angular__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_angular___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_angular__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_app_core_utils_file_export__ = __webpack_require__(1323);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_app_core_app_events__ = __webpack_require__(53);



var ExportDataModalCtrl = /** @class */ (function () {
    function ExportDataModalCtrl() {
        this.asRows = true;
        this.dateTimeFormat = 'YYYY-MM-DDTHH:mm:ssZ';
    }
    ExportDataModalCtrl.prototype.export = function () {
        if (this.panel === 'table') {
            __WEBPACK_IMPORTED_MODULE_1_app_core_utils_file_export__["exportTableDataToCsv"](this.data, this.excel);
        }
        else {
            if (this.asRows) {
                __WEBPACK_IMPORTED_MODULE_1_app_core_utils_file_export__["exportSeriesListToCsv"](this.data, this.dateTimeFormat, this.excel);
            }
            else {
                __WEBPACK_IMPORTED_MODULE_1_app_core_utils_file_export__["exportSeriesListToCsvColumns"](this.data, this.dateTimeFormat, this.excel);
            }
        }
        this.dismiss();
    };
    ExportDataModalCtrl.prototype.dismiss = function () {
        __WEBPACK_IMPORTED_MODULE_2_app_core_app_events__["a" /* default */].emit('hide-modal');
    };
    return ExportDataModalCtrl;
}());

function exportDataModal() {
    return {
        restrict: 'E',
        templateUrl: 'public/app/features/dashboard/export_data/export_data_modal.html',
        controller: ExportDataModalCtrl,
        controllerAs: 'ctrl',
        scope: {
            panel: '<',
            data: '<' // The difference to '=' is that the bound properties are not watched
        },
        bindToController: true
    };
}
__WEBPACK_IMPORTED_MODULE_0_angular___default.a.module('grafana.directives').directive('exportDataModal', exportDataModal);


/***/ }),

/***/ 1389:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AdHocFiltersCtrl", function() { return AdHocFiltersCtrl; });
/* harmony export (immutable) */ __webpack_exports__["adHocFiltersComponent"] = adHocFiltersComponent;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_angular__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_angular___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_angular__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_app_core_core_module__ = __webpack_require__(2);
///<reference path="../../headers/common.d.ts" />



var AdHocFiltersCtrl = /** @class */ (function () {
    /** @ngInject */
    AdHocFiltersCtrl.$inject = ["uiSegmentSrv", "datasourceSrv", "$q", "variableSrv", "$scope", "$rootScope"];
    function AdHocFiltersCtrl(uiSegmentSrv, datasourceSrv, $q, variableSrv, $scope, $rootScope) {
        this.uiSegmentSrv = uiSegmentSrv;
        this.datasourceSrv = datasourceSrv;
        this.$q = $q;
        this.variableSrv = variableSrv;
        this.$rootScope = $rootScope;
        this.removeTagFilterSegment = uiSegmentSrv.newSegment({ fake: true, value: '-- remove filter --' });
        this.buildSegmentModel();
        this.$rootScope.onAppEvent('template-variable-value-updated', this.buildSegmentModel.bind(this), $scope);
    }
    AdHocFiltersCtrl.prototype.buildSegmentModel = function () {
        this.segments = [];
        if (this.variable.value && !__WEBPACK_IMPORTED_MODULE_0_lodash___default.a.isArray(this.variable.value)) {
        }
        for (var _i = 0, _a = this.variable.filters; _i < _a.length; _i++) {
            var tag = _a[_i];
            if (this.segments.length > 0) {
                this.segments.push(this.uiSegmentSrv.newCondition('AND'));
            }
            if (tag.key !== undefined && tag.value !== undefined) {
                this.segments.push(this.uiSegmentSrv.newKey(tag.key));
                this.segments.push(this.uiSegmentSrv.newOperator(tag.operator));
                this.segments.push(this.uiSegmentSrv.newKeyValue(tag.value));
            }
        }
        this.segments.push(this.uiSegmentSrv.newPlusButton());
    };
    AdHocFiltersCtrl.prototype.getOptions = function (segment, index) {
        var _this = this;
        if (segment.type === 'operator') {
            return this.$q.when(this.uiSegmentSrv.newOperators(['=', '!=', '<', '>', '=~', '!~']));
        }
        if (segment.type === 'condition') {
            return this.$q.when([this.uiSegmentSrv.newSegment('AND')]);
        }
        return this.datasourceSrv.get(this.variable.datasource).then(function (ds) {
            var options = {};
            var promise = null;
            if (segment.type !== 'value') {
                promise = ds.getTagKeys();
            }
            else {
                options.key = _this.segments[index - 2].value;
                promise = ds.getTagValues(options);
            }
            return promise.then(function (results) {
                results = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.map(results, function (segment) {
                    return _this.uiSegmentSrv.newSegment({ value: segment.text });
                });
                // add remove option for keys
                if (segment.type === 'key') {
                    results.splice(0, 0, __WEBPACK_IMPORTED_MODULE_1_angular___default.a.copy(_this.removeTagFilterSegment));
                }
                return results;
            });
        });
    };
    AdHocFiltersCtrl.prototype.segmentChanged = function (segment, index) {
        this.segments[index] = segment;
        // handle remove tag condition
        if (segment.value === this.removeTagFilterSegment.value) {
            this.segments.splice(index, 3);
            if (this.segments.length === 0) {
                this.segments.push(this.uiSegmentSrv.newPlusButton());
            }
            else if (this.segments.length > 2) {
                this.segments.splice(Math.max(index - 1, 0), 1);
                if (this.segments[this.segments.length - 1].type !== 'plus-button') {
                    this.segments.push(this.uiSegmentSrv.newPlusButton());
                }
            }
        }
        else {
            if (segment.type === 'plus-button') {
                if (index > 2) {
                    this.segments.splice(index, 0, this.uiSegmentSrv.newCondition('AND'));
                }
                this.segments.push(this.uiSegmentSrv.newOperator('='));
                this.segments.push(this.uiSegmentSrv.newFake('select tag value', 'value', 'query-segment-value'));
                segment.type = 'key';
                segment.cssClass = 'query-segment-key';
            }
            if ((index + 1) === this.segments.length) {
                this.segments.push(this.uiSegmentSrv.newPlusButton());
            }
        }
        this.updateVariableModel();
    };
    AdHocFiltersCtrl.prototype.updateVariableModel = function () {
        var filters = [];
        var filterIndex = -1;
        var hasFakes = false;
        this.segments.forEach(function (segment) {
            if (segment.type === 'value' && segment.fake) {
                hasFakes = true;
                return;
            }
            switch (segment.type) {
                case 'key': {
                    filters.push({ key: segment.value });
                    filterIndex += 1;
                    break;
                }
                case 'value': {
                    filters[filterIndex].value = segment.value;
                    break;
                }
                case 'operator': {
                    filters[filterIndex].operator = segment.value;
                    break;
                }
                case 'condition': {
                    filters[filterIndex].condition = segment.value;
                    break;
                }
            }
        });
        if (hasFakes) {
            return;
        }
        this.variable.setFilters(filters);
        this.variableSrv.variableUpdated(this.variable, true);
    };
    return AdHocFiltersCtrl;
}());

var template = "\n<div class=\"gf-form-inline\">\n  <div class=\"gf-form\" ng-repeat=\"segment in ctrl.segments\">\n    <metric-segment segment=\"segment\" get-options=\"ctrl.getOptions(segment, $index)\"\n                    on-change=\"ctrl.segmentChanged(segment, $index)\"></metric-segment>\n  </div>\n</div>\n";
function adHocFiltersComponent() {
    return {
        restrict: 'E',
        template: template,
        controller: AdHocFiltersCtrl,
        bindToController: true,
        controllerAs: 'ctrl',
        scope: {
            variable: "="
        }
    };
}
__WEBPACK_IMPORTED_MODULE_2_app_core_core_module__["default"].directive('adHocFilters', adHocFiltersComponent);


/***/ }),

/***/ 1390:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
dashRowDirective.$inject = ["$rootScope"];
panelWidthDirective.$inject = ["$rootScope"];
panelDropZoneDirective.$inject = ["$timeout"];
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DashRowCtrl", function() { return DashRowCtrl; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_app_core_config__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_app_core_core__ = __webpack_require__(465);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__options__ = __webpack_require__(1391);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__add_panel__ = __webpack_require__(1392);
///<reference path="../../../headers/common.d.ts" />





var DashRowCtrl = /** @class */ (function () {
    /** @ngInject */
    DashRowCtrl.$inject = ["$scope", "$rootScope", "$timeout"];
    function DashRowCtrl($scope, $rootScope, $timeout) {
        this.$scope = $scope;
        this.$rootScope = $rootScope;
        this.$timeout = $timeout;
        this.row.title = this.row.title || 'Row title';
        if (this.row.isNew) {
            this.dropView = 1;
        }
    }
    DashRowCtrl.prototype.onDrop = function (panelId, dropTarget) {
        var _this = this;
        var dragObject;
        // if string it's a panel type
        if (__WEBPACK_IMPORTED_MODULE_0_lodash___default.a.isString(panelId)) {
            // setup new panel
            dragObject = {
                row: this.row,
                panel: {
                    title: __WEBPACK_IMPORTED_MODULE_1_app_core_config__["default"].new_panel_title,
                    type: panelId,
                    id: this.dashboard.getNextPanelId(),
                    isNew: true,
                },
            };
        }
        else {
            dragObject = this.dashboard.getPanelInfoById(panelId);
        }
        if (dropTarget) {
            dropTarget = this.dashboard.getPanelInfoById(dropTarget.id);
            // if draging new panel onto existing panel split it
            if (dragObject.panel.isNew) {
                dragObject.panel.span = dropTarget.panel.span = dropTarget.panel.span / 2;
                // insert after
                dropTarget.row.panels.splice(dropTarget.index + 1, 0, dragObject.panel);
            }
            else if (this.row === dragObject.row) {
                // just move element
                this.row.movePanel(dragObject.index, dropTarget.index);
            }
            else {
                // split drop target space
                dragObject.panel.span = dropTarget.panel.span = dropTarget.panel.span / 2;
                // insert after
                dropTarget.row.panels.splice(dropTarget.index + 1, 0, dragObject.panel);
                // remove from source row
                dragObject.row.removePanel(dragObject.panel, false);
            }
        }
        else {
            dragObject.panel.span = 12 - this.row.span;
            this.row.panels.push(dragObject.panel);
            // if not new remove from source row
            if (!dragObject.panel.isNew) {
                dragObject.row.removePanel(dragObject.panel, false);
            }
        }
        this.dropView = 0;
        this.row.panelSpanChanged();
        this.$timeout(function () {
            _this.$rootScope.$broadcast('render');
        });
    };
    DashRowCtrl.prototype.setHeight = function (height) {
        this.row.height = height;
        this.$scope.$broadcast('render');
    };
    DashRowCtrl.prototype.moveRow = function (direction) {
        var rowsList = this.dashboard.rows;
        var rowIndex = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.indexOf(rowsList, this.row);
        var newIndex = rowIndex + direction;
        if (newIndex >= 0 && newIndex <= (rowsList.length - 1)) {
            __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.move(rowsList, rowIndex, newIndex);
        }
    };
    DashRowCtrl.prototype.toggleCollapse = function () {
        this.closeDropView();
        this.row.collapse = !this.row.collapse;
    };
    DashRowCtrl.prototype.onMenuAddPanel = function () {
        this.dropView = 1;
    };
    DashRowCtrl.prototype.onMenuRowOptions = function () {
        this.dropView = 2;
    };
    DashRowCtrl.prototype.closeDropView = function () {
        this.dropView = 0;
    };
    DashRowCtrl.prototype.onMenuDeleteRow = function () {
        this.dashboard.removeRow(this.row);
    };
    return DashRowCtrl;
}());

/** @ngInject */
function dashRowDirective($rootScope) {
    return {
        restrict: 'E',
        templateUrl: 'public/app/features/dashboard/row/row.html',
        controller: DashRowCtrl,
        bindToController: true,
        controllerAs: 'ctrl',
        scope: {
            dashboard: "=",
            row: "=",
        },
        link: function (scope, element) {
            scope.$watchGroup(['ctrl.row.collapse', 'ctrl.row.height'], function () {
                element.toggleClass('dash-row--collapse', scope.ctrl.row.collapse);
                element.find('.panels-wrapper').css({ minHeight: scope.ctrl.row.collapse ? '5px' : scope.ctrl.row.height });
            });
            $rootScope.onAppEvent('panel-fullscreen-enter', function (evt, info) {
                var hasPanel = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.find(scope.ctrl.row.panels, { id: info.panelId });
                if (!hasPanel) {
                    element.hide();
                }
            }, scope);
            $rootScope.onAppEvent('panel-fullscreen-exit', function () {
                element.show();
            }, scope);
        }
    };
}
/** @ngInject */
function panelWidthDirective($rootScope) {
    return function (scope, element) {
        var fullscreen = false;
        function updateWidth() {
            if (!fullscreen) {
                element[0].style.width = ((scope.panel.span / 1.2) * 10) + '%';
            }
        }
        $rootScope.onAppEvent('panel-fullscreen-enter', function (evt, info) {
            fullscreen = true;
            if (scope.panel.id !== info.panelId) {
                element.hide();
            }
            else {
                element[0].style.width = '100%';
            }
        }, scope);
        $rootScope.onAppEvent('panel-fullscreen-exit', function (evt, info) {
            fullscreen = false;
            if (scope.panel.id !== info.panelId) {
                element.show();
            }
            updateWidth();
        }, scope);
        scope.$watch('panel.span', updateWidth);
        if (fullscreen) {
            element.hide();
        }
    };
}
/** @ngInject */
function panelDropZoneDirective($timeout) {
    return function (scope, element) {
        var row = scope.ctrl.row;
        var indrag = false;
        var textEl = element.find('.panel-drop-zone-text');
        function showPanel(span, text) {
            element.find('.panel-container').css('height', row.height);
            element[0].style.width = ((span / 1.2) * 10) + '%';
            textEl.text(text);
            element.show();
        }
        function hidePanel() {
            element.hide();
        }
        function updateState() {
            if (row.panels.length === 0 && indrag === false) {
                return showPanel(12, 'Empty Space');
            }
            var dropZoneSpan = 12 - row.span;
            if (dropZoneSpan > 0) {
                if (indrag) {
                    return showPanel(dropZoneSpan, 'Drop Here');
                }
                else {
                    return showPanel(dropZoneSpan, 'Empty Space');
                }
            }
            if (indrag === true) {
                if (dropZoneSpan > 1) {
                    return showPanel(dropZoneSpan, 'Drop Here');
                }
            }
            hidePanel();
        }
        row.events.on('span-changed', updateState, scope);
        scope.$on("ANGULAR_DRAG_START", function () {
            indrag = true;
            updateState();
        });
        scope.$on("ANGULAR_DRAG_END", function () {
            indrag = false;
            updateState();
        });
        updateState();
    };
}
__WEBPACK_IMPORTED_MODULE_2_app_core_core__["coreModule"].directive('dashRow', dashRowDirective);
__WEBPACK_IMPORTED_MODULE_2_app_core_core__["coreModule"].directive('panelWidth', panelWidthDirective);
__WEBPACK_IMPORTED_MODULE_2_app_core_core__["coreModule"].directive('panelDropZone', panelDropZoneDirective);


/***/ }),

/***/ 1391:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export RowOptionsCtrl */
/* unused harmony export rowOptionsDirective */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_app_core_core__ = __webpack_require__(465);
///<reference path="../../../headers/common.d.ts" />

// import VirtualScroll from 'virtual-scroll';
// console.log(VirtualScroll);
var RowOptionsCtrl = /** @class */ (function () {
    /** @ngInject */
    function RowOptionsCtrl() {
        this.fontSizes = ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'];
        this.row = this.rowCtrl.row;
        this.dashboard = this.rowCtrl.dashboard;
        this.row.titleSize = this.row.titleSize || 'h6';
    }
    return RowOptionsCtrl;
}());

function rowOptionsDirective() {
    return {
        restrict: 'E',
        templateUrl: 'public/app/features/dashboard/row/options.html',
        controller: RowOptionsCtrl,
        bindToController: true,
        controllerAs: 'ctrl',
        scope: {
            rowCtrl: "=",
        },
    };
}
__WEBPACK_IMPORTED_MODULE_0_app_core_core__["coreModule"].directive('dashRowOptions', rowOptionsDirective);


/***/ }),

/***/ 1392:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export AddPanelCtrl */
/* unused harmony export addPanelDirective */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_app_core_config__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_app_core_core__ = __webpack_require__(465);
///<reference path="../../../headers/common.d.ts" />



var AddPanelCtrl = /** @class */ (function () {
    /** @ngInject */
    AddPanelCtrl.$inject = ["$timeout", "$rootScope"];
    function AddPanelCtrl($timeout, $rootScope) {
        this.$timeout = $timeout;
        this.$rootScope = $rootScope;
        this.row = this.rowCtrl.row;
        this.dashboard = this.rowCtrl.dashboard;
        this.activeIndex = 0;
        this.allPanels = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.chain(__WEBPACK_IMPORTED_MODULE_1_app_core_config__["default"].panels)
            .filter({ hideFromList: false })
            .map(function (item) { return item; })
            .orderBy('sort')
            .value();
        this.panelHits = this.allPanels;
    }
    AddPanelCtrl.prototype.keyDown = function (evt) {
        if (evt.keyCode === 27) {
            this.rowCtrl.dropView = 0;
            return;
        }
        if (evt.keyCode === 40 || evt.keyCode === 39) {
            this.moveSelection(1);
        }
        if (evt.keyCode === 38 || evt.keyCode === 37) {
            this.moveSelection(-1);
        }
        if (evt.keyCode === 13) {
            var selectedPanel = this.panelHits[this.activeIndex];
            if (selectedPanel) {
                this.addPanel(selectedPanel);
            }
        }
    };
    AddPanelCtrl.prototype.moveSelection = function (direction) {
        var max = this.panelHits.length;
        var newIndex = this.activeIndex + direction;
        this.activeIndex = ((newIndex %= max) < 0) ? newIndex + max : newIndex;
    };
    AddPanelCtrl.prototype.panelSearchChanged = function () {
        var items = this.allPanels.slice();
        var startsWith = [];
        var contains = [];
        var searchLower = this.panelSearch.toLowerCase();
        var item;
        while (item = items.shift()) {
            var nameLower = item.name.toLowerCase();
            if (nameLower.indexOf(searchLower) === 0) {
                startsWith.push(item);
            }
            else if (nameLower.indexOf(searchLower) !== -1) {
                contains.push(item);
            }
        }
        this.panelHits = startsWith.concat(contains);
        this.activeIndex = 0;
    };
    AddPanelCtrl.prototype.addPanel = function (panelPluginInfo) {
        var _this = this;
        var defaultSpan = 12;
        var span = 12 - this.row.span;
        var panel = {
            id: null,
            title: __WEBPACK_IMPORTED_MODULE_1_app_core_config__["default"].new_panel_title,
            span: span < defaultSpan && span > 0 ? span : defaultSpan,
            type: panelPluginInfo.id,
        };
        this.rowCtrl.closeDropView();
        this.dashboard.addPanel(panel, this.row);
        this.$timeout(function () {
            _this.$rootScope.$broadcast('render');
            //this.$rootScope.appEvent('panel-change-view', {
            //  fullscreen: true, edit: true, panelId: panel.id
            //});
        });
    };
    return AddPanelCtrl;
}());

function addPanelDirective() {
    return {
        restrict: 'E',
        templateUrl: 'public/app/features/dashboard/row/add_panel.html',
        controller: AddPanelCtrl,
        bindToController: true,
        controllerAs: 'ctrl',
        scope: {
            rowCtrl: "=",
        },
    };
}
__WEBPACK_IMPORTED_MODULE_2_app_core_core__["coreModule"].directive('dashRowAddPanel', addPanelDirective);


/***/ }),

/***/ 1393:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
dashRepeatOptionDirective.$inject = ["variableSrv"];
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_app_core_core__ = __webpack_require__(465);
///<reference path="../../../headers/common.d.ts" />

var template = "\n<div class=\"gf-form-select-wrapper max-width-13\">\n<select class=\"gf-form-input\" ng-model=\"model.repeat\" ng-options=\"f.value as f.text for f in variables\">\n<option value=\"\"></option>\n</div>\n";
/** @ngInject **/
function dashRepeatOptionDirective(variableSrv) {
    return {
        restrict: 'E',
        template: template,
        scope: {
            model: "=",
        },
        link: function (scope, element) {
            element.css({ display: 'block', width: '100%' });
            scope.variables = variableSrv.variables.map(function (item) {
                return { text: item.name, value: item.name };
            });
            if (scope.variables.length === 0) {
                scope.variables.unshift({ text: 'No template variables found', value: null });
            }
            scope.variables.unshift({ text: 'Disabled', value: null });
        }
    };
}
__WEBPACK_IMPORTED_MODULE_0_app_core_core__["coreModule"].directive('dashRepeatOption', dashRepeatOptionDirective);


/***/ }),

/***/ 1394:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
  __webpack_require__(12),
  __webpack_require__(7),
  __webpack_require__(1324),
], __WEBPACK_AMD_DEFINE_RESULT__ = function (angular, _) {
  'use strict';

  angular
    .module('grafana.directives')
    .directive('panelLinksEditor', function() {
      return {
        scope: {
          panel: "="
        },
        restrict: 'E',
        controller: 'PanelLinksEditorCtrl',
        templateUrl: 'public/app/features/panellinks/module.html',
        link: function() {
        }
      };
    }).controller('PanelLinksEditorCtrl', ["$scope", "backendSrv", function($scope, backendSrv) {

      $scope.panel.links = $scope.panel.links || [];

      $scope.addLink = function() {
        $scope.panel.links.push({
          type: 'dashboard',
        });
      };

      $scope.searchDashboards = function(queryStr, callback) {
        backendSrv.search({query: queryStr}).then(function(hits) {
          var dashboards = _.map(hits, function(dash) {
            return dash.title;
          });

          callback(dashboards);
        });
      };

      $scope.dashboardChanged = function(link) {
        backendSrv.search({query: link.dashboard}).then(function(hits) {
          var dashboard = _.find(hits, {title: link.dashboard});
          if (dashboard) {
            link.dashUri = dashboard.uri;
            link.title = dashboard.title;
          }
        });
      };

      $scope.deleteLink = function(link) {
        $scope.panel.links = _.without($scope.panel.links, link);
      };
    }]);
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ 1395:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AnnotationsSrv; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__editor_ctrl__ = __webpack_require__(1396);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_angular__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_angular___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_angular__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_lodash__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_app_core_core_module__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__events_processing__ = __webpack_require__(1397);





var AnnotationsSrv = /** @class */ (function () {
    /** @ngInject */
    AnnotationsSrv.$inject = ["$rootScope", "$q", "datasourceSrv", "backendSrv", "timeSrv"];
    function AnnotationsSrv($rootScope, $q, datasourceSrv, backendSrv, timeSrv) {
        this.$rootScope = $rootScope;
        this.$q = $q;
        this.datasourceSrv = datasourceSrv;
        this.backendSrv = backendSrv;
        this.timeSrv = timeSrv;
        $rootScope.onAppEvent('refresh', this.clearCache.bind(this), $rootScope);
        $rootScope.onAppEvent('dashboard-initialized', this.clearCache.bind(this), $rootScope);
    }
    AnnotationsSrv.prototype.clearCache = function () {
        this.globalAnnotationsPromise = null;
        this.alertStatesPromise = null;
    };
    AnnotationsSrv.prototype.getAnnotations = function (options) {
        var _this = this;
        return this.$q
            .all([this.getGlobalAnnotations(options), this.getAlertStates(options)])
            .then(function (results) {
            // combine the annotations and flatten results
            var annotations = __WEBPACK_IMPORTED_MODULE_2_lodash___default.a.flattenDeep(results[0]);
            // filter out annotations that do not belong to requesting panel
            annotations = __WEBPACK_IMPORTED_MODULE_2_lodash___default.a.filter(annotations, function (item) {
                // if event has panel id and query is of type dashboard then panel and requesting panel id must match
                if (item.panelId && item.source.type === 'dashboard') {
                    return item.panelId === options.panel.id;
                }
                return true;
            });
            annotations = Object(__WEBPACK_IMPORTED_MODULE_4__events_processing__["a" /* dedupAnnotations */])(annotations);
            annotations = Object(__WEBPACK_IMPORTED_MODULE_4__events_processing__["b" /* makeRegions */])(annotations, options);
            // look for alert state for this panel
            var alertState = __WEBPACK_IMPORTED_MODULE_2_lodash___default.a.find(results[1], { panelId: options.panel.id });
            return {
                annotations: annotations,
                alertState: alertState,
            };
        })
            .catch(function (err) {
            if (!err.message && err.data && err.data.message) {
                err.message = err.data.message;
            }
            console.log('AnnotationSrv.query error', err);
            _this.$rootScope.appEvent('alert-error', ['Annotation Query Failed', err.message || err]);
            return [];
        });
    };
    AnnotationsSrv.prototype.getAlertStates = function (options) {
        if (!options.dashboard.id) {
            return this.$q.when([]);
        }
        // ignore if no alerts
        if (options.panel && !options.panel.alert) {
            return this.$q.when([]);
        }
        if (options.range.raw.to !== 'now') {
            return this.$q.when([]);
        }
        if (this.alertStatesPromise) {
            return this.alertStatesPromise;
        }
        this.alertStatesPromise = this.backendSrv.get('/api/alerts/states-for-dashboard', {
            dashboardId: options.dashboard.id,
        });
        return this.alertStatesPromise;
    };
    AnnotationsSrv.prototype.getGlobalAnnotations = function (options) {
        var _this = this;
        var dashboard = options.dashboard;
        if (this.globalAnnotationsPromise) {
            return this.globalAnnotationsPromise;
        }
        var range = this.timeSrv.timeRange();
        var promises = [];
        var _loop_1 = function (annotation) {
            if (!annotation.enable) {
                return "continue";
            }
            if (annotation.snapshotData) {
                return { value: this_1.translateQueryResult(annotation, annotation.snapshotData) };
            }
            promises.push(this_1.datasourceSrv
                .get(annotation.datasource)
                .then(function (datasource) {
                // issue query against data source
                return datasource.annotationQuery({
                    range: range,
                    rangeRaw: range.raw,
                    annotation: annotation,
                    dashboard: dashboard,
                });
            })
                .then(function (results) {
                // store response in annotation object if this is a snapshot call
                if (dashboard.snapshot) {
                    annotation.snapshotData = __WEBPACK_IMPORTED_MODULE_1_angular___default.a.copy(results);
                }
                // translate result
                return _this.translateQueryResult(annotation, results);
            }));
        };
        var this_1 = this;
        for (var _i = 0, _a = dashboard.annotations.list; _i < _a.length; _i++) {
            var annotation = _a[_i];
            var state_1 = _loop_1(annotation);
            if (typeof state_1 === "object")
                return state_1.value;
        }
        this.globalAnnotationsPromise = this.$q.all(promises);
        return this.globalAnnotationsPromise;
    };
    AnnotationsSrv.prototype.saveAnnotationEvent = function (annotation) {
        this.globalAnnotationsPromise = null;
        return this.backendSrv.post('/api/annotations', annotation);
    };
    AnnotationsSrv.prototype.updateAnnotationEvent = function (annotation) {
        this.globalAnnotationsPromise = null;
        return this.backendSrv.put("/api/annotations/" + annotation.id, annotation);
    };
    AnnotationsSrv.prototype.deleteAnnotationEvent = function (annotation) {
        this.globalAnnotationsPromise = null;
        var deleteUrl = "/api/annotations/" + annotation.id;
        if (annotation.isRegion) {
            deleteUrl = "/api/annotations/region/" + annotation.regionId;
        }
        return this.backendSrv.delete(deleteUrl);
    };
    AnnotationsSrv.prototype.translateQueryResult = function (annotation, results) {
        // if annotation has snapshotData
        // make clone and remove it
        if (annotation.snapshotData) {
            annotation = __WEBPACK_IMPORTED_MODULE_1_angular___default.a.copy(annotation);
            delete annotation.snapshotData;
        }
        for (var _i = 0, results_1 = results; _i < results_1.length; _i++) {
            var item = results_1[_i];
            item.source = annotation;
        }
        return results;
    };
    return AnnotationsSrv;
}());

__WEBPACK_IMPORTED_MODULE_3_app_core_core_module__["default"].service('annotationsSrv', AnnotationsSrv);


/***/ }),

/***/ 1396:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export AnnotationsEditorCtrl */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_angular__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_angular___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_angular__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_lodash__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_jquery__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_jquery___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_jquery__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_app_core_core_module__ = __webpack_require__(2);




var AnnotationsEditorCtrl = /** @class */ (function () {
    /** @ngInject */
    AnnotationsEditorCtrl.$inject = ["$scope", "datasourceSrv"];
    function AnnotationsEditorCtrl($scope, datasourceSrv) {
        this.$scope = $scope;
        this.datasourceSrv = datasourceSrv;
        this.annotationDefaults = {
            name: '',
            datasource: null,
            iconColor: 'rgba(255, 96, 96, 1)',
            enable: true,
            showIn: 0,
            hide: false,
        };
        this.showOptions = [
            { text: 'All Panels', value: 0 },
            { text: 'Specific Panels', value: 1 },
        ];
        $scope.ctrl = this;
        this.mode = 'list';
        this.datasources = datasourceSrv.getAnnotationSources();
        this.annotations = $scope.dashboard.annotations.list;
        this.reset();
        this.onColorChange = this.onColorChange.bind(this);
    }
    AnnotationsEditorCtrl.prototype.datasourceChanged = function () {
        var _this = this;
        return this.datasourceSrv.get(this.currentAnnotation.datasource).then(function (ds) {
            _this.currentDatasource = ds;
        });
    };
    AnnotationsEditorCtrl.prototype.edit = function (annotation) {
        this.currentAnnotation = annotation;
        this.currentAnnotation.showIn = this.currentAnnotation.showIn || 0;
        this.currentIsNew = false;
        this.datasourceChanged();
        this.mode = 'edit';
        __WEBPACK_IMPORTED_MODULE_2_jquery___default()(".tooltip.in").remove();
    };
    AnnotationsEditorCtrl.prototype.reset = function () {
        this.currentAnnotation = __WEBPACK_IMPORTED_MODULE_0_angular___default.a.copy(this.annotationDefaults);
        this.currentAnnotation.datasource = this.datasources[0].name;
        this.currentIsNew = true;
        this.datasourceChanged();
    };
    AnnotationsEditorCtrl.prototype.update = function () {
        this.reset();
        this.mode = 'list';
        this.$scope.broadcastRefresh();
    };
    AnnotationsEditorCtrl.prototype.setupNew = function () {
        this.mode = 'new';
        this.reset();
    };
    AnnotationsEditorCtrl.prototype.add = function () {
        this.annotations.push(this.currentAnnotation);
        this.reset();
        this.mode = 'list';
        this.$scope.broadcastRefresh();
        this.$scope.dashboard.updateSubmenuVisibility();
    };
    AnnotationsEditorCtrl.prototype.removeAnnotation = function (annotation) {
        var index = __WEBPACK_IMPORTED_MODULE_1_lodash___default.a.indexOf(this.annotations, annotation);
        this.annotations.splice(index, 1);
        this.$scope.dashboard.updateSubmenuVisibility();
        this.$scope.broadcastRefresh();
    };
    AnnotationsEditorCtrl.prototype.onColorChange = function (newColor) {
        this.currentAnnotation.iconColor = newColor;
    };
    AnnotationsEditorCtrl.prototype.annotationEnabledChange = function () {
        this.$scope.broadcastRefresh();
    };
    AnnotationsEditorCtrl.prototype.annotationHiddenChanged = function () {
        this.$scope.dashboard.updateSubmenuVisibility();
    };
    return AnnotationsEditorCtrl;
}());

__WEBPACK_IMPORTED_MODULE_3_app_core_core_module__["default"].controller('AnnotationsEditorCtrl', AnnotationsEditorCtrl);


/***/ }),

/***/ 1397:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["b"] = makeRegions;
/* harmony export (immutable) */ __webpack_exports__["a"] = dedupAnnotations;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_lodash__);

/**
 * This function converts annotation events into set
 * of single events and regions (event consist of two)
 * @param annotations
 * @param options
 */
function makeRegions(annotations, options) {
    var _a = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.partition(annotations, 'regionId'), regionEvents = _a[0], singleEvents = _a[1];
    var regions = getRegions(regionEvents, options.range);
    annotations = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.concat(regions, singleEvents);
    return annotations;
}
function getRegions(events, range) {
    var region_events = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.filter(events, function (event) {
        return event.regionId;
    });
    var regions = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.groupBy(region_events, 'regionId');
    regions = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.compact(__WEBPACK_IMPORTED_MODULE_0_lodash___default.a.map(regions, function (region_events) {
        var region_obj = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.head(region_events);
        if (region_events && region_events.length > 1) {
            region_obj.timeEnd = region_events[1].time;
            region_obj.isRegion = true;
            return region_obj;
        }
        else {
            if (region_events && region_events.length) {
                // Don't change proper region object
                if (!region_obj.time || !region_obj.timeEnd) {
                    // This is cut region
                    if (isStartOfRegion(region_obj)) {
                        region_obj.timeEnd = range.to.valueOf() - 1;
                    }
                    else {
                        // Start time = null
                        region_obj.timeEnd = region_obj.time;
                        region_obj.time = range.from.valueOf() + 1;
                    }
                    region_obj.isRegion = true;
                }
                return region_obj;
            }
        }
    }));
    return regions;
}
function isStartOfRegion(event) {
    return event.id && event.id === event.regionId;
}
function dedupAnnotations(annotations) {
    var dedup = [];
    // Split events by annotationId property existance
    var events = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.partition(annotations, 'id');
    var eventsById = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.groupBy(events[0], 'id');
    dedup = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.map(eventsById, function (eventGroup) {
        if (eventGroup.length > 1 && !__WEBPACK_IMPORTED_MODULE_0_lodash___default.a.every(eventGroup, isPanelAlert)) {
            // Get first non-panel alert
            return __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.find(eventGroup, function (event) {
                return event.eventType !== 'panel-alert';
            });
        }
        else {
            return __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.head(eventGroup);
        }
    });
    dedup = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.concat(dedup, events[1]);
    return dedup;
}
function isPanelAlert(event) {
    return event.eventType === 'panel-alert';
}


/***/ }),

/***/ 1398:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export EventEditorCtrl */
/* harmony export (immutable) */ __webpack_exports__["a"] = eventEditor;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_moment__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_moment___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_moment__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_app_core_core__ = __webpack_require__(465);



var EventEditorCtrl = /** @class */ (function () {
    /** @ngInject **/
    EventEditorCtrl.$inject = ["annotationsSrv"];
    function EventEditorCtrl(annotationsSrv) {
        this.annotationsSrv = annotationsSrv;
        this.event.panelId = this.panelCtrl.panel.id;
        this.event.dashboardId = this.panelCtrl.dashboard.id;
        // Annotations query returns time as Unix timestamp in milliseconds
        this.event.time = tryEpochToMoment(this.event.time);
        if (this.event.isRegion) {
            this.event.timeEnd = tryEpochToMoment(this.event.timeEnd);
        }
        this.timeFormated = this.panelCtrl.dashboard.formatDate(this.event.time);
    }
    EventEditorCtrl.prototype.save = function () {
        var _this = this;
        if (!this.form.$valid) {
            return;
        }
        var saveModel = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.cloneDeep(this.event);
        saveModel.time = saveModel.time.valueOf();
        saveModel.timeEnd = 0;
        if (saveModel.isRegion) {
            saveModel.timeEnd = this.event.timeEnd.valueOf();
            if (saveModel.timeEnd < saveModel.time) {
                console.log('invalid time');
                return;
            }
        }
        if (saveModel.id) {
            this.annotationsSrv.updateAnnotationEvent(saveModel)
                .then(function () {
                _this.panelCtrl.refresh();
                _this.close();
            })
                .catch(function () {
                _this.panelCtrl.refresh();
                _this.close();
            });
        }
        else {
            this.annotationsSrv.saveAnnotationEvent(saveModel)
                .then(function () {
                _this.panelCtrl.refresh();
                _this.close();
            })
                .catch(function () {
                _this.panelCtrl.refresh();
                _this.close();
            });
        }
    };
    EventEditorCtrl.prototype.delete = function () {
        var _this = this;
        return this.annotationsSrv.deleteAnnotationEvent(this.event)
            .then(function () {
            _this.panelCtrl.refresh();
            _this.close();
        })
            .catch(function () {
            _this.panelCtrl.refresh();
            _this.close();
        });
    };
    return EventEditorCtrl;
}());

function tryEpochToMoment(timestamp) {
    if (timestamp && __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.isNumber(timestamp)) {
        var epoch = Number(timestamp);
        return __WEBPACK_IMPORTED_MODULE_1_moment___default()(epoch);
    }
    else {
        return timestamp;
    }
}
function eventEditor() {
    return {
        restrict: 'E',
        controller: EventEditorCtrl,
        bindToController: true,
        controllerAs: 'ctrl',
        templateUrl: 'public/app/features/annotations/partials/event_editor.html',
        scope: {
            "panelCtrl": "=",
            "event": "=",
            "close": "&",
        }
    };
}
__WEBPACK_IMPORTED_MODULE_2_app_core_core__["coreModule"].directive('eventEditor', eventEditor);


/***/ }),

/***/ 1399:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return EventManager; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_moment__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_moment___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_moment__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_tinycolor2__ = __webpack_require__(128);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_tinycolor2___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_tinycolor2__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__event__ = __webpack_require__(1326);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_app_core_utils_colors__ = __webpack_require__(202);





var EventManager = /** @class */ (function () {
    function EventManager(panelCtrl) {
        this.panelCtrl = panelCtrl;
    }
    EventManager.prototype.editorClosed = function () {
        this.event = null;
        this.editorOpen = false;
        this.panelCtrl.render();
    };
    EventManager.prototype.editorOpened = function () {
        this.editorOpen = true;
    };
    EventManager.prototype.updateTime = function (range) {
        if (!this.event) {
            this.event = new __WEBPACK_IMPORTED_MODULE_3__event__["a" /* AnnotationEvent */]();
            this.event.dashboardId = this.panelCtrl.dashboard.id;
            this.event.panelId = this.panelCtrl.panel.id;
        }
        // update time
        this.event.time = __WEBPACK_IMPORTED_MODULE_1_moment___default()(range.from);
        this.event.isRegion = false;
        if (range.to) {
            this.event.timeEnd = __WEBPACK_IMPORTED_MODULE_1_moment___default()(range.to);
            this.event.isRegion = true;
        }
        this.panelCtrl.render();
    };
    EventManager.prototype.editEvent = function (event, elem) {
        this.event = event;
        this.panelCtrl.render();
    };
    EventManager.prototype.addFlotEvents = function (annotations, flotOptions) {
        if (!this.event && annotations.length === 0) {
            return;
        }
        var types = {
            $__alerting: {
                color: __WEBPACK_IMPORTED_MODULE_4_app_core_utils_colors__["a" /* ALERTING_COLOR */],
                position: 'BOTTOM',
                markerSize: 5,
            },
            $__ok: {
                color: __WEBPACK_IMPORTED_MODULE_4_app_core_utils_colors__["d" /* OK_COLOR */],
                position: 'BOTTOM',
                markerSize: 5,
            },
            $__no_data: {
                color: __WEBPACK_IMPORTED_MODULE_4_app_core_utils_colors__["c" /* NO_DATA_COLOR */],
                position: 'BOTTOM',
                markerSize: 5,
            },
            $__editing: {
                color: __WEBPACK_IMPORTED_MODULE_4_app_core_utils_colors__["b" /* DEFAULT_ANNOTATION_COLOR */],
                position: 'BOTTOM',
                markerSize: 5,
            },
        };
        if (this.event) {
            if (this.event.isRegion) {
                annotations = [
                    {
                        isRegion: true,
                        min: this.event.time.valueOf(),
                        timeEnd: this.event.timeEnd.valueOf(),
                        text: this.event.text,
                        eventType: '$__editing',
                        editModel: this.event,
                    },
                ];
            }
            else {
                annotations = [
                    {
                        min: this.event.time.valueOf(),
                        text: this.event.text,
                        editModel: this.event,
                        eventType: '$__editing',
                    },
                ];
            }
        }
        else {
            // annotations from query
            for (var i = 0; i < annotations.length; i++) {
                var item = annotations[i];
                // add properties used by jquery flot events
                item.min = item.time;
                item.max = item.time;
                item.eventType = item.source.name;
                if (item.newState) {
                    item.eventType = '$__' + item.newState;
                    continue;
                }
                if (!types[item.source.name]) {
                    types[item.source.name] = {
                        color: item.source.iconColor,
                        position: 'BOTTOM',
                        markerSize: 5,
                    };
                }
            }
        }
        var regions = getRegions(annotations);
        addRegionMarking(regions, flotOptions);
        var eventSectionHeight = 20;
        var eventSectionMargin = 7;
        flotOptions.grid.eventSectionHeight = eventSectionMargin;
        flotOptions.xaxis.eventSectionHeight = eventSectionHeight;
        flotOptions.events = {
            levels: __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.keys(types).length + 1,
            data: annotations,
            types: types,
            manager: this,
        };
    };
    return EventManager;
}());

function getRegions(events) {
    return __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.filter(events, 'isRegion');
}
function addRegionMarking(regions, flotOptions) {
    var markings = flotOptions.grid.markings;
    var defaultColor = __WEBPACK_IMPORTED_MODULE_4_app_core_utils_colors__["b" /* DEFAULT_ANNOTATION_COLOR */];
    var fillColor;
    __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.each(regions, function (region) {
        if (region.source) {
            fillColor = region.source.iconColor || defaultColor;
        }
        else {
            fillColor = defaultColor;
        }
        fillColor = addAlphaToRGB(fillColor, __WEBPACK_IMPORTED_MODULE_4_app_core_utils_colors__["e" /* REGION_FILL_ALPHA */]);
        markings.push({ xaxis: { from: region.min, to: region.timeEnd }, color: fillColor });
    });
}
function addAlphaToRGB(colorString, alpha) {
    var color = __WEBPACK_IMPORTED_MODULE_2_tinycolor2___default()(colorString);
    if (color.isValid()) {
        color.setAlpha(alpha);
        return color.toRgbString();
    }
    else {
        return colorString;
    }
}


/***/ }),

/***/ 1400:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ 
annotationTooltipDirective.$inject = ["$sanitize", "dashboardSrv", "contextSrv", "popoverSrv", "$compile"];__webpack_exports__["a"] = annotationTooltipDirective;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_jquery__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_jquery___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_jquery__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_app_core_core_module__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__alerting_alert_def__ = __webpack_require__(1307);




/** @ngInject **/
function annotationTooltipDirective($sanitize, dashboardSrv, contextSrv, popoverSrv, $compile) {
    function sanitizeString(str) {
        try {
            return $sanitize(str);
        }
        catch (err) {
            console.log('Could not sanitize annotation string, html escaping instead');
            return __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.escape(str);
        }
    }
    return {
        restrict: 'E',
        scope: {
            "event": "=",
            "onEdit": "&"
        },
        link: function (scope, element) {
            var event = scope.event;
            var title = event.title;
            var text = event.text;
            var dashboard = dashboardSrv.getCurrent();
            var tooltip = '<div class="graph-annotation">';
            var titleStateClass = '';
            if (event.alertId) {
                var stateModel = __WEBPACK_IMPORTED_MODULE_3__alerting_alert_def__["a" /* default */].getStateDisplayModel(event.newState);
                titleStateClass = stateModel.stateClass;
                title = "<i class=\"icon-gf " + stateModel.iconClass + "\"></i> " + stateModel.text;
                text = __WEBPACK_IMPORTED_MODULE_3__alerting_alert_def__["a" /* default */].getAlertAnnotationInfo(event);
                if (event.text) {
                    text = text + '<br />' + event.text;
                }
            }
            else if (title) {
                text = title + '<br />' + (__WEBPACK_IMPORTED_MODULE_0_lodash___default.a.isString(text) ? text : '');
                title = '';
            }
            var header = "<div class=\"graph-annotation__header\">";
            if (event.login) {
                header += "<div class=\"graph-annotation__user\" bs-tooltip=\"'Created by " + event.login + "'\"><img src=\"" + event.avatarUrl + "\" /></div>";
            }
            header += "\n          <span class=\"graph-annotation__title " + titleStateClass + "\">" + sanitizeString(title) + "</span>\n          <span class=\"graph-annotation__time\">" + dashboard.formatDate(event.min) + "</span>\n      ";
            // Show edit icon only for users with at least Editor role
            if (event.id && contextSrv.isEditor) {
                header += "\n          <span class=\"pointer graph-annotation__edit-icon\" ng-click=\"onEdit()\">\n            <i class=\"fa fa-pencil-square\"></i>\n          </span>\n        ";
            }
            header += "</div>";
            tooltip += header;
            tooltip += '<div class="graph-annotation__body">';
            if (text) {
                tooltip += '<div>' + sanitizeString(text.replace(/\n/g, '<br>')) + '</div>';
            }
            var tags = event.tags;
            if (tags && tags.length) {
                scope.tags = tags;
                tooltip += '<span class="label label-tag small" ng-repeat="tag in tags" tag-color-from-name="tag">{{tag}}</span><br/>';
            }
            tooltip += "</div>";
            tooltip += '</div>';
            var $tooltip = __WEBPACK_IMPORTED_MODULE_1_jquery___default()(tooltip);
            $tooltip.appendTo(element);
            $compile(element.contents())(scope);
        }
    };
}
__WEBPACK_IMPORTED_MODULE_2_app_core_core_module__["default"].directive('annotationTooltip', annotationTooltipDirective);


/***/ }),

/***/ 1401:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__editor_ctrl__ = __webpack_require__(1402);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_app_core_core_module__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__template_srv__ = __webpack_require__(1403);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__variable_srv__ = __webpack_require__(1404);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__interval_variable__ = __webpack_require__(1405);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__query_variable__ = __webpack_require__(1406);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__datasource_variable__ = __webpack_require__(1407);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__custom_variable__ = __webpack_require__(1408);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__constant_variable__ = __webpack_require__(1409);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__adhoc_variable__ = __webpack_require__(1410);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "TemplateSrv", function() { return __WEBPACK_IMPORTED_MODULE_2__template_srv__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "VariableSrv", function() { return __WEBPACK_IMPORTED_MODULE_3__variable_srv__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "IntervalVariable", function() { return __WEBPACK_IMPORTED_MODULE_4__interval_variable__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "QueryVariable", function() { return __WEBPACK_IMPORTED_MODULE_5__query_variable__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "DatasourceVariable", function() { return __WEBPACK_IMPORTED_MODULE_6__datasource_variable__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "CustomVariable", function() { return __WEBPACK_IMPORTED_MODULE_7__custom_variable__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "ConstantVariable", function() { return __WEBPACK_IMPORTED_MODULE_8__constant_variable__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "AdhocVariable", function() { return __WEBPACK_IMPORTED_MODULE_9__adhoc_variable__["a"]; });










__WEBPACK_IMPORTED_MODULE_1_app_core_core_module__["default"].service('templateSrv', __WEBPACK_IMPORTED_MODULE_2__template_srv__["a" /* TemplateSrv */]);



/***/ }),

/***/ 1402:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export VariableEditorCtrl */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_app_core_core_module__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__variable__ = __webpack_require__(1306);
///<reference path="../../headers/common.d.ts" />



var VariableEditorCtrl = /** @class */ (function () {
    /** @ngInject **/
    VariableEditorCtrl.$inject = ["$scope", "datasourceSrv", "variableSrv", "templateSrv"];
    function VariableEditorCtrl($scope, datasourceSrv, variableSrv, templateSrv) {
        $scope.variableTypes = __WEBPACK_IMPORTED_MODULE_2__variable__["variableTypes"];
        $scope.ctrl = {};
        $scope.namePattern = /^(?!__).*$/;
        $scope.refreshOptions = [
            { value: 0, text: "Never" },
            { value: 1, text: "On Dashboard Load" },
            { value: 2, text: "On Time Range Change" },
        ];
        $scope.sortOptions = [
            { value: 0, text: "Disabled" },
            { value: 1, text: "Alphabetical (asc)" },
            { value: 2, text: "Alphabetical (desc)" },
            { value: 3, text: "Numerical (asc)" },
            { value: 4, text: "Numerical (desc)" },
        ];
        $scope.hideOptions = [
            { value: 0, text: "" },
            { value: 1, text: "Label" },
            { value: 2, text: "Variable" },
        ];
        $scope.init = function () {
            $scope.mode = 'list';
            $scope.variables = variableSrv.variables;
            //alert($scope.variables);
            $scope.reset();
            $scope.$watch('mode', function (val) {
                if (val === 'new') {
                    $scope.reset();
                }
            });
        };
        $scope.add = function () {
            if ($scope.isValid()) {
                variableSrv.addVariable($scope.current);
                $scope.update();
            }
        };
        $scope.isValid = function () {
            if (!$scope.ctrl.form.$valid) {
                return false;
            }
            if (!$scope.current.name.match(/^\w+$/)) {
                $scope.appEvent('alert-warning', ['Validation', 'Only word and digit characters are allowed in variable names']);
                return false;
            }
            var sameName = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.find($scope.variables, { name: $scope.current.name });
            if (sameName && sameName !== $scope.current) {
                $scope.appEvent('alert-warning', ['Validation', 'Variable with the same name already exists']);
                return false;
            }
            if ($scope.current.type === 'query' && $scope.current.query.match(new RegExp('\\$' + $scope.current.name + '(/| |$)'))) {
                $scope.appEvent('alert-warning', ['Validation', 'Query cannot contain a reference to itself. Variable: $' + $scope.current.name]);
                return false;
            }
            return true;
        };
        $scope.validate = function () {
            $scope.infoText = '';
            if ($scope.current.type === 'adhoc' && $scope.current.datasource !== null) {
                $scope.infoText = 'Adhoc filters are applied automatically to all queries that target this datasource';
                datasourceSrv.get($scope.current.datasource).then(function (ds) {
                    if (!ds.getTagKeys) {
                        $scope.infoText = 'This datasource does not support adhoc filters yet.';
                    }
                });
            }
        };
        $scope.runQuery = function () {
            return variableSrv.updateOptions($scope.current).then(function () {
                //console.info($scope.current.options);
            }, function (err) {
                if (err.data && err.data.message) {
                    err.message = err.data.message;
                }
                $scope.appEvent("alert-error", ['Templating', 'Template variables could not be initialized: ' + err.message]);
            });
        };
        $scope.edit = function (variable) {
            $scope.current = variable;
            $scope.currentIsNew = false;
            $scope.mode = 'edit';
            $scope.validate();
        };
        $scope.duplicate = function (variable) {
            var clone = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.cloneDeep(variable.getSaveModel());
            $scope.current = variableSrv.createVariableFromModel(clone);
            $scope.current.name = 'copy_of_' + variable.name;
            variableSrv.addVariable($scope.current);
        };
        $scope.update = function () {
            if ($scope.isValid()) {
                $scope.runQuery().then(function () {
                    $scope.reset();
                    $scope.mode = 'list';
                    templateSrv.updateTemplateData();
                });
            }
        };
        $scope.reset = function () {
            $scope.currentIsNew = true;
            $scope.current = variableSrv.createVariableFromModel({ type: 'query' });
            // this is done here in case a new data source type variable was added
            $scope.datasources = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.filter(datasourceSrv.getMetricSources(), function (ds) {
                return !ds.meta.mixed && ds.value !== null;
            });
            $scope.datasourceTypes = __WEBPACK_IMPORTED_MODULE_0_lodash___default()($scope.datasources).uniqBy('meta.id').map(function (ds) {
                return { text: ds.meta.name, value: ds.meta.id };
            }).value();
        };
        $scope.typeChanged = function () {
            var old = $scope.current;
            $scope.current = variableSrv.createVariableFromModel({ type: $scope.current.type });
            $scope.current.name = old.name;
            $scope.current.hide = old.hide;
            $scope.current.label = old.label;
            var oldIndex = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.indexOf(this.variables, old);
            if (oldIndex !== -1) {
                this.variables[oldIndex] = $scope.current;
            }
            $scope.validate();
        };
        $scope.removeVariable = function (variable) {
            variableSrv.removeVariable(variable);
        };
    }
    return VariableEditorCtrl;
}());

__WEBPACK_IMPORTED_MODULE_1_app_core_core_module__["default"].controller('VariableEditorCtrl', VariableEditorCtrl);


/***/ }),

/***/ 1403:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return TemplateSrv; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_app_core_utils_kbn__ = __webpack_require__(464);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_lodash__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_lodash__);


function luceneEscape(value) {
    return value.replace(/([\!\*\+\-\=<>\s\&\|\(\)\[\]\{\}\^\~\?\:\\/"])/g, "\\$1");
}
var TemplateSrv = /** @class */ (function () {
    function TemplateSrv() {
        this.regex = /\$(\w+)|\[\[([\s\S]+?)\]\]/g;
        this.index = {};
        this.grafanaVariables = {};
        this.builtIns = {};
        this.filters = {};
        this.builtIns['__interval'] = { text: '1s', value: '1s' };
        this.builtIns['__interval_ms'] = { text: '100', value: '100' };
    }
    TemplateSrv.prototype.init = function (variables) {
        this.variables = variables;
        this.updateTemplateData();
    };
    TemplateSrv.prototype.updateTemplateData = function () {
        this.index = {};
        this.filters = {};
        for (var i = 0; i < this.variables.length; i++) {
            var variable = this.variables[i];
            if (!variable.current || !variable.current.isNone && !variable.current.value) {
                continue;
            }
            this.index[variable.name] = variable;
        }
    };
    TemplateSrv.prototype.variableInitialized = function (variable) {
        this.index[variable.name] = variable;
    };
    TemplateSrv.prototype.getAdhocFilters = function (datasourceName) {
        var filters = [];
        for (var i = 0; i < this.variables.length; i++) {
            var variable = this.variables[i];
            if (variable.type !== 'adhoc') {
                continue;
            }
            if (variable.datasource === datasourceName) {
                filters = filters.concat(variable.filters);
            }
            if (variable.datasource.indexOf('$') === 0) {
                if (this.replace(variable.datasource) === datasourceName) {
                    filters = filters.concat(variable.filters);
                }
            }
        }
        return filters;
    };
    TemplateSrv.prototype.luceneFormat = function (value) {
        if (typeof value === 'string') {
            return luceneEscape(value);
        }
        var quotedValues = __WEBPACK_IMPORTED_MODULE_1_lodash___default.a.map(value, function (val) {
            return '\"' + luceneEscape(val) + '\"';
        });
        return '(' + quotedValues.join(' OR ') + ')';
    };
    TemplateSrv.prototype.formatValue = function (value, format, variable) {
        // for some scopedVars there is no variable
        variable = variable || {};
        if (typeof format === 'function') {
            return format(value, variable, this.formatValue);
        }
        switch (format) {
            case "regex": {
                if (typeof value === 'string') {
                    return __WEBPACK_IMPORTED_MODULE_0_app_core_utils_kbn__["default"].regexEscape(value);
                }
                var escapedValues = __WEBPACK_IMPORTED_MODULE_1_lodash___default.a.map(value, __WEBPACK_IMPORTED_MODULE_0_app_core_utils_kbn__["default"].regexEscape);
                return '(' + escapedValues.join('|') + ')';
            }
            case "lucene": {
                return this.luceneFormat(value);
            }
            case "pipe": {
                if (typeof value === 'string') {
                    return value;
                }
                return value.join('|');
            }
            case "distributed": {
                if (typeof value === 'string') {
                    return value;
                }
                return this.distributeVariable(value, variable.name);
            }
            default: {
                if (__WEBPACK_IMPORTED_MODULE_1_lodash___default.a.isArray(value)) {
                    return '{' + value.join(',') + '}';
                }
                return value;
            }
        }
    };
    TemplateSrv.prototype.setGrafanaVariable = function (name, value) {
        this.grafanaVariables[name] = value;
    };
    TemplateSrv.prototype.getVariableName = function (expression) {
        this.regex.lastIndex = 0;
        var match = this.regex.exec(expression);
        if (!match) {
            return null;
        }
        return match[1] || match[2];
    };
    TemplateSrv.prototype.variableExists = function (expression) {
        var name = this.getVariableName(expression);
        return name && (this.index[name] !== void 0);
    };
    TemplateSrv.prototype.highlightVariablesAsHtml = function (str) {
        var _this = this;
        if (!str || !__WEBPACK_IMPORTED_MODULE_1_lodash___default.a.isString(str)) {
            return str;
        }
        str = __WEBPACK_IMPORTED_MODULE_1_lodash___default.a.escape(str);
        this.regex.lastIndex = 0;
        return str.replace(this.regex, function (match, g1, g2) {
            if (_this.index[g1 || g2] || _this.builtIns[g1 || g2]) {
                return '<span class="template-variable">' + match + '</span>';
            }
            return match;
        });
    };
    TemplateSrv.prototype.getAllValue = function (variable) {
        if (variable.allValue) {
            return variable.allValue;
        }
        var values = [];
        for (var i = 1; i < variable.options.length; i++) {
            values.push(variable.options[i].value);
        }
        return values;
    };
    TemplateSrv.prototype.replace = function (target, scopedVars, format) {
        var _this = this;
        if (!target) {
            return target;
        }
        var variable, systemValue, value;
        this.regex.lastIndex = 0;
        return target.replace(this.regex, function (match, g1, g2) {
            variable = _this.index[g1 || g2];
            if (scopedVars) {
                value = scopedVars[g1 || g2];
                if (value) {
                    return _this.formatValue(value.value, format, variable);
                }
            }
            if (!variable) {
                return match;
            }
            systemValue = _this.grafanaVariables[variable.current.value];
            if (systemValue) {
                return _this.formatValue(systemValue, format, variable);
            }
            value = variable.current.value;
            if (_this.isAllValue(value)) {
                value = _this.getAllValue(variable);
                // skip formating of custom all values
                if (variable.allValue) {
                    return value;
                }
            }
            var res = _this.formatValue(value, format, variable);
            return res;
        });
    };
    TemplateSrv.prototype.isAllValue = function (value) {
        return value === '$__all' || Array.isArray(value) && value[0] === '$__all';
    };
    TemplateSrv.prototype.replaceWithText = function (target, scopedVars) {
        var _this = this;
        if (!target) {
            return target;
        }
        var variable;
        this.regex.lastIndex = 0;
        return target.replace(this.regex, function (match, g1, g2) {
            if (scopedVars) {
                var option = scopedVars[g1 || g2];
                if (option) {
                    return option.text;
                }
            }
            variable = _this.index[g1 || g2];
            if (!variable) {
                return match;
            }
            return _this.grafanaVariables[variable.current.value] || variable.current.text;
        });
    };
    TemplateSrv.prototype.fillVariableValuesForUrl = function (params, scopedVars) {
        __WEBPACK_IMPORTED_MODULE_1_lodash___default.a.each(this.variables, function (variable) {
            if (scopedVars && scopedVars[variable.name] !== void 0) {
                params['var-' + variable.name] = scopedVars[variable.name].value;
            }
            else {
                params['var-' + variable.name] = variable.getValueForUrl();
            }
        });
    };
    TemplateSrv.prototype.distributeVariable = function (value, variable) {
        value = __WEBPACK_IMPORTED_MODULE_1_lodash___default.a.map(value, function (val, index) {
            if (index !== 0) {
                return variable + "=" + val;
            }
            else {
                return val;
            }
        });
        return value.join(',');
    };
    return TemplateSrv;
}());



/***/ }),

/***/ 1404:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return VariableSrv; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_angular__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_angular___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_angular__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_lodash__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_app_core_core_module__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__variable__ = __webpack_require__(1306);
///<reference path="../../headers/common.d.ts" />




var VariableSrv = /** @class */ (function () {
    /** @ngInject */
    VariableSrv.$inject = ["$rootScope", "$q", "$location", "$injector", "templateSrv"];
    function VariableSrv($rootScope, $q, $location, $injector, templateSrv) {
        this.$rootScope = $rootScope;
        this.$q = $q;
        this.$location = $location;
        this.$injector = $injector;
        this.templateSrv = templateSrv;
        // update time variant variables
        $rootScope.$on('refresh', this.onDashboardRefresh.bind(this), $rootScope);
        $rootScope.$on('template-variable-value-updated', this.updateUrlParamsWithCurrentVariables.bind(this), $rootScope);
    }
    VariableSrv.prototype.init = function (dashboard) {
        var _this = this;
        this.dashboard = dashboard;
        // create working class models representing variables
        this.variables = dashboard.templating.list = dashboard.templating.list.map(this.createVariableFromModel.bind(this));
        this.templateSrv.init(this.variables);
        // init variables
        for (var _i = 0, _a = this.variables; _i < _a.length; _i++) {
            var variable = _a[_i];
            variable.initLock = this.$q.defer();
        }
        var queryParams = this.$location.search();
        return this.$q.all(this.variables.map(function (variable) {
            return _this.processVariable(variable, queryParams);
        })).then(function () {
            _this.templateSrv.updateTemplateData();
        });
    };
    VariableSrv.prototype.onDashboardRefresh = function () {
        var _this = this;
        var promises = this.variables
            .filter(function (variable) { return variable.refresh === 2; })
            .map(function (variable) {
            var previousOptions = variable.options.slice();
            return variable.updateOptions()
                .then(function () {
                if (__WEBPACK_IMPORTED_MODULE_0_angular___default.a.toJson(previousOptions) !== __WEBPACK_IMPORTED_MODULE_0_angular___default.a.toJson(variable.options)) {
                    _this.$rootScope.$emit('template-variable-value-updated');
                }
            });
        });
        return this.$q.all(promises);
    };
    VariableSrv.prototype.processVariable = function (variable, queryParams) {
        var _this = this;
        var dependencies = [];
        for (var _i = 0, _a = this.variables; _i < _a.length; _i++) {
            var otherVariable = _a[_i];
            if (variable.dependsOn(otherVariable)) {
                dependencies.push(otherVariable.initLock.promise);
            }
        }
        return this.$q.all(dependencies).then(function () {
            var urlValue = queryParams['var-' + variable.name];
            if (urlValue !== void 0) {
                return variable.setValueFromUrl(urlValue).then(variable.initLock.resolve);
            }
            if (variable.refresh === 1 || variable.refresh === 2) {
                return variable.updateOptions().then(variable.initLock.resolve);
            }
            variable.initLock.resolve();
        }).finally(function () {
            _this.templateSrv.variableInitialized(variable);
            delete variable.initLock;
        });
    };
    VariableSrv.prototype.createVariableFromModel = function (model) {
        var ctor = __WEBPACK_IMPORTED_MODULE_3__variable__["variableTypes"][model.type].ctor;
        if (!ctor) {
            throw { message: "Unable to find variable constructor for " + model.type };
        }
        var variable = this.$injector.instantiate(ctor, { model: model });
        return variable;
    };
    VariableSrv.prototype.addVariable = function (variable) {
        this.variables.push(variable);
        this.templateSrv.updateTemplateData();
        this.dashboard.updateSubmenuVisibility();
    };
    VariableSrv.prototype.removeVariable = function (variable) {
        var index = __WEBPACK_IMPORTED_MODULE_1_lodash___default.a.indexOf(this.variables, variable);
        this.variables.splice(index, 1);
        this.templateSrv.updateTemplateData();
        this.dashboard.updateSubmenuVisibility();
    };
    VariableSrv.prototype.updateOptions = function (variable) {
        return variable.updateOptions();
    };
    VariableSrv.prototype.variableUpdated = function (variable, emitChangeEvents) {
        var _this = this;
        // if there is a variable lock ignore cascading update because we are in a boot up scenario
        if (variable.initLock) {
            return this.$q.when();
        }
        // cascade updates to variables that use this variable
        var promises = __WEBPACK_IMPORTED_MODULE_1_lodash___default.a.map(this.variables, function (otherVariable) {
            if (otherVariable === variable) {
                return;
            }
            if (otherVariable.dependsOn(variable)) {
                return _this.updateOptions(otherVariable);
            }
        });
        return this.$q.all(promises).then(function () {
            if (emitChangeEvents) {
                _this.$rootScope.$emit('template-variable-value-updated');
                _this.$rootScope.$broadcast('refresh');
            }
        });
    };
    VariableSrv.prototype.selectOptionsForCurrentValue = function (variable) {
        var i, y, value, option;
        var selected = [];
        //console.info(variable.options);
        for (i = 0; i < variable.options.length; i++) {
            option = variable.options[i];
            option.selected = false;
            if (__WEBPACK_IMPORTED_MODULE_1_lodash___default.a.isArray(variable.current.value)) {
                for (y = 0; y < variable.current.value.length; y++) {
                    value = variable.current.value[y];
                    if (option.value === value) {
                        option.selected = true;
                        selected.push(option);
                    }
                }
            }
            else if (option.value === variable.current.value) {
                option.selected = true;
                selected.push(option);
            }
        }
        return selected;
    };
    VariableSrv.prototype.validateVariableSelectionState = function (variable) {
        if (!variable.current) {
            variable.current = {};
        }
        //console.info(variable.options);
        if (__WEBPACK_IMPORTED_MODULE_1_lodash___default.a.isArray(variable.current.value)) {
            var selected = this.selectOptionsForCurrentValue(variable);
            // if none pick first
            if (selected.length === 0) {
                selected = variable.options[0];
            }
            else {
                selected = {
                    value: __WEBPACK_IMPORTED_MODULE_1_lodash___default.a.map(selected, function (val) { return val.value; }),
                    text: __WEBPACK_IMPORTED_MODULE_1_lodash___default.a.map(selected, function (val) { return val.text; }).join(' + '),
                };
            }
            return variable.setValue(selected);
        }
        else {
            var currentOption = __WEBPACK_IMPORTED_MODULE_1_lodash___default.a.find(variable.options, { text: variable.current.text });
            if (currentOption) {
                return variable.setValue(currentOption);
            }
            else {
                if (!variable.options.length) {
                    return Promise.resolve();
                }
                return variable.setValue(variable.options[0]);
            }
        }
    };
    VariableSrv.prototype.setOptionFromUrl = function (variable, urlValue) {
        var promise = this.$q.when();
        if (variable.refresh) {
            promise = variable.updateOptions();
        }
        return promise.then(function () {
            var option = __WEBPACK_IMPORTED_MODULE_1_lodash___default.a.find(variable.options, function (op) {
                return op.text === urlValue || op.value === urlValue;
            });
            option = option || { text: urlValue, value: urlValue };
            return variable.setValue(option);
        });
    };
    VariableSrv.prototype.setOptionAsCurrent = function (variable, option) {
        variable.current = __WEBPACK_IMPORTED_MODULE_1_lodash___default.a.cloneDeep(option);
        if (__WEBPACK_IMPORTED_MODULE_1_lodash___default.a.isArray(variable.current.text)) {
            variable.current.text = variable.current.text.join(' + ');
        }
        this.selectOptionsForCurrentValue(variable);
        return this.variableUpdated(variable);
    };
    VariableSrv.prototype.updateUrlParamsWithCurrentVariables = function () {
        // update url
        var params = this.$location.search();
        // remove variable params
        __WEBPACK_IMPORTED_MODULE_1_lodash___default.a.each(params, function (value, key) {
            if (key.indexOf('var-') === 0) {
                delete params[key];
            }
        });
        // add new values
        this.templateSrv.fillVariableValuesForUrl(params);
        // update url
        this.$location.search(params);
    };
    VariableSrv.prototype.setAdhocFilter = function (options) {
        var variable = __WEBPACK_IMPORTED_MODULE_1_lodash___default.a.find(this.variables, { type: 'adhoc', datasource: options.datasource });
        if (!variable) {
            variable = this.createVariableFromModel({ name: 'Filters', type: 'adhoc', datasource: options.datasource });
            this.addVariable(variable);
        }
        var filters = variable.filters;
        var filter = __WEBPACK_IMPORTED_MODULE_1_lodash___default.a.find(filters, { key: options.key, value: options.value });
        if (!filter) {
            filter = { key: options.key, value: options.value };
            filters.push(filter);
        }
        filter.operator = options.operator;
        this.variableUpdated(variable, true);
    };
    return VariableSrv;
}());

__WEBPACK_IMPORTED_MODULE_2_app_core_core_module__["default"].service('variableSrv', VariableSrv);


/***/ }),

/***/ 1405:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return IntervalVariable; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_app_core_utils_kbn__ = __webpack_require__(464);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__variable__ = __webpack_require__(1306);
///<reference path="../../headers/common.d.ts" />



var IntervalVariable = /** @class */ (function () {
    /** @ngInject **/
    IntervalVariable.$inject = ["model", "timeSrv", "templateSrv", "variableSrv"];
    function IntervalVariable(model, timeSrv, templateSrv, variableSrv) {
        this.model = model;
        this.timeSrv = timeSrv;
        this.templateSrv = templateSrv;
        this.variableSrv = variableSrv;
        this.defaults = {
            type: 'interval',
            name: '',
            hide: 0,
            label: '',
            refresh: 2,
            options: [],
            current: {},
            query: '1m,10m,30m,1h,6h,12h,1d,7d,14d,30d',
            auto: false,
            auto_min: '10s',
            auto_count: 30,
        };
        Object(__WEBPACK_IMPORTED_MODULE_2__variable__["assignModelProperties"])(this, model, this.defaults);
        this.refresh = 2;
    }
    IntervalVariable.prototype.getSaveModel = function () {
        Object(__WEBPACK_IMPORTED_MODULE_2__variable__["assignModelProperties"])(this.model, this, this.defaults);
        return this.model;
    };
    IntervalVariable.prototype.setValue = function (option) {
        this.updateAutoValue();
        return this.variableSrv.setOptionAsCurrent(this, option);
    };
    IntervalVariable.prototype.updateAutoValue = function () {
        if (!this.auto) {
            return;
        }
        // add auto option if missing
        if (this.options.length && this.options[0].text !== 'auto') {
            this.options.unshift({ text: 'auto', value: '$__auto_interval_' + this.name });
        }
        var res = __WEBPACK_IMPORTED_MODULE_1_app_core_utils_kbn__["default"].calculateInterval(this.timeSrv.timeRange(), this.auto_count, this.auto_min);
        this.templateSrv.setGrafanaVariable('$__auto_interval_' + this.name, res.interval);
        // for backward compatibility, to be removed eventually
        this.templateSrv.setGrafanaVariable('$__auto_interval', res.interval);
    };
    IntervalVariable.prototype.updateOptions = function () {
        // extract options between quotes and/or comma
        this.options = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.map(this.query.match(/(["'])(.*?)\1|\w+/g), function (text) {
            text = text.replace(/["']+/g, '');
            return { text: text.trim(), value: text.trim() };
        });
        this.updateAutoValue();
        return this.variableSrv.validateVariableSelectionState(this);
    };
    IntervalVariable.prototype.dependsOn = function (variable) {
        return false;
    };
    IntervalVariable.prototype.setValueFromUrl = function (urlValue) {
        this.updateAutoValue();
        return this.variableSrv.setOptionFromUrl(this, urlValue);
    };
    IntervalVariable.prototype.getValueForUrl = function () {
        return this.current.value;
    };
    return IntervalVariable;
}());

__WEBPACK_IMPORTED_MODULE_2__variable__["variableTypes"]['interval'] = {
    name: 'Interval',
    ctor: IntervalVariable,
    description: 'Define a timespan interval (ex 1m, 1h, 1d)',
};


/***/ }),

/***/ 1406:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return QueryVariable; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_app_core_utils_kbn__ = __webpack_require__(464);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__variable__ = __webpack_require__(1306);



function getNoneOption() {
    return { text: 'None', value: '', isNone: true };
}
var QueryVariable = /** @class */ (function () {
    /** @ngInject **/
    QueryVariable.$inject = ["model", "datasourceSrv", "templateSrv", "variableSrv", "backendSrv", "timeSrv"];
    function QueryVariable(model, datasourceSrv, templateSrv, variableSrv, backendSrv, timeSrv) {
        this.model = model;
        this.datasourceSrv = datasourceSrv;
        this.templateSrv = templateSrv;
        this.variableSrv = variableSrv;
        this.backendSrv = backendSrv;
        this.timeSrv = timeSrv;
        this.defaults = {
            type: 'query',
            label: null,
            query: '',
            regex: '',
            sort: 0,
            datasource: null,
            refresh: 0,
            hide: 0,
            name: '',
            multi: false,
            includeAll: false,
            allValue: null,
            options: [],
            current: {},
            tags: [],
            useTags: false,
            tagsQuery: "",
            tagValuesQuery: "",
        };
        // copy model properties to this instance
        Object(__WEBPACK_IMPORTED_MODULE_2__variable__["assignModelProperties"])(this, model, this.defaults);
        var instance = this;
        /*window.$.ajax({
          url : 'http://61.164.218.158:8080/DataCenter/manager/manager_device_listall.action',
          //'http://192.168.3.65:8080/DataCenter/manager/manager_device_listall.action',
          type : "post",
          dataType : "jsonp",
          crossDomain: true,
          /*data:{'callback':5},
          jsonp: "callback",
          jsonpCallback:"message",
          data:{'callback':'message'},ju
          success : function(data)
          {
              instance.cnData=data;
          }
        });*/
        var res = backendSrv.get('http://61.164.218.158:8080/AirServer/site/findAllSites')
            .then(function (resp) {
            //console.info(resp);
            instance.cnData = resp;
        }, function (resp) {
            console.info(resp);
        });
        //console.info('startaaa11');
    }
    QueryVariable.prototype.getSaveModel = function () {
        // copy back model properties to model
        Object(__WEBPACK_IMPORTED_MODULE_2__variable__["assignModelProperties"])(this.model, this, this.defaults);
        // remove options
        if (this.refresh !== 0) {
            this.model.options = [];
        }
        return this.model;
    };
    QueryVariable.prototype.setValue = function (option) {
        return this.variableSrv.setOptionAsCurrent(this, option);
    };
    QueryVariable.prototype.setValueFromUrl = function (urlValue) {
        return this.variableSrv.setOptionFromUrl(this, urlValue);
    };
    QueryVariable.prototype.getValueForUrl = function () {
        if (this.current.text === 'All') {
            return 'All';
        }
        return this.current.value;
    };
    QueryVariable.prototype.updateOptions = function () {
        return this.datasourceSrv.get(this.datasource)
            .then(this.updateOptionsFromMetricFindQuery.bind(this))
            .then(this.updateTags.bind(this))
            .then(this.variableSrv.validateVariableSelectionState.bind(this.variableSrv, this));
    };
    QueryVariable.prototype.updateTags = function (datasource) {
        var _this = this;
        if (this.useTags) {
            return this.metricFindQuery(datasource, this.tagsQuery).then(function (results) {
                _this.tags = [];
                for (var i = 0; i < results.length; i++) {
                    _this.tags.push(results[i].text);
                }
                return datasource;
            });
        }
        else {
            delete this.tags;
        }
        return datasource;
    };
    QueryVariable.prototype.getValuesForTag = function (tagKey) {
        var _this = this;
        return this.datasourceSrv.get(this.datasource).then(function (datasource) {
            var query = _this.tagValuesQuery.replace('$tag', tagKey);
            return _this.metricFindQuery(datasource, query).then(function (results) {
                return __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.map(results, function (value) {
                    return value.text;
                });
            });
        });
    };
    QueryVariable.prototype.updateOptionsFromMetricFindQuery = function (datasource) {
        var _this = this;
        return this.metricFindQuery(datasource, this.query).then(function (results) {
            //console.info(results);
            _this.options = _this.metricNamesToVariableValues(results);
            //console.info(this.options);
            if (_this.includeAll) {
                _this.addAllOption();
            }
            if (!_this.options.length) {
                _this.options.push(getNoneOption());
            }
            return datasource;
        });
    };
    QueryVariable.prototype.metricFindQuery = function (datasource, query) {
        var options = { range: undefined, variable: this };
        if (this.refresh === 2) {
            options.range = this.timeSrv.timeRange();
        }
        return datasource.metricFindQuery(query, options);
    };
    QueryVariable.prototype.addAllOption = function () {
        this.options.unshift({ text: 'All', value: "$__all", cn: '' });
    };
    QueryVariable.prototype.metricNamesToVariableValues = function (metricNames) {
        //alert(metricNames);
        var regex, options, i, matches;
        options = [];
        if (this.regex) {
            regex = __WEBPACK_IMPORTED_MODULE_1_app_core_utils_kbn__["default"].stringToJsRegex(this.templateSrv.replace(this.regex, {}, 'regex'));
        }
        for (i = 0; i < metricNames.length; i++) {
            var item = metricNames[i];
            var text = item.text === undefined || item.text === null
                ? item.value
                : item.text;
            var value = item.value === undefined || item.value === null
                ? item.text
                : item.value;
            if (__WEBPACK_IMPORTED_MODULE_0_lodash___default.a.isNumber(value)) {
                value = value.toString();
            }
            if (__WEBPACK_IMPORTED_MODULE_0_lodash___default.a.isNumber(text)) {
                text = text.toString();
            }
            if (regex) {
                matches = regex.exec(value);
                if (!matches) {
                    continue;
                }
                if (matches.length > 1) {
                    value = matches[1];
                    text = matches[1];
                }
            }
            options.push({ text: text, value: value, cn: item.cn });
        }
        options = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.uniqBy(options, 'value');
        return this.sortVariableValues(options, this.sort);
    };
    QueryVariable.prototype.sortVariableValues = function (options, sortOrder) {
        if (sortOrder === 0) {
            return options;
        }
        var sortType = Math.ceil(sortOrder / 2);
        var reverseSort = (sortOrder % 2 === 0);
        if (sortType === 1) {
            options = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.sortBy(options, 'text');
        }
        else if (sortType === 2) {
            options = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.sortBy(options, function (opt) {
                var matches = opt.text.match(/.*?(\d+).*/);
                if (!matches || matches.length < 2) {
                    return -1;
                }
                else {
                    return parseInt(matches[1], 10);
                }
            });
        }
        if (reverseSort) {
            options = options.reverse();
        }
        return options;
    };
    QueryVariable.prototype.dependsOn = function (variable) {
        return Object(__WEBPACK_IMPORTED_MODULE_2__variable__["containsVariable"])(this.query, this.datasource, variable.name);
    };
    return QueryVariable;
}());

__WEBPACK_IMPORTED_MODULE_2__variable__["variableTypes"]['query'] = {
    name: 'Query',
    ctor: QueryVariable,
    description: 'Variable values are fetched from a datasource query',
    supportsMulti: true,
};


/***/ }),

/***/ 1407:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return DatasourceVariable; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_app_core_utils_kbn__ = __webpack_require__(464);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__variable__ = __webpack_require__(1306);
///<reference path="../../headers/common.d.ts" />


var DatasourceVariable = /** @class */ (function () {
    /** @ngInject **/
    DatasourceVariable.$inject = ["model", "datasourceSrv", "variableSrv", "templateSrv"];
    function DatasourceVariable(model, datasourceSrv, variableSrv, templateSrv) {
        this.model = model;
        this.datasourceSrv = datasourceSrv;
        this.variableSrv = variableSrv;
        this.templateSrv = templateSrv;
        this.defaults = {
            type: 'datasource',
            name: '',
            hide: 0,
            label: '',
            current: {},
            regex: '',
            options: [],
            query: '',
            refresh: 1,
        };
        Object(__WEBPACK_IMPORTED_MODULE_1__variable__["assignModelProperties"])(this, model, this.defaults);
        this.refresh = 1;
    }
    DatasourceVariable.prototype.getSaveModel = function () {
        Object(__WEBPACK_IMPORTED_MODULE_1__variable__["assignModelProperties"])(this.model, this, this.defaults);
        // dont persist options
        this.model.options = [];
        return this.model;
    };
    DatasourceVariable.prototype.setValue = function (option) {
        return this.variableSrv.setOptionAsCurrent(this, option);
    };
    DatasourceVariable.prototype.updateOptions = function () {
        var options = [];
        var sources = this.datasourceSrv.getMetricSources({ skipVariables: true });
        var regex;
        if (this.regex) {
            regex = this.templateSrv.replace(this.regex, null, 'regex');
            regex = __WEBPACK_IMPORTED_MODULE_0_app_core_utils_kbn__["default"].stringToJsRegex(regex);
        }
        for (var i = 0; i < sources.length; i++) {
            var source = sources[i];
            // must match on type
            if (source.meta.id !== this.query) {
                continue;
            }
            if (regex && !regex.exec(source.name)) {
                continue;
            }
            options.push({ text: source.name, value: source.name });
        }
        if (options.length === 0) {
            options.push({ text: 'No data sources found', value: '' });
        }
        this.options = options;
        return this.variableSrv.validateVariableSelectionState(this);
    };
    DatasourceVariable.prototype.dependsOn = function (variable) {
        if (this.regex) {
            return Object(__WEBPACK_IMPORTED_MODULE_1__variable__["containsVariable"])(this.regex, variable.name);
        }
        return false;
    };
    DatasourceVariable.prototype.setValueFromUrl = function (urlValue) {
        return this.variableSrv.setOptionFromUrl(this, urlValue);
    };
    DatasourceVariable.prototype.getValueForUrl = function () {
        return this.current.value;
    };
    return DatasourceVariable;
}());

__WEBPACK_IMPORTED_MODULE_1__variable__["variableTypes"]['datasource'] = {
    name: 'Datasource',
    ctor: DatasourceVariable,
    description: 'Enabled you to dynamically switch the datasource for multiple panels',
};


/***/ }),

/***/ 1408:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CustomVariable; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__variable__ = __webpack_require__(1306);
///<reference path="../../headers/common.d.ts" />


var CustomVariable = /** @class */ (function () {
    /** @ngInject **/
    CustomVariable.$inject = ["model", "variableSrv"];
    function CustomVariable(model, variableSrv) {
        this.model = model;
        this.variableSrv = variableSrv;
        this.defaults = {
            type: 'custom',
            name: '',
            label: '',
            hide: 0,
            options: [],
            current: {},
            query: '',
            includeAll: false,
            multi: false,
            allValue: null,
        };
        Object(__WEBPACK_IMPORTED_MODULE_1__variable__["assignModelProperties"])(this, model, this.defaults);
    }
    CustomVariable.prototype.setValue = function (option) {
        return this.variableSrv.setOptionAsCurrent(this, option);
    };
    CustomVariable.prototype.getSaveModel = function () {
        Object(__WEBPACK_IMPORTED_MODULE_1__variable__["assignModelProperties"])(this.model, this, this.defaults);
        return this.model;
    };
    CustomVariable.prototype.updateOptions = function () {
        // extract options in comma separated string
        this.options = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.map(this.query.split(/[,]+/), function (text) {
            return { text: text.trim(), value: text.trim() };
        });
        if (this.includeAll) {
            this.addAllOption();
        }
        return this.variableSrv.validateVariableSelectionState(this);
    };
    CustomVariable.prototype.addAllOption = function () {
        this.options.unshift({ text: 'All', value: "$__all" });
    };
    CustomVariable.prototype.dependsOn = function (variable) {
        return false;
    };
    CustomVariable.prototype.setValueFromUrl = function (urlValue) {
        return this.variableSrv.setOptionFromUrl(this, urlValue);
    };
    CustomVariable.prototype.getValueForUrl = function () {
        if (this.current.text === 'All') {
            return 'All';
        }
        return this.current.value;
    };
    return CustomVariable;
}());

__WEBPACK_IMPORTED_MODULE_1__variable__["variableTypes"]['custom'] = {
    name: 'Custom',
    ctor: CustomVariable,
    description: 'Define variable values manually',
    supportsMulti: true,
};


/***/ }),

/***/ 1409:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ConstantVariable; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__variable__ = __webpack_require__(1306);
///<reference path="../../headers/common.d.ts" />

var ConstantVariable = /** @class */ (function () {
    /** @ngInject **/
    ConstantVariable.$inject = ["model", "variableSrv"];
    function ConstantVariable(model, variableSrv) {
        this.model = model;
        this.variableSrv = variableSrv;
        this.defaults = {
            type: 'constant',
            name: '',
            hide: 2,
            label: '',
            query: '',
            current: {},
            options: [],
        };
        Object(__WEBPACK_IMPORTED_MODULE_0__variable__["assignModelProperties"])(this, model, this.defaults);
    }
    ConstantVariable.prototype.getSaveModel = function () {
        Object(__WEBPACK_IMPORTED_MODULE_0__variable__["assignModelProperties"])(this.model, this, this.defaults);
        return this.model;
    };
    ConstantVariable.prototype.setValue = function (option) {
        this.variableSrv.setOptionAsCurrent(this, option);
    };
    ConstantVariable.prototype.updateOptions = function () {
        this.options = [{ text: this.query.trim(), value: this.query.trim() }];
        this.setValue(this.options[0]);
        return Promise.resolve();
    };
    ConstantVariable.prototype.dependsOn = function (variable) {
        return false;
    };
    ConstantVariable.prototype.setValueFromUrl = function (urlValue) {
        return this.variableSrv.setOptionFromUrl(this, urlValue);
    };
    ConstantVariable.prototype.getValueForUrl = function () {
        return this.current.value;
    };
    return ConstantVariable;
}());

__WEBPACK_IMPORTED_MODULE_0__variable__["variableTypes"]['constant'] = {
    name: 'Constant',
    ctor: ConstantVariable,
    description: 'Define a hidden constant variable, useful for metric prefixes in dashboards you want to share',
};


/***/ }),

/***/ 1410:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AdhocVariable; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__variable__ = __webpack_require__(1306);


var AdhocVariable = /** @class */ (function () {
    /** @ngInject **/
    AdhocVariable.$inject = ["model"];
    function AdhocVariable(model) {
        this.model = model;
        this.defaults = {
            type: 'adhoc',
            name: '',
            label: '',
            hide: 0,
            datasource: null,
            filters: [],
        };
        Object(__WEBPACK_IMPORTED_MODULE_1__variable__["assignModelProperties"])(this, model, this.defaults);
    }
    AdhocVariable.prototype.setValue = function (option) {
        return Promise.resolve();
    };
    AdhocVariable.prototype.getSaveModel = function () {
        Object(__WEBPACK_IMPORTED_MODULE_1__variable__["assignModelProperties"])(this.model, this, this.defaults);
        return this.model;
    };
    AdhocVariable.prototype.updateOptions = function () {
        return Promise.resolve();
    };
    AdhocVariable.prototype.dependsOn = function (variable) {
        return false;
    };
    AdhocVariable.prototype.setValueFromUrl = function (urlValue) {
        var _this = this;
        if (!__WEBPACK_IMPORTED_MODULE_0_lodash___default.a.isArray(urlValue)) {
            urlValue = [urlValue];
        }
        this.filters = urlValue.map(function (item) {
            var values = item.split('|').map(function (value) {
                return _this.unescapeDelimiter(value);
            });
            return {
                key: values[0],
                operator: values[1],
                value: values[2],
            };
        });
        return Promise.resolve();
    };
    AdhocVariable.prototype.getValueForUrl = function () {
        var _this = this;
        return this.filters.map(function (filter) {
            return [filter.key, filter.operator, filter.value].map(function (value) {
                return _this.escapeDelimiter(value);
            }).join('|');
        });
    };
    AdhocVariable.prototype.escapeDelimiter = function (value) {
        return value.replace(/\|/g, '__gfp__');
    };
    AdhocVariable.prototype.unescapeDelimiter = function (value) {
        return value.replace(/__gfp__/g, '|');
    };
    AdhocVariable.prototype.setFilters = function (filters) {
        this.filters = filters;
    };
    return AdhocVariable;
}());

__WEBPACK_IMPORTED_MODULE_1__variable__["variableTypes"]['adhoc'] = {
    name: 'Ad hoc filters',
    ctor: AdhocVariable,
    description: 'Add key/value filters on the fly',
};


/***/ }),

/***/ 1411:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__plugin_edit_ctrl__ = __webpack_require__(1412);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__plugin_page_ctrl__ = __webpack_require__(1413);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__plugin_list_ctrl__ = __webpack_require__(1414);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__import_list_import_list__ = __webpack_require__(1415);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__ds_edit_ctrl__ = __webpack_require__(1416);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__ds_list_ctrl__ = __webpack_require__(1417);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__datasource_srv__ = __webpack_require__(1418);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__datasource_srv___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6__datasource_srv__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__plugin_component__ = __webpack_require__(1540);










/***/ }),

/***/ 1412:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export PluginEditCtrl */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_angular__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_angular___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_angular__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_lodash__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_remarkable__ = __webpack_require__(469);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_remarkable___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_remarkable__);
///<reference path="../../headers/common.d.ts" />



var PluginEditCtrl = /** @class */ (function () {
    /** @ngInject */
    PluginEditCtrl.$inject = ["$scope", "$rootScope", "backendSrv", "$sce", "$routeParams", "navModelSrv"];
    function PluginEditCtrl($scope, $rootScope, backendSrv, $sce, $routeParams, navModelSrv) {
        this.$scope = $scope;
        this.$rootScope = $rootScope;
        this.backendSrv = backendSrv;
        this.$sce = $sce;
        this.navModel = navModelSrv.getPluginsNav();
        this.model = {};
        this.pluginId = $routeParams.pluginId;
        this.tabIndex = 0;
        this.tabs = ['Readme'];
        this.preUpdateHook = function () { return Promise.resolve(); };
        this.postUpdateHook = function () { return Promise.resolve(); };
    }
    PluginEditCtrl.prototype.init = function () {
        var _this = this;
        return this.backendSrv.get("/api/plugins/" + this.pluginId + "/settings").then(function (result) {
            _this.model = result;
            _this.pluginIcon = _this.getPluginIcon(_this.model.type);
            _this.model.dependencies.plugins.forEach(function (plug) {
                plug.icon = _this.getPluginIcon(plug.type);
            });
            _this.includes = __WEBPACK_IMPORTED_MODULE_1_lodash___default.a.map(result.includes, function (plug) {
                plug.icon = _this.getPluginIcon(plug.type);
                return plug;
            });
            if (_this.model.type === 'app') {
                _this.hasDashboards = __WEBPACK_IMPORTED_MODULE_1_lodash___default.a.find(result.includes, { type: 'dashboard' });
                if (_this.hasDashboards) {
                    _this.tabs.unshift('Dashboards');
                }
                _this.tabs.unshift('Config');
                _this.tabIndex = 0;
            }
            return _this.initReadme();
        });
    };
    PluginEditCtrl.prototype.initReadme = function () {
        var _this = this;
        return this.backendSrv.get("/api/plugins/" + this.pluginId + "/markdown/readme").then(function (res) {
            var md = new __WEBPACK_IMPORTED_MODULE_2_remarkable___default.a();
            _this.readmeHtml = _this.$sce.trustAsHtml(md.render(res));
        });
    };
    PluginEditCtrl.prototype.getPluginIcon = function (type) {
        switch (type) {
            case 'datasource': return 'icon-gf icon-gf-datasources';
            case 'panel': return 'icon-gf icon-gf-panel';
            case 'app': return 'icon-gf icon-gf-apps';
            case 'page': return 'icon-gf icon-gf-endpoint-tiny';
            case 'dashboard': return 'icon-gf icon-gf-dashboard';
            default: return 'icon-gf icon-gf-apps';
        }
    };
    PluginEditCtrl.prototype.update = function () {
        var _this = this;
        this.preUpdateHook().then(function () {
            var updateCmd = __WEBPACK_IMPORTED_MODULE_1_lodash___default.a.extend({
                enabled: _this.model.enabled,
                pinned: _this.model.pinned,
                jsonData: _this.model.jsonData,
                secureJsonData: _this.model.secureJsonData,
            }, {});
            return _this.backendSrv.post("/api/plugins/" + _this.pluginId + "/settings", updateCmd);
        })
            .then(this.postUpdateHook)
            .then(function (res) {
            window.location.href = window.location.href;
        });
    };
    PluginEditCtrl.prototype.importDashboards = function () {
        return Promise.resolve();
    };
    PluginEditCtrl.prototype.setPreUpdateHook = function (callback) {
        this.preUpdateHook = callback;
    };
    PluginEditCtrl.prototype.setPostUpdateHook = function (callback) {
        this.postUpdateHook = callback;
    };
    PluginEditCtrl.prototype.updateAvailable = function () {
        var modalScope = this.$scope.$new(true);
        modalScope.plugin = this.model;
        this.$rootScope.appEvent('show-modal', {
            src: 'public/app/features/plugins/partials/update_instructions.html',
            scope: modalScope
        });
    };
    PluginEditCtrl.prototype.enable = function () {
        this.model.enabled = true;
        this.model.pinned = true;
        this.update();
    };
    PluginEditCtrl.prototype.disable = function () {
        this.model.enabled = false;
        this.model.pinned = false;
        this.update();
    };
    return PluginEditCtrl;
}());

__WEBPACK_IMPORTED_MODULE_0_angular___default.a.module('grafana.controllers').controller('PluginEditCtrl', PluginEditCtrl);


/***/ }),

/***/ 1413:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export AppPageCtrl */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_angular__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_angular___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_angular__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_lodash__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_lodash__);
///<reference path="../../headers/common.d.ts" />


var pluginInfoCache = {};
var AppPageCtrl = /** @class */ (function () {
    /** @ngInject */
    AppPageCtrl.$inject = ["backendSrv", "$routeParams", "$rootScope"];
    function AppPageCtrl(backendSrv, $routeParams, $rootScope) {
        this.backendSrv = backendSrv;
        this.$routeParams = $routeParams;
        this.$rootScope = $rootScope;
        this.pluginId = $routeParams.pluginId;
        if (pluginInfoCache[this.pluginId]) {
            this.initPage(pluginInfoCache[this.pluginId]);
        }
        else {
            this.loadPluginInfo();
        }
    }
    AppPageCtrl.prototype.initPage = function (app) {
        this.appModel = app;
        this.page = __WEBPACK_IMPORTED_MODULE_1_lodash___default.a.find(app.includes, { slug: this.$routeParams.slug });
        pluginInfoCache[this.pluginId] = app;
        if (!this.page) {
            this.$rootScope.appEvent('alert-error', ['App Page Not Found', '']);
            this.navModel = {
                section: {
                    title: "Page not found",
                    url: app.defaultNavUrl,
                    icon: 'icon-gf icon-gf-sadface',
                },
                menu: [],
            };
            return;
        }
        var menu = [];
        for (var _i = 0, _a = app.includes; _i < _a.length; _i++) {
            var item = _a[_i];
            if (item.addToNav) {
                if (item.type === 'dashboard') {
                    menu.push({
                        title: item.name,
                        url: 'dashboard/db/' + item.slug,
                        icon: 'fa fa-fw fa-dot-circle-o',
                    });
                }
                if (item.type === 'page') {
                    menu.push({
                        title: item.name,
                        url: "plugins/" + app.id + "/page/" + item.slug,
                        icon: 'fa fa-fw fa-dot-circle-o',
                    });
                }
            }
        }
        this.navModel = {
            section: {
                title: app.name,
                url: app.defaultNavUrl,
                iconUrl: app.info.logos.small,
            },
            menu: menu,
        };
    };
    AppPageCtrl.prototype.loadPluginInfo = function () {
        var _this = this;
        this.backendSrv.get("/api/plugins/" + this.pluginId + "/settings").then(function (app) {
            _this.initPage(app);
        });
    };
    return AppPageCtrl;
}());

__WEBPACK_IMPORTED_MODULE_0_angular___default.a.module('grafana.controllers').controller('AppPageCtrl', AppPageCtrl);


/***/ }),

/***/ 1414:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export PluginListCtrl */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_angular__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_angular___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_angular__);
///<reference path="../../headers/common.d.ts" />

var PluginListCtrl = /** @class */ (function () {
    /** @ngInject */
    PluginListCtrl.$inject = ["backendSrv", "$location", "navModelSrv"];
    function PluginListCtrl(backendSrv, $location, navModelSrv) {
        var _this = this;
        this.backendSrv = backendSrv;
        this.tabIndex = 0;
        this.navModel = navModelSrv.getPluginsNav();
        var pluginType = $location.search().type || 'panel';
        switch (pluginType) {
            case "datasource": {
                this.tabIndex = 1;
                break;
            }
            case "app": {
                this.tabIndex = 2;
                break;
            }
            case "panel":
            default:
                this.tabIndex = 0;
        }
        this.backendSrv.get('api/plugins', { embedded: 0, type: pluginType }).then(function (plugins) {
            _this.plugins = plugins;
        });
    }
    return PluginListCtrl;
}());

__WEBPACK_IMPORTED_MODULE_0_angular___default.a.module('grafana.controllers').controller('PluginListCtrl', PluginListCtrl);


/***/ }),

/***/ 1415:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export DashImportListCtrl */
/* unused harmony export dashboardImportList */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_app_core_core_module__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_app_core_app_events__ = __webpack_require__(53);
///<reference path="../../../headers/common.d.ts" />



var DashImportListCtrl = /** @class */ (function () {
    /** @ngInject */
    DashImportListCtrl.$inject = ["$scope", "backendSrv", "$rootScope"];
    function DashImportListCtrl($scope, backendSrv, $rootScope) {
        var _this = this;
        this.backendSrv = backendSrv;
        this.$rootScope = $rootScope;
        this.dashboards = [];
        backendSrv.get("/api/plugins/" + this.plugin.id + "/dashboards").then(function (dashboards) {
            _this.dashboards = dashboards;
        });
        __WEBPACK_IMPORTED_MODULE_2_app_core_app_events__["a" /* default */].on('dashboard-list-import-all', this.importAll.bind(this), $scope);
    }
    DashImportListCtrl.prototype.importAll = function (payload) {
        return this.importNext(0).then(function () {
            payload.resolve("All dashboards imported");
        }).catch(function (err) {
            payload.reject(err);
        });
    };
    DashImportListCtrl.prototype.importNext = function (index) {
        var _this = this;
        return this.import(this.dashboards[index], true).then(function () {
            if (index + 1 < _this.dashboards.length) {
                return new Promise(function (resolve) {
                    setTimeout(function () {
                        _this.importNext(index + 1).then(function () {
                            resolve();
                        });
                    }, 500);
                });
            }
            else {
                return Promise.resolve();
            }
        });
    };
    DashImportListCtrl.prototype.import = function (dash, overwrite) {
        var _this = this;
        var installCmd = {
            pluginId: this.plugin.id,
            path: dash.path,
            overwrite: overwrite,
            inputs: []
        };
        if (this.datasource) {
            installCmd.inputs.push({
                name: '*',
                type: 'datasource',
                pluginId: this.datasource.type,
                value: this.datasource.name
            });
        }
        return this.backendSrv.post("/api/dashboards/import", installCmd).then(function (res) {
            _this.$rootScope.appEvent('alert-success', ['Dashboard Imported', dash.title]);
            __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.extend(dash, res);
        });
    };
    DashImportListCtrl.prototype.remove = function (dash) {
        var _this = this;
        this.backendSrv.delete('/api/dashboards/' + dash.importedUri).then(function () {
            _this.$rootScope.appEvent('alert-success', ['Dashboard Deleted', dash.title]);
            dash.imported = false;
        });
    };
    return DashImportListCtrl;
}());

function dashboardImportList() {
    return {
        restrict: 'E',
        templateUrl: 'public/app/features/plugins/import_list/import_list.html',
        controller: DashImportListCtrl,
        bindToController: true,
        controllerAs: 'ctrl',
        scope: {
            plugin: "=",
            datasource: "="
        }
    };
}
__WEBPACK_IMPORTED_MODULE_1_app_core_core_module__["default"].directive('dashboardImportList', dashboardImportList);


/***/ }),

/***/ 1416:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export DataSourceEditCtrl */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_app_core_config__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_app_core_core__ = __webpack_require__(465);
///<reference path="../../headers/common.d.ts" />



var datasourceTypes = [];
var defaults = {
    name: '',
    type: 'graphite',
    url: '',
    access: 'proxy',
    jsonData: {},
    secureJsonFields: {},
};
var datasourceCreated = false;
var DataSourceEditCtrl = /** @class */ (function () {
    /** @ngInject */
    DataSourceEditCtrl.$inject = ["$q", "backendSrv", "$routeParams", "$location", "datasourceSrv", "navModelSrv"];
    function DataSourceEditCtrl($q, backendSrv, $routeParams, $location, datasourceSrv, navModelSrv) {
        var _this = this;
        this.$q = $q;
        this.backendSrv = backendSrv;
        this.$routeParams = $routeParams;
        this.$location = $location;
        this.datasourceSrv = datasourceSrv;
        this.navModelSrv = navModelSrv;
        this.navModel = this.navModelSrv.getDatasourceNav(0);
        this.isNew = true;
        this.datasources = [];
        this.tabIndex = 0;
        this.loadDatasourceTypes().then(function () {
            if (_this.$routeParams.id) {
                _this.getDatasourceById(_this.$routeParams.id);
            }
            else {
                _this.initNewDatasourceModel();
            }
        });
    }
    DataSourceEditCtrl.prototype.initNewDatasourceModel = function () {
        this.current = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.cloneDeep(defaults);
        // We are coming from getting started
        if (this.$location.search().gettingstarted) {
            this.gettingStarted = true;
            this.current.isDefault = true;
        }
        this.typeChanged();
    };
    DataSourceEditCtrl.prototype.loadDatasourceTypes = function () {
        var _this = this;
        if (datasourceTypes.length > 0) {
            this.types = datasourceTypes;
            return this.$q.when(null);
        }
        return this.backendSrv.get('/api/plugins', { enabled: 1, type: 'datasource' }).then(function (plugins) {
            datasourceTypes = plugins;
            _this.types = plugins;
        });
    };
    DataSourceEditCtrl.prototype.getDatasourceById = function (id) {
        var _this = this;
        this.backendSrv.get('/api/datasources/' + id).then(function (ds) {
            _this.isNew = false;
            _this.current = ds;
            if (datasourceCreated) {
                datasourceCreated = false;
                _this.testDatasource();
            }
            return _this.typeChanged();
        });
    };
    DataSourceEditCtrl.prototype.userChangedType = function () {
        // reset model but keep name & default flag
        this.current = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.defaults({
            id: this.current.id,
            name: this.current.name,
            isDefault: this.current.isDefault,
            type: this.current.type,
        }, __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.cloneDeep(defaults));
        this.typeChanged();
    };
    DataSourceEditCtrl.prototype.typeChanged = function () {
        var _this = this;
        this.hasDashboards = false;
        return this.backendSrv.get('/api/plugins/' + this.current.type + '/settings').then(function (pluginInfo) {
            _this.datasourceMeta = pluginInfo;
            _this.hasDashboards = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.find(pluginInfo.includes, { type: 'dashboard' });
        });
    };
    DataSourceEditCtrl.prototype.updateFrontendSettings = function () {
        var _this = this;
        return this.backendSrv.get('/api/frontend/settings').then(function (settings) {
            __WEBPACK_IMPORTED_MODULE_1_app_core_config__["default"].datasources = settings.datasources;
            __WEBPACK_IMPORTED_MODULE_1_app_core_config__["default"].defaultDatasource = settings.defaultDatasource;
            _this.datasourceSrv.init();
        });
    };
    DataSourceEditCtrl.prototype.testDatasource = function () {
        var _this = this;
        this.datasourceSrv.get(this.current.name).then(function (datasource) {
            if (!datasource.testDatasource) {
                return;
            }
            _this.testing = { done: false, status: 'error' };
            // make test call in no backend cache context
            _this.backendSrv.withNoBackendCache(function () {
                return datasource.testDatasource().then(function (result) {
                    _this.testing.message = result.message;
                    _this.testing.status = result.status;
                }).catch(function (err) {
                    if (err.statusText) {
                        _this.testing.message = 'HTTP Error ' + err.statusText;
                    }
                    else {
                        _this.testing.message = err.message;
                    }
                });
            }).finally(function () {
                _this.testing.done = true;
            });
        });
    };
    DataSourceEditCtrl.prototype.saveChanges = function () {
        var _this = this;
        if (!this.editForm.$valid) {
            return;
        }
        if (this.current.readOnly) {
            return;
        }
        if (this.current.id) {
            return this.backendSrv.put('/api/datasources/' + this.current.id, this.current).then(function (result) {
                _this.current = result.datasource;
                _this.updateFrontendSettings().then(function () {
                    _this.testDatasource();
                });
            });
        }
        else {
            return this.backendSrv.post('/api/datasources', this.current).then(function (result) {
                _this.current = result.datasource;
                _this.updateFrontendSettings();
                datasourceCreated = true;
                _this.$location.path('datasources/edit/' + result.id);
            });
        }
    };
    DataSourceEditCtrl.prototype.confirmDelete = function () {
        var _this = this;
        this.backendSrv.delete('/api/datasources/' + this.current.id).then(function () {
            _this.$location.path('datasources');
        });
    };
    DataSourceEditCtrl.prototype.delete = function (s) {
        var _this = this;
        __WEBPACK_IMPORTED_MODULE_2_app_core_core__["appEvents"].emit('confirm-modal', {
            title: 'Delete',
            text: 'Are you sure you want to delete this datasource?',
            yesText: "Delete",
            icon: "fa-trash",
            onConfirm: function () {
                _this.confirmDelete();
            }
        });
    };
    return DataSourceEditCtrl;
}());

__WEBPACK_IMPORTED_MODULE_2_app_core_core__["coreModule"].controller('DataSourceEditCtrl', DataSourceEditCtrl);
__WEBPACK_IMPORTED_MODULE_2_app_core_core__["coreModule"].directive('datasourceHttpSettings', function () {
    return {
        scope: {
            current: "=",
            suggestUrl: "@",
        },
        templateUrl: 'public/app/features/plugins/partials/ds_http_settings.html',
        link: {
            pre: function ($scope, elem, attrs) {
                $scope.getSuggestUrls = function () {
                    return [$scope.suggestUrl];
                };
            }
        }
    };
});


/***/ }),

/***/ 1417:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export DataSourcesCtrl */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__core_core_module__ = __webpack_require__(2);
///<reference path="../../headers/common.d.ts" />

var DataSourcesCtrl = /** @class */ (function () {
    /** @ngInject */
    DataSourcesCtrl.$inject = ["$scope", "backendSrv", "datasourceSrv", "navModelSrv"];
    function DataSourcesCtrl($scope, backendSrv, datasourceSrv, navModelSrv) {
        var _this = this;
        this.$scope = $scope;
        this.backendSrv = backendSrv;
        this.datasourceSrv = datasourceSrv;
        this.navModelSrv = navModelSrv;
        this.navModel = this.navModelSrv.getDatasourceNav(0);
        backendSrv.get('/api/datasources').then(function (result) {
            _this.datasources = result;
        });
    }
    DataSourcesCtrl.prototype.removeDataSourceConfirmed = function (ds) {
        var _this = this;
        this.backendSrv.delete('/api/datasources/' + ds.id)
            .then(function () {
            _this.$scope.appEvent('alert-success', ['Datasource deleted', '']);
        }, function () {
            _this.$scope.appEvent('alert-error', ['Unable to delete datasource', '']);
        }).then(function () {
            _this.backendSrv.get('/api/datasources')
                .then(function (result) {
                _this.datasources = result;
            });
            _this.backendSrv.get('/api/frontend/settings')
                .then(function (settings) {
                _this.datasourceSrv.init(settings.datasources);
            });
        });
    };
    DataSourcesCtrl.prototype.removeDataSource = function (ds) {
        var _this = this;
        this.$scope.appEvent('confirm-modal', {
            title: 'Delete',
            text: 'Are you sure you want to delete datasource ' + ds.name + '?',
            yesText: "Delete",
            icon: "fa-trash",
            onConfirm: function () {
                _this.removeDataSourceConfirmed(ds);
            }
        });
    };
    return DataSourcesCtrl;
}());

__WEBPACK_IMPORTED_MODULE_0__core_core_module__["default"].controller('DataSourcesCtrl', DataSourcesCtrl);


/***/ }),

/***/ 1418:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
  __webpack_require__(12),
  __webpack_require__(7),
  __webpack_require__(2),
  __webpack_require__(27),
  __webpack_require__(1316),
], __WEBPACK_AMD_DEFINE_RESULT__ = function (angular, _, coreModule, config, pluginLoader) {
  'use strict';

  config = config.default;

  coreModule.default.service('datasourceSrv', ["$q", "$injector", "$rootScope", "templateSrv", function($q, $injector, $rootScope, templateSrv) {
    var self = this;

    this.init = function() {
      this.datasources = {};
    };

    this.get = function(name) {
      if (!name) {
        return this.get(config.defaultDatasource);
      }

      name = templateSrv.replace(name);

      if (name === 'default') {
        return this.get(config.defaultDatasource);
      }

      if (this.datasources[name]) {
        return $q.when(this.datasources[name]);
      }

      return this.loadDatasource(name);
    };

    this.loadDatasource = function(name) {
      var dsConfig = config.datasources[name];
      if (!dsConfig) {
        return $q.reject({message: "Datasource named " + name + " was not found"});
      }

      var deferred = $q.defer();
      var pluginDef = dsConfig.meta;

      pluginLoader.importPluginModule(pluginDef.module).then(function(plugin) {
        // check if its in cache now
        if (self.datasources[name]) {
          deferred.resolve(self.datasources[name]);
          return;
        }

        // plugin module needs to export a constructor function named Datasource
        if (!plugin.Datasource) {
          throw "Plugin module is missing Datasource constructor";
        }

        var instance = $injector.instantiate(plugin.Datasource, {instanceSettings: dsConfig});
        instance.meta = pluginDef;
        instance.name = name;
        self.datasources[name] = instance;
        deferred.resolve(instance);
      }).catch(function(err) {
        $rootScope.appEvent('alert-error', [dsConfig.name + ' plugin failed', err.toString()]);
      });

      return deferred.promise;
    };

    this.getAll = function() {
      return config.datasources;
    };

    this.getAnnotationSources = function() {
      var sources = [];

      this.addDataSourceVariables(sources);

      _.each(config.datasources, function(value) {
        if (value.meta && value.meta.annotations) {
          sources.push(value);
        }
      });

      return sources;
    };

    this.getMetricSources = function(options) {
      var metricSources = [];

      _.each(config.datasources, function(value, key) {
        if (value.meta && value.meta.metrics) {
          metricSources.push({value: key, name: key, meta: value.meta});

          if (key === config.defaultDatasource) {
            metricSources.push({value: null, name: 'default', meta: value.meta});
          }
        }
      });

      if (!options || !options.skipVariables) {
        this.addDataSourceVariables(metricSources);
      }

      metricSources.sort(function(a, b) {
        // these two should always be at the bottom
        if (a.meta.id === "mixed" || a.meta.id === "grafana") {
          return 1;
        }
        if (b.meta.id === "mixed" || b.meta.id === "grafana") {
          return -1;
        }
        if (a.name.toLowerCase() > b.name.toLowerCase()) {
          return 1;
        }
        if (a.name.toLowerCase() < b.name.toLowerCase()) {
          return -1;
        }
        return 0;
      });

      return metricSources;
    };

    this.addDataSourceVariables = function(list) {
      // look for data source variables
      for (var i = 0; i < templateSrv.variables.length; i++) {
        var variable = templateSrv.variables[i];
        if (variable.type !== 'datasource') {
          continue;
        }

        var first = variable.current.value;
        if (first === 'default') {
          first = config.defaultDatasource;
        }

        var ds = config.datasources[first];

        if (ds) {
          list.push({
            name: '$' + variable.name,
            value: '$' + variable.name,
            meta: ds.meta,
          });
        }
      }
    };

    this.init();
  }]);
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ 1419:
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer, process, global, __filename) {var require;/*
 * SystemJS v0.20.19 Dev
 */
!function(){"use strict";function e(e){return ut?Symbol():"@@"+e}function t(e,t){ot||(t=t.replace(at?/file:\/\/\//g:/file:\/\//g,""));var r,n=(e.message||e)+"\n  "+t;r=ft&&e.fileName?new Error(n,e.fileName,e.lineNumber):new Error(n);var o=e.originalErr?e.originalErr.stack:e.stack;return r.stack=it?n+"\n  "+o:o,r.originalErr=e.originalErr||e,r}function r(e,t){throw new RangeError('Unable to resolve "'+e+'" to '+t)}function n(e,t){e=e.trim();var n=t&&t.substr(0,t.indexOf(":")+1),o=e[0],i=e[1];if("/"===o&&"/"===i)return n||r(e,t),n+e;if("."===o&&("/"===i||"."===i&&("/"===e[2]||2===e.length&&(e+="/"))||1===e.length&&(e+="/"))||"/"===o){var a,s=!n||"/"!==t[n.length];if(s?(void 0===t&&r(e,t),a=t):a="/"===t[n.length+1]?"file:"!==n?(a=t.substr(n.length+2)).substr(a.indexOf("/")+1):t.substr(8):t.substr(n.length+1),"/"===o){if(!s)return t.substr(0,t.length-a.length-1)+e;r(e,t)}for(var u=a.substr(0,a.lastIndexOf("/")+1)+e,l=[],c=-1,f=0;f<u.length;f++)if(-1===c)if("."!==u[f])c=f;else{if("."!==u[f+1]||"/"!==u[f+2]&&f+2!==u.length){if("/"!==u[f+1]&&f+1!==u.length){c=f;continue}f+=1}else l.pop(),f+=2;s&&0===l.length&&r(e,t)}else"/"===u[f]&&(l.push(u.substring(c,f+1)),c=-1);return-1!==c&&l.push(u.substr(c)),t.substr(0,t.length-a.length)+l.join("")}return-1!==e.indexOf(":")?it&&":"===e[1]&&"\\"===e[2]&&e[0].match(/[a-z]/i)?"file:///"+e.replace(/\\/g,"/"):e:void 0}function o(e){if(e.values)return e.values();if("undefined"==typeof Symbol||!Symbol.iterator)throw new Error("Symbol.iterator not supported in this browser");var t={};return t[Symbol.iterator]=function(){var t=Object.keys(e),r=0;return{next:function(){return r<t.length?{value:e[t[r++]],done:!1}:{value:void 0,done:!0}}}},t}function i(){this.registry=new u}function a(e){if(!(e instanceof l))throw new TypeError("Module instantiation did not return a valid namespace object.");return e}function s(e){if(void 0===e)throw new RangeError("No resolution found.");return e}function u(){this[mt]={}}function l(e){Object.defineProperty(this,vt,{value:e}),Object.keys(e).forEach(c,this)}function c(e){Object.defineProperty(this,e,{enumerable:!0,get:function(){return this[vt][e]}})}function f(){i.call(this);var e=this.registry.delete;this.registry.delete=function(r){var n=e.call(this,r);return t.hasOwnProperty(r)&&!t[r].linkRecord&&(delete t[r],n=!0),n};var t={};this[yt]={lastRegister:void 0,records:t},this.trace=!1}function d(e,t,r){return e.records[t]={key:t,registration:r,module:void 0,importerSetters:void 0,loadError:void 0,evalError:void 0,linkRecord:{instantiatePromise:void 0,dependencies:void 0,execute:void 0,executingRequire:!1,moduleObj:void 0,setters:void 0,depsInstantiatePromise:void 0,dependencyInstantiations:void 0}}}function p(e,t,r,n,o){var i=n[t];if(i)return Promise.resolve(i);var a=o.records[t];return a&&!a.module?a.loadError?Promise.reject(a.loadError):h(e,a,a.linkRecord,n,o):e.resolve(t,r).then(function(t){if(i=n[t])return i;if((a=o.records[t])&&!a.module||(a=d(o,t,a&&a.registration)),a.loadError)return Promise.reject(a.loadError);var r=a.linkRecord;return r?h(e,a,r,n,o):a})}function g(e,t,r){return function(){var e=r.lastRegister;return e?(r.lastRegister=void 0,t.registration=e,!0):!!t.registration}}function h(e,r,n,o,i){return n.instantiatePromise||(n.instantiatePromise=(r.registration?Promise.resolve():Promise.resolve().then(function(){return i.lastRegister=void 0,e[bt](r.key,e[bt].length>1&&g(e,r,i))})).then(function(t){if(void 0!==t){if(!(t instanceof l))throw new TypeError("Instantiate did not return a valid Module object.");return delete i.records[r.key],e.trace&&v(e,r,n),o[r.key]=t}var a=r.registration;if(r.registration=void 0,!a)throw new TypeError("Module instantiation did not call an anonymous or correctly named System.register.");return n.dependencies=a[0],r.importerSetters=[],n.moduleObj={},a[2]?(n.moduleObj.default=n.moduleObj.__useDefault={},n.executingRequire=a[1],n.execute=a[2]):y(e,r,n,a[1]),r}).catch(function(e){throw r.linkRecord=void 0,r.loadError=r.loadError||t(e,"Instantiating "+r.key)}))}function m(e,t,r,n,o,i){return e.resolve(t,r).then(function(r){i&&(i[t]=r);var a=o.records[r],s=n[r];if(s&&(!a||a.module&&s!==a.module))return s;if(a&&a.loadError)throw a.loadError;(!a||!s&&a.module)&&(a=d(o,r,a&&a.registration));var u=a.linkRecord;return u?h(e,a,u,n,o):a})}function v(e,t,r){e.loads=e.loads||{},e.loads[t.key]={key:t.key,deps:r.dependencies,dynamicDeps:[],depMap:r.depMap||{}}}function y(e,t,r,n){var o=r.moduleObj,i=t.importerSetters,a=!1,s=n.call(st,function(e,t){if("object"==typeof e){var r=!1;for(var n in e)t=e[n],"__useDefault"===n||n in o&&o[n]===t||(r=!0,o[n]=t);if(!1===r)return t}else{if((a||e in o)&&o[e]===t)return t;o[e]=t}for(var s=0;s<i.length;s++)i[s](o);return t},new x(e,t.key));r.setters=s.setters,r.execute=s.execute,s.exports&&(r.moduleObj=o=s.exports,a=!0)}function b(e,r,n,o,i){if(n.depsInstantiatePromise)return n.depsInstantiatePromise;for(var a=Array(n.dependencies.length),s=0;s<n.dependencies.length;s++)a[s]=m(e,n.dependencies[s],r.key,o,i,e.trace&&n.depMap||(n.depMap={}));var u=Promise.all(a).then(function(e){if(n.dependencyInstantiations=e,n.setters)for(var t=0;t<e.length;t++){var o=n.setters[t];if(o){var i=e[t];if(i instanceof l)o(i);else{if(i.loadError)throw i.loadError;o(i.module||i.linkRecord.moduleObj),i.importerSetters&&i.importerSetters.push(o)}}}return r});return e.trace&&(u=u.then(function(){return v(e,r,n),r})),(u=u.catch(function(e){throw n.depsInstantiatePromise=void 0,t(e,"Loading "+r.key)})).catch(function(){}),n.depsInstantiatePromise=u}function w(e,t,r,n,o){return new Promise(function(r,i){function a(t){var r=t.linkRecord;r&&-1===u.indexOf(t)&&(u.push(t),c++,b(e,t,r,n,o).then(s,i))}function s(e){c--;var t=e.linkRecord;if(t)for(var n=0;n<t.dependencies.length;n++){var o=t.dependencyInstantiations[n];o instanceof l||a(o)}0===c&&r()}var u=[],c=0;a(t)})}function x(e,t){this.loader=e,this.key=this.id=t,this.meta={url:t}}function k(e,t,r,n,o,i){if(t.module)return t.module;if(t.evalError)throw t.evalError;if(i&&-1!==i.indexOf(t))return t.linkRecord.moduleObj;var a=O(e,t,r,n,o,r.setters?[]:i||[]);if(a)throw a;return t.module}function E(e,t,r,n,o,i,a){return function(s){for(var u=0;u<r.length;u++)if(r[u]===s){var c,f=n[u];return c=f instanceof l?f:k(e,f,f.linkRecord,o,i,a),"__useDefault"in c?c.__useDefault:c}throw new Error("Module "+s+" not declared as a System.registerDynamic dependency of "+t)}}function O(e,r,n,o,i,a){a.push(r);var s;if(n.setters)for(var u,c,f=0;f<n.dependencies.length;f++)if(!((u=n.dependencyInstantiations[f])instanceof l)&&((c=u.linkRecord)&&-1===a.indexOf(u)&&(s=u.evalError?u.evalError:O(e,u,c,o,i,c.setters?a:[])),s))return r.linkRecord=void 0,r.evalError=t(s,"Evaluating "+r.key),r.evalError;if(n.execute)if(n.setters)s=S(n.execute);else{var d={id:r.key},p=n.moduleObj;Object.defineProperty(d,"exports",{configurable:!0,set:function(e){p.default=p.__useDefault=e},get:function(){return p.__useDefault}});var g=E(e,r.key,n.dependencies,n.dependencyInstantiations,o,i,a);if(!n.executingRequire)for(f=0;f<n.dependencies.length;f++)g(n.dependencies[f]);s=j(n.execute,g,p.default,d),d.exports!==p.__useDefault&&(p.default=p.__useDefault=d.exports);var h=p.default;if(h&&h.__esModule)for(var m in h)Object.hasOwnProperty.call(h,m)&&(p[m]=h[m])}if(r.linkRecord=void 0,s)return r.evalError=t(s,"Evaluating "+r.key);if(o[r.key]=r.module=new l(n.moduleObj),!n.setters){if(r.importerSetters)for(f=0;f<r.importerSetters.length;f++)r.importerSetters[f](r.module);r.importerSetters=void 0}}function S(e){try{e.call(wt)}catch(e){return e}}function j(e,t,r,n){try{var o=e.call(st,t,r,n);void 0!==o&&(n.exports=o)}catch(e){return e}}function _(){}function P(e){return e instanceof l?e:new l(e&&e.__esModule?e:{default:e,__useDefault:e})}function M(e){return void 0===xt&&(xt="undefined"!=typeof Symbol&&!!Symbol.toStringTag),e instanceof l||xt&&"[object Module]"==Object.prototype.toString.call(e)}function R(e,t){(t||this.warnings&&"undefined"!=typeof console&&console.warn)&&console.warn(e)}function C(e,t,r){var n=new Uint8Array(t);return 0===n[0]&&97===n[1]&&115===n[2]?WebAssembly.compile(t).then(function(t){var n=[],o=[],i={};return WebAssembly.Module.imports&&WebAssembly.Module.imports(t).forEach(function(e){var t=e.module;o.push(function(e){i[t]=e}),-1===n.indexOf(t)&&n.push(t)}),e.register(n,function(e){return{setters:o,execute:function(){e(new WebAssembly.Instance(t,i).exports)}}}),r(),!0}):Promise.resolve(!1)}function L(e,t){if("."===e[0])throw new Error("Node module "+e+" can't be loaded as it is not a package require.");if(!kt){var r=this._nodeRequire("module"),n=decodeURI(t.substr(at?8:7));(kt=new r(n)).paths=r._nodeModulePaths(n)}return kt.require(e)}function A(e,t){for(var r in t)Object.hasOwnProperty.call(t,r)&&(e[r]=t[r]);return e}function I(e,t){for(var r in t)Object.hasOwnProperty.call(t,r)&&void 0===e[r]&&(e[r]=t[r]);return e}function F(e,t,r){for(var n in t)if(Object.hasOwnProperty.call(t,n)){var o=t[n];void 0===e[n]?e[n]=o:o instanceof Array&&e[n]instanceof Array?e[n]=[].concat(r?o:e[n]).concat(r?e[n]:o):"object"==typeof o&&null!==o&&"object"==typeof e[n]?e[n]=(r?I:A)(A({},e[n]),o):r||(e[n]=o)}}function K(e){if(Pt||Mt){var t=document.createElement("link");Pt?(t.rel="preload",t.as="script"):t.rel="prefetch",t.href=e,document.head.appendChild(t)}else(new Image).src=e}function D(e,t,r){try{importScripts(e)}catch(e){r(e)}t()}function U(e,t,r,n,o){function i(){n(),s()}function a(t){s(),o(new Error("Fetching "+e))}function s(){for(var e=0;e<Rt.length;e++)if(Rt[e].err===a){Rt.splice(e,1);break}u.removeEventListener("load",i,!1),u.removeEventListener("error",a,!1),document.head.removeChild(u)}if(e=e.replace(/#/g,"%23"),_t)return D(e,n,o);var u=document.createElement("script");u.type="text/javascript",u.charset="utf-8",u.async=!0,t&&(u.crossOrigin=t),r&&(u.integrity=r),u.addEventListener("load",i,!1),u.addEventListener("error",a,!1),u.src=e,document.head.appendChild(u)}function q(e,t){for(var r=e.split(".");r.length;)t=t[r.shift()];return t}function T(e,t,r){var o=N(t,r);if(o){var i=t[o]+r.substr(o.length),a=n(i,nt);return void 0!==a?a:e+i}return-1!==r.indexOf(":")?r:e+r}function z(e){var t=this.name;if(t.substr(0,e.length)===e&&(t.length===e.length||"/"===t[e.length]||"/"===e[e.length-1]||":"===e[e.length-1])){var r=e.split("/").length;r>this.len&&(this.match=e,this.len=r)}}function N(e,t){if(Object.hasOwnProperty.call(e,t))return t;var r={name:t,match:void 0,len:0};return Object.keys(e).forEach(z,r),r.match}function J(e,t,r,n){if("file:///"===e.substr(0,8)){if(Ft)return $(e,t,r,n);throw new Error("Unable to fetch file URLs in this environment.")}e=e.replace(/#/g,"%23");var o={headers:{Accept:"application/x-es-module, */*"}};return r&&(o.integrity=r),t&&("string"==typeof t&&(o.headers.Authorization=t),o.credentials="include"),fetch(e,o).then(function(e){if(e.ok)return n?e.arrayBuffer():e.text();throw new Error("Fetch error: "+e.status+" "+e.statusText)})}function $(e,t,r,n){return new Promise(function(r,o){function i(){r(n?s.response:s.responseText)}function a(){o(new Error("XHR error: "+(s.status?" ("+s.status+(s.statusText?" "+s.statusText:"")+")":"")+" loading "+e))}e=e.replace(/#/g,"%23");var s=new XMLHttpRequest;n&&(s.responseType="arraybuffer"),s.onreadystatechange=function(){4===s.readyState&&(0==s.status?s.response?i():(s.addEventListener("error",a),s.addEventListener("load",i)):200===s.status?i():a())},s.open("GET",e,!0),s.setRequestHeader&&(s.setRequestHeader("Accept","application/x-es-module, */*"),t&&("string"==typeof t&&s.setRequestHeader("Authorization",t),s.withCredentials=!0)),s.send(null)})}function B(e,t,r,n){return"file:///"!=e.substr(0,8)?Promise.reject(new Error('Unable to fetch "'+e+'". Only file URLs of the form file:/// supported running in Node.')):(Lt=Lt||__webpack_require__(1425),e=at?e.replace(/\//g,"\\").substr(8):e.substr(7),new Promise(function(t,r){Lt.readFile(e,function(e,o){if(e)return r(e);if(n)t(o);else{var i=o+"";"\ufeff"===i[0]&&(i=i.substr(1)),t(i)}})}))}function W(){throw new Error("No fetch method is defined for this environment.")}function G(){return{pluginKey:void 0,pluginArgument:void 0,pluginModule:void 0,packageKey:void 0,packageConfig:void 0,load:void 0}}function H(e,t,r){var n=G();if(r){var o;t.pluginFirst?-1!==(o=r.lastIndexOf("!"))&&(n.pluginArgument=n.pluginKey=r.substr(0,o)):-1!==(o=r.indexOf("!"))&&(n.pluginArgument=n.pluginKey=r.substr(o+1)),n.packageKey=N(t.packages,r),n.packageKey&&(n.packageConfig=t.packages[n.packageKey])}return n}function Z(e,t){var r=this[St],n=G(),o=H(this,r,t),i=this;return Promise.resolve().then(function(){var r=e.lastIndexOf("#?");if(-1===r)return Promise.resolve(e);var n=he.call(i,e.substr(r+2));return me.call(i,n,t,!0).then(function(t){return t?e.substr(0,r):"@empty"})}).then(function(e){var a=ne(r.pluginFirst,e);return a?(n.pluginKey=a.plugin,Promise.all([ee.call(i,r,a.argument,o&&o.pluginArgument||t,n,o,!0),i.resolve(a.plugin,t)]).then(function(e){if(n.pluginArgument=e[0],n.pluginKey=e[1],n.pluginArgument===n.pluginKey)throw new Error("Plugin "+n.pluginArgument+" cannot load itself, make sure it is excluded from any wildcard meta configuration via a custom loader: false rule.");return oe(r.pluginFirst,e[0],e[1])})):ee.call(i,r,e,o&&o.pluginArgument||t,n,o,!1)}).then(function(e){return ve.call(i,e,t,o)}).then(function(e){return re.call(i,r,e,n),n.pluginKey||!n.load.loader?e:i.resolve(n.load.loader,e).then(function(t){return n.pluginKey=t,n.pluginArgument=e,e})}).then(function(e){return i[jt][e]=n,e})}function X(e,t){var r=ne(e.pluginFirst,t);if(r){var n=X.call(this,e,r.plugin);return oe(e.pluginFirst,Q.call(this,e,r.argument,void 0,!1,!1),n)}return Q.call(this,e,t,void 0,!1,!1)}function Y(e,t){var r=this[St],n=G(),o=o||H(this,r,t),i=ne(r.pluginFirst,e);return i?(n.pluginKey=Y.call(this,i.plugin,t),oe(r.pluginFirst,V.call(this,r,i.argument,o.pluginArgument||t,n,o,!!n.pluginKey),n.pluginKey)):V.call(this,r,e,o.pluginArgument||t,n,o,!!n.pluginKey)}function Q(e,t,r,o,i){var a=n(t,r||nt);if(a)return T(e.baseURL,e.paths,a);if(o){var s=N(e.map,t);if(s&&(t=e.map[s]+t.substr(s.length),a=n(t,nt)))return T(e.baseURL,e.paths,a)}if(this.registry.has(t))return t;if("@node/"===t.substr(0,6))return t;var u=i&&"/"!==t[t.length-1],l=T(e.baseURL,e.paths,u?t+"/":t);return u?l.substr(0,l.length-1):l}function V(e,t,r,n,o,i){if(o&&o.packageConfig&&"."!==t[0]){var a=o.packageConfig.map,s=a&&N(a,t);if(s&&"string"==typeof a[s]){var u=ue(this,e,o.packageConfig,o.packageKey,s,t,n,i);if(u)return u}}var l=Q.call(this,e,t,r,!0,!0),c=de(e,l);if(n.packageKey=c&&c.packageKey||N(e.packages,l),!n.packageKey)return l;if(-1!==e.packageConfigKeys.indexOf(l))return n.packageKey=void 0,l;n.packageConfig=e.packages[n.packageKey]||(e.packages[n.packageKey]=Ee());var f=l.substr(n.packageKey.length+1);return ae(this,e,n.packageConfig,n.packageKey,f,n,i)}function ee(e,t,r,n,o,i){var a=this;return Et.then(function(){if(o&&o.packageConfig&&"./"!==t.substr(0,2)){var r=o.packageConfig.map,s=r&&N(r,t);if(s)return ce(a,e,o.packageConfig,o.packageKey,s,t,n,i)}return Et}).then(function(o){if(o)return o;var s=Q.call(a,e,t,r,!0,!0),u=de(e,s);return n.packageKey=u&&u.packageKey||N(e.packages,s),n.packageKey?-1!==e.packageConfigKeys.indexOf(s)?(n.packageKey=void 0,n.load=te(),n.load.format="json",n.load.loader="",Promise.resolve(s)):(n.packageConfig=e.packages[n.packageKey]||(e.packages[n.packageKey]=Ee()),(u&&!n.packageConfig.configured?pe(a,e,u.configPath,n):Et).then(function(){var t=s.substr(n.packageKey.length+1);return le(a,e,n.packageConfig,n.packageKey,t,n,i)})):Promise.resolve(s)})}function te(){return{extension:"",deps:void 0,format:void 0,loader:void 0,scriptLoad:void 0,globals:void 0,nonce:void 0,integrity:void 0,sourceMap:void 0,exports:void 0,encapsulateGlobal:!1,crossOrigin:void 0,cjsRequireDetection:!0,cjsDeferDepsExecute:!1,esModule:!1}}function re(e,t,r){r.load=r.load||te();var n,o=0;for(var i in e.meta)if(-1!==(n=i.indexOf("*"))&&i.substr(0,n)===t.substr(0,n)&&i.substr(n+1)===t.substr(t.length-i.length+n+1)){var a=i.split("/").length;a>o&&(o=a),F(r.load,e.meta[i],o!==a)}if(e.meta[t]&&F(r.load,e.meta[t],!1),r.packageKey){var s=t.substr(r.packageKey.length+1),u={};if(r.packageConfig.meta){o=0;ge(r.packageConfig.meta,s,function(e,t,r){r>o&&(o=r),F(u,t,r&&o>r)}),F(r.load,u,!1)}!r.packageConfig.format||r.pluginKey||r.load.loader||(r.load.format=r.load.format||r.packageConfig.format)}}function ne(e,t){var r,n,o=e?t.indexOf("!"):t.lastIndexOf("!");if(-1!==o)return e?(r=t.substr(o+1),n=t.substr(0,o)):(r=t.substr(0,o),n=t.substr(o+1)||r.substr(r.lastIndexOf(".")+1)),{argument:r,plugin:n}}function oe(e,t,r){return e?r+"!"+t:t+"!"+r}function ie(e,t,r,n,o){if(!n||!t.defaultExtension||"/"===n[n.length-1]||o)return n;var i=!1;if(t.meta&&ge(t.meta,n,function(e,t,r){if(0===r||e.lastIndexOf("*")!==e.length-1)return i=!0}),!i&&e.meta&&ge(e.meta,r+"/"+n,function(e,t,r){if(0===r||e.lastIndexOf("*")!==e.length-1)return i=!0}),i)return n;var a="."+t.defaultExtension;return n.substr(n.length-a.length)!==a?n+a:n}function ae(e,t,r,n,o,i,a){if(!o){if(!r.main)return n;o="./"===r.main.substr(0,2)?r.main.substr(2):r.main}if(r.map){var s="./"+o,u=N(r.map,s);if(u||(s="./"+ie(t,r,n,o,a))!=="./"+o&&(u=N(r.map,s)),u){var l=ue(e,t,r,n,u,s,i,a);if(l)return l}}return n+"/"+ie(t,r,n,o,a)}function se(e,t,r){return!(t.substr(0,e.length)===e&&r.length>e.length)}function ue(e,t,r,n,o,i,a,s){"/"===i[i.length-1]&&(i=i.substr(0,i.length-1));var u=r.map[o];if("object"==typeof u)throw new Error("Synchronous conditional normalization not supported sync normalizing "+o+" in "+n);if(se(o,u,i)&&"string"==typeof u)return V.call(e,t,u+i.substr(o.length),n+"/",a,a,s)}function le(e,t,r,n,o,i,a){if(!o){if(!r.main)return Promise.resolve(n);o="./"===r.main.substr(0,2)?r.main.substr(2):r.main}var s,u;return r.map&&(s="./"+o,(u=N(r.map,s))||(s="./"+ie(t,r,n,o,a))!=="./"+o&&(u=N(r.map,s))),(u?ce(e,t,r,n,u,s,i,a):Et).then(function(e){return e?Promise.resolve(e):Promise.resolve(n+"/"+ie(t,r,n,o,a))})}function ce(e,t,r,n,o,i,a,s){"/"===i[i.length-1]&&(i=i.substr(0,i.length-1));var u=r.map[o];if("string"==typeof u)return se(o,u,i)?ee.call(e,t,u+i.substr(o.length),n+"/",a,a,s).then(function(t){return ve.call(e,t,n+"/",a)}):Et;var l=[],c=[];for(var d in u){var p=he(d);c.push({condition:p,map:u[d]}),l.push(f.prototype.import.call(e,p.module,n))}return Promise.all(l).then(function(e){for(var t=0;t<c.length;t++){var r=c[t].condition,n=q(r.prop,"__useDefault"in e[t]?e[t].__useDefault:e[t]);if(!r.negate&&n||r.negate&&!n)return c[t].map}}).then(function(r){if(r)return se(o,r,i)?ee.call(e,t,r+i.substr(o.length),n+"/",a,a,s).then(function(t){return ve.call(e,t,n+"/",a)}):Et})}function fe(e){var t=e.lastIndexOf("*"),r=Math.max(t+1,e.lastIndexOf("/"));return{length:r,regEx:new RegExp("^("+e.substr(0,r).replace(/[.+?^${}()|[\]\\]/g,"\\$&").replace(/\*/g,"[^\\/]+")+")(\\/|$)"),wildcard:-1!==t}}function de(e,t){for(var r,n,o=!1,i=0;i<e.packageConfigPaths.length;i++){var a=e.packageConfigPaths[i],s=Dt[a]||(Dt[a]=fe(a));if(!(t.length<s.length)){var u=t.match(s.regEx);!u||r&&(o&&s.wildcard||!(r.length<u[1].length))||(r=u[1],o=!s.wildcard,n=r+a.substr(s.length))}}if(r)return{packageKey:r,configPath:n}}function pe(e,r,n,o,i){var a=e.pluginLoader||e;return-1===r.packageConfigKeys.indexOf(n)&&r.packageConfigKeys.push(n),a.import(n).then(function(e){Oe(o.packageConfig,e,o.packageKey,!0,r),o.packageConfig.configured=!0}).catch(function(e){throw t(e,"Unable to fetch package configuration file "+n)})}function ge(e,t,r){var n;for(var o in e){var i="./"===o.substr(0,2)?"./":"";if(i&&(o=o.substr(2)),-1!==(n=o.indexOf("*"))&&o.substr(0,n)===t.substr(0,n)&&o.substr(n+1)===t.substr(t.length-o.length+n+1)&&r(o,e[i+o],o.split("/").length))return}var a=e[t]&&Object.hasOwnProperty.call(e,t)?e[t]:e["./"+t];a&&r(a,a,0)}function he(e){var t,r,n,o=e.lastIndexOf("|");return-1!==o?(t=e.substr(o+1),r=e.substr(0,o),"~"===t[0]&&(n=!0,t=t.substr(1))):(n="~"===e[0],t="default",r=e.substr(n),-1!==Ut.indexOf(r)&&(t=r,r=null)),{module:r||"@system-env",prop:t,negate:n}}function me(e,t,r){return f.prototype.import.call(this,e.module,t).then(function(t){var n=q(e.prop,t);if(r&&"boolean"!=typeof n)throw new TypeError("Condition did not resolve to a boolean.");return e.negate?!n:n})}function ve(e,t,r){var n=e.match(qt);if(!n)return Promise.resolve(e);var o=he.call(this,n[0].substr(2,n[0].length-3));return me.call(this,o,t,!1).then(function(r){if("string"!=typeof r)throw new TypeError("The condition value for "+e+" doesn't resolve to a string.");if(-1!==r.indexOf("/"))throw new TypeError("Unabled to interpolate conditional "+e+(t?" in "+t:"")+"\n\tThe condition value "+r+' cannot contain a "/" separator.');return e.replace(qt,r)})}function ye(e,t,r){for(var n=0;n<Tt.length;n++){var o=Tt[n];t[o]&&Er[o.substr(0,o.length-6)]&&r(t[o])}}function be(e,t){var r={};for(var n in e){var o=e[n];t>1?o instanceof Array?r[n]=[].concat(o):"object"==typeof o?r[n]=be(o,t-1):"packageConfig"!==n&&(r[n]=o):r[n]=o}return r}function we(e,t){var r=e[t];return r instanceof Array?e[t].concat([]):"object"==typeof r?be(r,3):e[t]}function xe(e){if(e){if(-1!==Or.indexOf(e))return we(this[St],e);throw new Error('"'+e+'" is not a valid configuration name. Must be one of '+Or.join(", ")+".")}for(var t={},r=0;r<Or.length;r++){var n=Or[r],o=we(this[St],n);void 0!==o&&(t[n]=o)}return t}function ke(e,t){var r=this,o=this[St];if("warnings"in e&&(o.warnings=e.warnings),"wasm"in e&&(o.wasm="undefined"!=typeof WebAssembly&&e.wasm),("production"in e||"build"in e)&&tt.call(r,!!e.production,!!(e.build||Er&&Er.build)),!t){var i;ye(r,e,function(e){i=i||e.baseURL}),(i=i||e.baseURL)&&(o.baseURL=n(i,nt)||n("./"+i,nt),"/"!==o.baseURL[o.baseURL.length-1]&&(o.baseURL+="/")),e.paths&&A(o.paths,e.paths),ye(r,e,function(e){e.paths&&A(o.paths,e.paths)});for(var a in o.paths)-1!==o.paths[a].indexOf("*")&&(R.call(o,"Path config "+a+" -> "+o.paths[a]+" is no longer supported as wildcards are deprecated."),delete o.paths[a])}if(e.defaultJSExtensions&&R.call(o,"The defaultJSExtensions configuration option is deprecated.\n  Use packages defaultExtension instead.",!0),"boolean"==typeof e.pluginFirst&&(o.pluginFirst=e.pluginFirst),e.map)for(var a in e.map){var s=e.map[a];if("string"==typeof s){var u=Q.call(r,o,s,void 0,!1,!1);"/"===u[u.length-1]&&":"!==a[a.length-1]&&"/"!==a[a.length-1]&&(u=u.substr(0,u.length-1)),o.map[a]=u}else{m=(m=Q.call(r,o,"/"!==a[a.length-1]?a+"/":a,void 0,!0,!0)).substr(0,m.length-1);var l=o.packages[m];l||((l=o.packages[m]=Ee()).defaultExtension=""),Oe(l,{map:s},m,!1,o)}}if(e.packageConfigPaths){for(var c=[],f=0;f<e.packageConfigPaths.length;f++){var d=e.packageConfigPaths[f],p=Math.max(d.lastIndexOf("*")+1,d.lastIndexOf("/")),g=Q.call(r,o,d.substr(0,p),void 0,!1,!1);c[f]=g+d.substr(p)}o.packageConfigPaths=c}if(e.bundles)for(var a in e.bundles){for(var h=[],f=0;f<e.bundles[a].length;f++)h.push(r.normalizeSync(e.bundles[a][f]));o.bundles[a]=h}if(e.packages)for(var a in e.packages){if(a.match(/^([^\/]+:)?\/\/$/))throw new TypeError('"'+a+'" is not a valid package name.');var m=Q.call(r,o,"/"!==a[a.length-1]?a+"/":a,void 0,!0,!0);m=m.substr(0,m.length-1),Oe(o.packages[m]=o.packages[m]||Ee(),e.packages[a],m,!1,o)}if(e.depCache)for(var a in e.depCache)o.depCache[r.normalizeSync(a)]=[].concat(e.depCache[a]);if(e.meta)for(var a in e.meta)if("*"===a[0])A(o.meta[a]=o.meta[a]||{},e.meta[a]);else{var v=Q.call(r,o,a,void 0,!0,!0);A(o.meta[v]=o.meta[v]||{},e.meta[a])}"transpiler"in e&&(o.transpiler=e.transpiler);for(var y in e)-1===Or.indexOf(y)&&-1===Tt.indexOf(y)&&(r[y]=e[y]);ye(r,e,function(e){r.config(e,!0)})}function Ee(){return{defaultExtension:void 0,main:void 0,format:void 0,meta:void 0,map:void 0,packageConfig:void 0,configured:!1}}function Oe(e,t,r,n,o){for(var i in t)"main"===i||"format"===i||"defaultExtension"===i||"configured"===i?n&&void 0!==e[i]||(e[i]=t[i]):"map"===i?(n?I:A)(e.map=e.map||{},t.map):"meta"===i?(n?I:A)(e.meta=e.meta||{},t.meta):Object.hasOwnProperty.call(t,i)&&R.call(o,'"'+i+'" is not a valid package configuration option in package '+r);return void 0===e.defaultExtension&&(e.defaultExtension="js"),void 0===e.main&&e.map&&e.map["."]?(e.main=e.map["."],delete e.map["."]):"object"==typeof e.main&&(e.map=e.map||{},e.map["./@main"]=e.main,e.main.default=e.main.default||"./",e.main="@main"),e}function Se(e){return zt?Wt+new Buffer(e).toString("base64"):"undefined"!=typeof btoa?Wt+btoa(unescape(encodeURIComponent(e))):""}function je(e,t,r,n){var o=e.lastIndexOf("\n");if(t){if("object"!=typeof t)throw new TypeError("load.metadata.sourceMap must be set to an object.");t=JSON.stringify(t)}return(n?"(function(System, SystemJS) {":"")+e+(n?"\n})(System, System);":"")+("\n//# sourceURL="!=e.substr(o,15)?"\n//# sourceURL="+r+(t?"!transpiled":""):"")+(t&&Se(t)||"")}function _e(e,t,r,n,o){Nt||(Nt=document.head||document.body||document.documentElement);var i=document.createElement("script");i.text=je(t,r,n,!1);var a,s=window.onerror;if(window.onerror=function(e){a=addToError(e,"Evaluating "+n),s&&s.apply(this,arguments)},Pe(e),o&&i.setAttribute("nonce",o),Nt.appendChild(i),Nt.removeChild(i),Me(),window.onerror=s,a)return a}function Pe(e){0==Gt++&&(Bt=st.System),st.System=st.SystemJS=e}function Me(){0==--Gt&&(st.System=st.SystemJS=Bt)}function Re(e,t,r,n,o,i,a){if(t){if(i&&Ht)return _e(e,t,r,n,i);try{Pe(e),!Jt&&e._nodeRequire&&(Jt=e._nodeRequire("vm"),$t=Jt.runInThisContext("typeof System !== 'undefined' && System")===e),$t?Jt.runInThisContext(je(t,r,n,!a),{filename:n+(r?"!transpiled":"")}):(0,eval)(je(t,r,n,!a)),Me()}catch(e){return Me(),e}}}function Ce(e){return"file:///"===e.substr(0,8)?e.substr(7+!!at):Zt&&e.substr(0,Zt.length)===Zt?e.substr(Zt.length):e}function Le(e,t){return Ce(this.normalizeSync(e,t))}function Ae(e){var t,r=e.lastIndexOf("!"),n=(t=-1!==r?e.substr(0,r):e).split("/");return n.pop(),n=n.join("/"),{filename:Ce(t),dirname:Ce(n)}}function Ie(e){function t(e,t){for(var r=0;r<e.length;r++)if(e[r][0]<t.index&&e[r][1]>t.index)return!0;return!1}It.lastIndex=tr.lastIndex=rr.lastIndex=0;var r,n=[],o=[],i=[];if(e.length/e.split("\n").length<200){for(;r=rr.exec(e);)o.push([r.index,r.index+r[0].length]);for(;r=tr.exec(e);)t(o,r)||i.push([r.index+r[1].length,r.index+r[0].length-1])}for(;r=It.exec(e);)if(!t(o,r)&&!t(i,r)){var a=r[1].substr(1,r[1].length-2);if(a.match(/"|'/))continue;n.push(a)}return n}function Fe(e){if(-1===nr.indexOf(e)){try{var t=st[e]}catch(t){nr.push(e)}this(e,t)}}function Ke(e){if("string"==typeof e)return q(e,st);if(!(e instanceof Array))throw new Error("Global exports must be a string or array.");for(var t={},r=0;r<e.length;r++)t[e[r].split(".").pop()]=q(e[r],st);return t}function De(e,t,r,n){var o=st.define;st.define=void 0;var i;if(r){i={};for(var a in r)i[a]=st[a],st[a]=r[a]}return t||(Yt={},Object.keys(st).forEach(Fe,function(e,t){Yt[e]=t})),function(){var e,r=t?Ke(t):{},a=!!t;if(t&&!n||Object.keys(st).forEach(Fe,function(o,i){Yt[o]!==i&&void 0!==i&&(n&&(st[o]=void 0),t||(r[o]=i,void 0!==e?a||e===i||(a=!0):e=i))}),r=a?r:e,i)for(var s in i)st[s]=i[s];return st.define=o,r}}function Ue(e,t){var r=((e=e.replace(tr,"")).match(ar)[1].split(",")[t]||"require").replace(sr,""),n=ur[r]||(ur[r]=new RegExp(or+r+ir,"g"));n.lastIndex=0;for(var o,i=[];o=n.exec(e);)i.push(o[2]||o[3]);return i}function qe(e){return function(t,r,n){e(t,r,n),"object"!=typeof(r=n.exports)&&"function"!=typeof r||"__esModule"in r||Object.defineProperty(n.exports,"__esModule",{value:!0})}}function Te(e,t){Vt=e,cr=t,Qt=void 0,lr=!1}function ze(e){Qt?e.registerDynamic(Vt?Qt[0].concat(Vt):Qt[0],!1,cr?qe(Qt[1]):Qt[1]):lr&&e.registerDynamic([],!1,_)}function Ne(e,t){!e.load.esModule||"object"!=typeof t&&"function"!=typeof t||"__esModule"in t||Object.defineProperty(t,"__esModule",{value:!0})}function Je(e,t){var r=this,n=this[St];return(Be(n,this,e)||Et).then(function(){if(!t()){var o=r[jt][e];if("@node/"===e.substr(0,6)){if(!r._nodeRequire)throw new TypeError("Error loading "+e+". Can only load node core modules in Node.");return r.registerDynamic([],!1,function(){return L.call(r,e.substr(6),r.baseURL)}),void t()}return o.load.scriptLoad?!o.load.pluginKey&&fr||(o.load.scriptLoad=!1,R.call(n,'scriptLoad not supported for "'+e+'"')):!1!==o.load.scriptLoad&&!o.load.pluginKey&&fr&&(o.load.deps||o.load.globals||!("system"===o.load.format||"register"===o.load.format||"global"===o.load.format&&o.load.exports)||(o.load.scriptLoad=!0)),o.load.scriptLoad?new Promise(function(n,i){if("amd"===o.load.format&&st.define!==r.amdDefine)throw new Error("Loading AMD with scriptLoad requires setting the global `"+pr+".define = SystemJS.amdDefine`");U(e,o.load.crossOrigin,o.load.integrity,function(){if(!t()){o.load.format="global";var e=o.load.exports&&Ke(o.load.exports);r.registerDynamic([],!1,function(){return Ne(o,e),e}),t()}n()},i)}):$e(r,e,o).then(function(){return We(r,e,o,t,n.wasm)})}}).then(function(t){return delete r[jt][e],t})}function $e(e,t,r){return r.pluginKey?e.import(r.pluginKey).then(function(e){r.pluginModule=e,r.pluginLoad={name:t,address:r.pluginArgument,source:void 0,metadata:r.load},r.load.deps=r.load.deps||[]}):Et}function Be(e,t,r){var n=e.depCache[r];if(n)for(a=0;a<n.length;a++)t.normalize(n[a],r).then(K);else{var o=!1;for(var i in e.bundles){for(var a=0;a<e.bundles[i].length;a++){var s=e.bundles[i][a];if(s===r){o=!0;break}if(-1!==s.indexOf("*")){var u=s.split("*");if(2!==u.length){e.bundles[i].splice(a--,1);continue}if(r.substr(0,u[0].length)===u[0]&&r.substr(r.length-u[1].length,u[1].length)===u[1]){o=!0;break}}}if(o)return t.import(i)}}}function We(e,t,r,n,o){return r.load.exports&&!r.load.format&&(r.load.format="global"),Et.then(function(){if(r.pluginModule&&r.pluginModule.locate)return Promise.resolve(r.pluginModule.locate.call(e,r.pluginLoad)).then(function(e){e&&(r.pluginLoad.address=e)})}).then(function(){return r.pluginModule?(o=!1,r.pluginModule.fetch?r.pluginModule.fetch.call(e,r.pluginLoad,function(e){return Kt(e.address,r.load.authorization,r.load.integrity,!1)}):Kt(r.pluginLoad.address,r.load.authorization,r.load.integrity,!1)):Kt(t,r.load.authorization,r.load.integrity,o)}).then(function(i){return o&&"string"!=typeof i?C(e,i,n).then(function(o){if(!o){var a=ot?new TextDecoder("utf-8").decode(new Uint8Array(i)):i.toString();return Ge(e,t,a,r,n)}}):Ge(e,t,i,r,n)})}function Ge(e,t,r,n,o){return Promise.resolve(r).then(function(t){return"detect"===n.load.format&&(n.load.format=void 0),Ve(t,n),n.pluginModule?(n.pluginLoad.source=t,n.pluginModule.translate?Promise.resolve(n.pluginModule.translate.call(e,n.pluginLoad,n.traceOpts)).then(function(e){if(n.load.sourceMap){if("object"!=typeof n.load.sourceMap)throw new Error("metadata.load.sourceMap must be set to an object.");Xe(n.pluginLoad.address,n.load.sourceMap)}return"string"==typeof e?e:n.pluginLoad.source}):t):t}).then(function(r){return n.load.format||'"bundle"'!==r.substring(0,8)?"register"===n.load.format||!n.load.format&&He(r)?(n.load.format="register",r):"esm"===n.load.format||!n.load.format&&r.match(gr)?(n.load.format="esm",Ye(e,r,t,n,o)):r:(n.load.format="system",r)}).then(function(t){if("string"!=typeof t||!n.pluginModule||!n.pluginModule.instantiate)return t;var r=!1;return n.pluginLoad.source=t,Promise.resolve(n.pluginModule.instantiate.call(e,n.pluginLoad,function(e){if(t=e.source,n.load=e.metadata,r)throw new Error("Instantiate must only be called once.");r=!0})).then(function(e){return r?t:P(e)})}).then(function(r){if("string"!=typeof r)return r;n.load.format||(n.load.format=Ze(r));var i=!1;switch(n.load.format){case"esm":case"register":case"system":if(u=Re(e,r,n.load.sourceMap,t,n.load.integrity,n.load.nonce,!1))throw u;if(!o())return Ot;return;case"json":var a=JSON.parse(r);return e.newModule({default:a,__useDefault:a});case"amd":var s=st.define;st.define=e.amdDefine,Te(n.load.deps,n.load.esModule);var u=Re(e,r,n.load.sourceMap,t,n.load.integrity,n.load.nonce,!1);if((i=o())||(ze(e),i=o()),st.define=s,u)throw u;break;case"cjs":var l=n.load.deps,c=(n.load.deps||[]).concat(n.load.cjsRequireDetection?Ie(r):[]);for(var f in n.load.globals)n.load.globals[f]&&c.push(n.load.globals[f]);e.registerDynamic(c,!0,function(o,i,a){if(o.resolve=function(t){return Le.call(e,t,a.id)},a.paths=[],a.require=o,!n.load.cjsDeferDepsExecute&&l)for(var s=0;s<l.length;s++)o(l[s]);var u=Ae(a.id),c={exports:i,args:[o,i,a,u.filename,u.dirname,st,st]},f="(function (require, exports, module, __filename, __dirname, global, GLOBAL";if(n.load.globals)for(var d in n.load.globals)c.args.push(o(n.load.globals[d])),f+=", "+d;var p=st.define;st.define=void 0,st.__cjsWrapper=c,r=f+") {"+r.replace(yr,"")+"\n}).apply(__cjsWrapper.exports, __cjsWrapper.args);";var g=Re(e,r,n.load.sourceMap,t,n.load.integrity,n.load.nonce,!1);if(g)throw g;Ne(n,i),st.__cjsWrapper=void 0,st.define=p}),i=o();break;case"global":c=n.load.deps||[];for(var f in n.load.globals){var d=n.load.globals[f];d&&c.push(d)}e.registerDynamic(c,!1,function(o,i,a){var s;if(n.load.globals){s={};for(var u in n.load.globals)n.load.globals[u]&&(s[u]=o(n.load.globals[u]))}var l=n.load.exports;l&&(r+="\n"+pr+'["'+l+'"] = '+l+";");var c=De(a.id,l,s,n.load.encapsulateGlobal),f=Re(e,r,n.load.sourceMap,t,n.load.integrity,n.load.nonce,!0);if(f)throw f;var d=c();return Ne(n,d),d}),i=o();break;default:throw new TypeError('Unknown module format "'+n.load.format+'" for "'+t+'".'+("es6"===n.load.format?' Use "esm" instead here.':""))}if(!i)throw new Error("Module "+t+" detected as "+n.load.format+" but didn't execute correctly.")})}function He(e){var t=e.match(hr);return t&&"System.register"===e.substr(t[0].length,15)}function Ze(e){return e.match(mr)?"amd":(vr.lastIndex=0,It.lastIndex=0,It.exec(e)||vr.exec(e)?"cjs":"global")}function Xe(e,t){var r=e.split("!")[0];t.file&&t.file!=e||(t.file=r+"!transpiled"),(!t.sources||t.sources.length<=1&&(!t.sources[0]||t.sources[0]===e))&&(t.sources=[r])}function Ye(e,r,n,o,i){if(!e.transpiler)throw new TypeError("Unable to dynamically transpile ES module\n   A loader plugin needs to be configured via `SystemJS.config({ transpiler: 'transpiler-module' })`.");if(o.load.deps){for(var a="",s=0;s<o.load.deps.length;s++)a+='import "'+o.load.deps[s]+'"; ';r=a+r}return e.import.call(e,e.transpiler).then(function(t){if(!(t=t.__useDefault||t).translate)throw new Error(e.transpiler+" is not a valid transpiler plugin.");return t===o.pluginModule?r:("string"==typeof o.load.sourceMap&&(o.load.sourceMap=JSON.parse(o.load.sourceMap)),o.pluginLoad=o.pluginLoad||{name:n,address:n,source:r,metadata:o.load},o.load.deps=o.load.deps||[],Promise.resolve(t.translate.call(e,o.pluginLoad,o.traceOpts)).then(function(e){var t=o.load.sourceMap;return t&&"object"==typeof t&&Xe(n,t),"esm"===o.load.format&&He(e)&&(o.load.format="register"),e}))},function(e){throw t(e,"Unable to load transpiler to transpile "+n)})}function Qe(e,t,r){for(var n,o=t.split(".");o.length>1;)e=e[n=o.shift()]=e[n]||{};void 0===e[n=o.shift()]&&(e[n]=r)}function Ve(e,t){var r=e.match(br);if(r)for(var n=r[0].match(wr),o=0;o<n.length;o++){var i=n[o],a=i.length,s=i.substr(0,1);if(";"==i.substr(a-1,1)&&a--,'"'==s||"'"==s){var u=i.substr(1,i.length-3),l=u.substr(0,u.indexOf(" "));if(l){var c=u.substr(l.length+1,u.length-l.length-1);"deps"===l&&(l="deps[]"),"[]"===l.substr(l.length-2,2)?(l=l.substr(0,l.length-2),t.load[l]=t.load[l]||[],t.load[l].push(c)):"use"!==l&&Qe(t.load,l,c)}else t.load[u]=!0}}}function et(){f.call(this),this._loader={},this[jt]={},this[St]={baseURL:nt,paths:{},packageConfigPaths:[],packageConfigKeys:[],map:{},packages:{},depCache:{},meta:{},bundles:{},production:!1,transpiler:void 0,loadedBundles:{},warnings:!1,pluginFirst:!1,wasm:!1},this.scriptSrc=dr,this._nodeRequire=er,this.registry.set("@empty",Ot),tt.call(this,!1,!1),Xt(this)}function tt(e,t){this[St].production=e,this.registry.set("@system-env",Er=this.newModule({browser:ot,node:!!this._nodeRequire,production:!t&&e,dev:t||!e,build:t,default:!0}))}function rt(e,t){R.call(e[St],"SystemJS."+t+" is deprecated for SystemJS.registry."+t)}var nt,ot="undefined"!=typeof window&&"undefined"!=typeof document,it="undefined"!=typeof process&&process.versions&&process.versions.node,at="undefined"!=typeof process&&"string"==typeof process.platform&&process.platform.match(/^win/),st="undefined"!=typeof self?self:global,ut="undefined"!=typeof Symbol;if("undefined"!=typeof document&&document.getElementsByTagName){if(!(nt=document.baseURI)){var lt=document.getElementsByTagName("base");nt=lt[0]&&lt[0].href||window.location.href}}else"undefined"!=typeof location&&(nt=location.href);if(nt){var ct=(nt=nt.split("#")[0].split("?")[0]).lastIndexOf("/");-1!==ct&&(nt=nt.substr(0,ct+1))}else{if("undefined"==typeof process||!process.cwd)throw new TypeError("No environment baseURI");nt="file://"+(at?"/":"")+process.cwd(),at&&(nt=nt.replace(/\\/g,"/"))}"/"!==nt[nt.length-1]&&(nt+="/");var ft="_"==new Error(0,"_").fileName,dt=Promise.resolve();i.prototype.constructor=i,i.prototype.import=function(e,r){if("string"!=typeof e)throw new TypeError("Loader import method must be passed a module key string");var n=this;return dt.then(function(){return n[gt](e,r)}).then(a).catch(function(n){throw t(n,"Loading "+e+(r?" from "+r:""))})};var pt=i.resolve=e("resolve"),gt=i.resolveInstantiate=e("resolveInstantiate");i.prototype[gt]=function(e,t){var r=this;return r.resolve(e,t).then(function(e){return r.registry.get(e)})},i.prototype.resolve=function(e,r){var n=this;return dt.then(function(){return n[pt](e,r)}).then(s).catch(function(n){throw t(n,"Resolving "+e+(r?" to "+r:""))})};var ht="undefined"!=typeof Symbol&&Symbol.iterator,mt=e("registry");ht&&(u.prototype[Symbol.iterator]=function(){return this.entries()[Symbol.iterator]()},u.prototype.entries=function(){var e=this[mt];return o(Object.keys(e).map(function(t){return[t,e[t]]}))}),u.prototype.keys=function(){return o(Object.keys(this[mt]))},u.prototype.values=function(){var e=this[mt];return o(Object.keys(e).map(function(t){return e[t]}))},u.prototype.get=function(e){return this[mt][e]},u.prototype.set=function(e,t){if(!(t instanceof l))throw new Error("Registry must be set with an instance of Module Namespace");return this[mt][e]=t,this},u.prototype.has=function(e){return Object.hasOwnProperty.call(this[mt],e)},u.prototype.delete=function(e){return!!Object.hasOwnProperty.call(this[mt],e)&&(delete this[mt][e],!0)};var vt=e("baseObject");l.prototype=Object.create(null),"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(l.prototype,Symbol.toStringTag,{value:"Module"});var yt=e("register-internal");f.prototype=Object.create(i.prototype),f.prototype.constructor=f;var bt=f.instantiate=e("instantiate");f.prototype[f.resolve=i.resolve]=function(e,t){return n(e,t||nt)},f.prototype[bt]=function(e,t){},f.prototype[i.resolveInstantiate]=function(e,t){var r=this,n=this[yt],o=this.registry[mt];return p(r,e,t,o,n).then(function(e){if(e instanceof l)return e;var t=e.linkRecord;if(!t){if(e.module)return e.module;throw e.evalError}return w(r,e,t,o,n).then(function(){return k(r,e,t,o,n,void 0)})})},f.prototype.register=function(e,t,r){var n=this[yt];void 0===r?n.lastRegister=[e,t,void 0]:(n.records[e]||d(n,e,void 0)).registration=[t,r,void 0]},f.prototype.registerDynamic=function(e,t,r,n){var o=this[yt];"string"!=typeof e?o.lastRegister=[e,t,r]:(o.records[e]||d(o,e,void 0)).registration=[t,r,n]},x.prototype.import=function(e){return this.loader.trace&&this.loader.loads[this.key].dynamicDeps.push(e),this.loader.import(e,this.key)};var wt={};Object.freeze&&Object.freeze(wt);var xt,kt,Et=Promise.resolve(),Ot=new l({}),St=e("loader-config"),jt=e("metadata"),_t="undefined"==typeof window&&"undefined"!=typeof self&&"undefined"!=typeof importScripts,Pt=!1,Mt=!1;if(ot&&function(){var e=document.createElement("link").relList;if(e&&e.supports){Mt=!0;try{Pt=e.supports("preload")}catch(e){}}}(),ot){var Rt=[],Ct=window.onerror;window.onerror=function(e,t){for(var r=0;r<Rt.length;r++)if(Rt[r].src===t)return void Rt[r].err(e);Ct&&Ct.apply(this,arguments)}}var Lt,At,It=/(?:^\uFEFF?|[^$_a-zA-Z\xA0-\uFFFF."'])require\s*\(\s*("[^"\\]*(?:\\.[^"\\]*)*"|'[^'\\]*(?:\\.[^'\\]*)*'|`[^`\\]*(?:\\.[^`\\]*)*`)\s*\)/g,Ft="undefined"!=typeof XMLHttpRequest,Kt=At="undefined"!=typeof self&&void 0!==self.fetch?J:Ft?$:"undefined"!="function"&&"undefined"!=typeof process?B:W,Dt={},Ut=["browser","node","dev","build","production","default"],qt=/#\{[^\}]+\}/,Tt=["browserConfig","nodeConfig","devConfig","buildConfig","productionConfig"],zt="undefined"!=typeof Buffer;try{zt&&"YQ=="!==new Buffer("a").toString("base64")&&(zt=!1)}catch(e){zt=!1}var Nt,Jt,$t,Bt,Wt="\n//# sourceMappingURL=data:application/json;base64,",Gt=0,Ht=!1;ot&&"undefined"!=typeof document&&document.getElementsByTagName&&(window.chrome&&window.chrome.extension||navigator.userAgent.match(/^Node\.js/)||(Ht=!0));var Zt,Xt=function(e){function t(r,n,o,i){if("object"==typeof r&&!(r instanceof Array))return t.apply(null,Array.prototype.splice.call(arguments,1,arguments.length-1));if("string"==typeof r&&"function"==typeof n&&(r=[r]),!(r instanceof Array)){if("string"==typeof r){var a=e.decanonicalize(r,i),s=e.get(a);if(!s)throw new Error('Module not already loaded loading "'+r+'" as '+a+(i?' from "'+i+'".':"."));return"__useDefault"in s?s.__useDefault:s}throw new TypeError("Invalid require")}for(var u=[],l=0;l<r.length;l++)u.push(e.import(r[l],i));Promise.all(u).then(function(e){n&&n.apply(null,e)},o)}function r(r,n,o){function i(r,i,l){for(var c=[],f=0;f<n.length;f++)c.push(r(n[f]));if(l.uri=l.id,l.config=_,-1!==u&&c.splice(u,0,l),-1!==s&&c.splice(s,0,i),-1!==a){var d=function(n,o,i){return"string"==typeof n&&"function"!=typeof o?r(n):t.call(e,n,o,i,l.id)};d.toUrl=function(t){return e.normalizeSync(t,l.id)},c.splice(a,0,d)}var p=st.require;st.require=t;var g=o.apply(-1===s?st:i,c);st.require=p,void 0!==g&&(l.exports=g)}"string"!=typeof r&&(o=n,n=r,r=null),n instanceof Array||(o=n,n=["require","exports","module"].splice(0,o.length)),"function"!=typeof o&&(o=function(e){return function(){return e}}(o)),r||Vt&&(n=n.concat(Vt),Vt=void 0);var a,s,u;-1!==(a=n.indexOf("require"))&&(n.splice(a,1),r||(n=n.concat(Ue(o.toString(),a)))),-1!==(s=n.indexOf("exports"))&&n.splice(s,1),-1!==(u=n.indexOf("module"))&&n.splice(u,1),r?(e.registerDynamic(r,n,!1,i),Qt?(Qt=void 0,lr=!0):lr||(Qt=[n,i])):e.registerDynamic(n,!1,cr?qe(i):i)}e.set("@@cjs-helpers",e.newModule({requireResolve:Le.bind(e),getPathVars:Ae})),e.set("@@global-helpers",e.newModule({prepareGlobal:De})),r.amd={},e.amdDefine=r,e.amdRequire=t};"undefined"!=typeof window&&"undefined"!=typeof document&&window.location&&(Zt=location.protocol+"//"+location.hostname+(location.port?":"+location.port:""));var Yt,Qt,Vt,er,tr=/(^|[^\\])(\/\*([\s\S]*?)\*\/|([^:]|^)\/\/(.*)$)/gm,rr=/("[^"\\\n\r]*(\\.[^"\\\n\r]*)*"|'[^'\\\n\r]*(\\.[^'\\\n\r]*)*')/g,nr=["_g","sessionStorage","localStorage","clipboardData","frames","frameElement","external","mozAnimationStartTime","webkitStorageInfo","webkitIndexedDB","mozInnerScreenY","mozInnerScreenX"],or="(?:^|[^$_a-zA-Z\\xA0-\\uFFFF.])",ir="\\s*\\(\\s*(\"([^\"]+)\"|'([^']+)')\\s*\\)",ar=/\(([^\)]*)\)/,sr=/^\s+|\s+$/g,ur={},lr=!1,cr=!1,fr=(ot||_t)&&"undefined"!=typeof navigator&&navigator.userAgent&&!navigator.userAgent.match(/MSIE (9|10).0/);"undefined"=="function"||"undefined"==typeof process||process.browser||(er=require);var dr,pr="undefined"!=typeof self?"self":"global",gr=/(^\s*|[}\);\n]\s*)(import\s*(['"]|(\*\s+as\s+)?(?!type)([^"'\(\)\n; ]+)\s*from\s*['"]|\{)|export\s+\*\s+from\s+["']|export\s*(\{|default|function|class|var|const|let|async\s+function))/,hr=/^(\s*\/\*[^\*]*(\*(?!\/)[^\*]*)*\*\/|\s*\/\/[^\n]*|\s*"[^"]+"\s*;?|\s*'[^']+'\s*;?)*\s*/,mr=/(?:^\uFEFF?|[^$_a-zA-Z\xA0-\uFFFF.])define\s*\(\s*("[^"]+"\s*,\s*|'[^']+'\s*,\s*)?\s*(\[(\s*(("[^"]+"|'[^']+')\s*,|\/\/.*\r?\n|\/\*(.|\s)*?\*\/))*(\s*("[^"]+"|'[^']+')\s*,?)?(\s*(\/\/.*\r?\n|\/\*(.|\s)*?\*\/))*\s*\]|function\s*|{|[_$a-zA-Z\xA0-\uFFFF][_$a-zA-Z0-9\xA0-\uFFFF]*\))/,vr=/(?:^\uFEFF?|[^$_a-zA-Z\xA0-\uFFFF.])(exports\s*(\[['"]|\.)|module(\.exports|\['exports'\]|\["exports"\])\s*(\[['"]|[=,\.]))/,yr=/^\#\!.*/,br=/^(\s*\/\*[^\*]*(\*(?!\/)[^\*]*)*\*\/|\s*\/\/[^\n]*|\s*"[^"]+"\s*;?|\s*'[^']+'\s*;?)+/,wr=/\/\*[^\*]*(\*(?!\/)[^\*]*)*\*\/|\/\/[^\n]*|"[^"]+"\s*;?|'[^']+'\s*;?/g;if("undefined"==typeof Promise)throw new Error("SystemJS needs a Promise polyfill.");if("undefined"!=typeof document){var xr=document.getElementsByTagName("script"),kr=xr[xr.length-1];document.currentScript&&(kr.defer||kr.async)&&(kr=document.currentScript),dr=kr&&kr.src}else if("undefined"!=typeof importScripts)try{throw new Error("_")}catch(e){e.stack.replace(/(?:at|@).*(http.+):[\d]+:[\d]+/,function(e,t){dr=t})}else"undefined"!=typeof __filename&&(dr=__filename);var Er;et.prototype=Object.create(f.prototype),et.prototype.constructor=et,et.prototype[et.resolve=f.resolve]=et.prototype.normalize=Z,et.prototype.load=function(e,t){return R.call(this[St],"System.load is deprecated."),this.import(e,t)},et.prototype.decanonicalize=et.prototype.normalizeSync=et.prototype.resolveSync=Y,et.prototype[et.instantiate=f.instantiate]=Je,et.prototype.config=ke,et.prototype.getConfig=xe,et.prototype.global=st,et.prototype.import=function(){return f.prototype.import.apply(this,arguments).then(function(e){return"__useDefault"in e?e.__useDefault:e})};for(var Or=["baseURL","map","paths","packages","packageConfigPaths","depCache","meta","bundles","transpiler","warnings","pluginFirst","production","wasm"],Sr="undefined"!=typeof Proxy,jr=0;jr<Or.length;jr++)!function(e){Object.defineProperty(et.prototype,e,{get:function(){var t=we(this[St],e);return Sr&&"object"==typeof t&&(t=new Proxy(t,{set:function(t,r){throw new Error("Cannot set SystemJS."+e+'["'+r+'"] directly. Use SystemJS.config({ '+e+': { "'+r+'": ... } }) rather.')}})),t},set:function(t){throw new Error("Setting `SystemJS."+e+"` directly is no longer supported. Use `SystemJS.config({ "+e+": ... })`.")}})}(Or[jr]);et.prototype.delete=function(e){return rt(this,"delete"),this.registry.delete(e)},et.prototype.get=function(e){return rt(this,"get"),this.registry.get(e)},et.prototype.has=function(e){return rt(this,"has"),this.registry.has(e)},et.prototype.set=function(e,t){return rt(this,"set"),this.registry.set(e,t)},et.prototype.newModule=function(e){return new l(e)},et.prototype.isModule=M,et.prototype.register=function(e,t,r){return"string"==typeof e&&(e=X.call(this,this[St],e)),f.prototype.register.call(this,e,t,r)},et.prototype.registerDynamic=function(e,t,r,n){return"string"==typeof e&&(e=X.call(this,this[St],e)),f.prototype.registerDynamic.call(this,e,t,r,n)},et.prototype.version="0.20.19 Dev";var _r=new et;(ot||_t)&&(st.SystemJS=st.System=_r),"undefined"!=typeof module&&module.exports&&(module.exports=_r)}();
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1420).Buffer, __webpack_require__(1424), __webpack_require__(54), "/index.js"))

/***/ }),

/***/ 1420:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */



var base64 = __webpack_require__(1421)
var ieee754 = __webpack_require__(1422)
var isArray = __webpack_require__(1423)

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength()

function typedArraySupport () {
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length)
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length)
    }
    that.length = length
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype
  return arr
}

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    })
  }
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
}

function allocUnsafe (that, size) {
  assertSize(size)
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  that = createBuffer(that, length)

  var actual = that.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual)
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  that = createBuffer(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array)
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset)
  } else {
    array = new Uint8Array(array, byteOffset, length)
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array)
  }
  return that
}

function fromObject (that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    that = createBuffer(that, len)

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len)
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end)
    newBuf.__proto__ = Buffer.prototype
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start]
    }
  }

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString())
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(54)))

/***/ }),

/***/ 1421:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function placeHoldersCount (b64) {
  var len = b64.length
  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // the number of equal signs (place holders)
  // if there are two placeholders, than the two characters before it
  // represent one byte
  // if there is only one, then the three characters before it represent 2 bytes
  // this is just a cheap hack to not do indexOf twice
  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0
}

function byteLength (b64) {
  // base64 is 4/3 + up to two characters of the original data
  return (b64.length * 3 / 4) - placeHoldersCount(b64)
}

function toByteArray (b64) {
  var i, l, tmp, placeHolders, arr
  var len = b64.length
  placeHolders = placeHoldersCount(b64)

  arr = new Arr((len * 3 / 4) - placeHolders)

  // if there are placeholders, only get up to the last complete 4 chars
  l = placeHolders > 0 ? len - 4 : len

  var L = 0

  for (i = 0; i < l; i += 4) {
    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]
    arr[L++] = (tmp >> 16) & 0xFF
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  if (placeHolders === 2) {
    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[L++] = tmp & 0xFF
  } else if (placeHolders === 1) {
    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var output = ''
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    output += lookup[tmp >> 2]
    output += lookup[(tmp << 4) & 0x3F]
    output += '=='
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])
    output += lookup[tmp >> 10]
    output += lookup[(tmp >> 4) & 0x3F]
    output += lookup[(tmp << 2) & 0x3F]
    output += '='
  }

  parts.push(output)

  return parts.join('')
}


/***/ }),

/***/ 1422:
/***/ (function(module, exports) {

exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}


/***/ }),

/***/ 1423:
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};


/***/ }),

/***/ 1424:
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),

/***/ 1425:
/***/ (function(module, exports) {



/***/ }),

/***/ 1426:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return MetricsPanelCtrl; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_app_core_config__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_jquery__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_jquery___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_jquery__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_lodash__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_app_core_utils_kbn__ = __webpack_require__(464);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_app_features_panel_panel_ctrl__ = __webpack_require__(1313);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_app_core_utils_rangeutil__ = __webpack_require__(471);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_app_core_utils_datemath__ = __webpack_require__(467);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__metrics_tab__ = __webpack_require__(1427);
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();








var MetricsPanelCtrl = /** @class */ (function (_super) {
    __extends(MetricsPanelCtrl, _super);
    function MetricsPanelCtrl($scope, $injector) {
        var _this = _super.call(this, $scope, $injector) || this;
        // make metrics tab the default
        _this.editorTabIndex = 1;
        _this.$q = $injector.get('$q');
        _this.datasourceSrv = $injector.get('datasourceSrv');
        _this.timeSrv = $injector.get('timeSrv');
        _this.templateSrv = $injector.get('templateSrv');
        _this.scope = $scope;
        _this.panel.datasource = _this.panel.datasource || null;
        if (!_this.panel.targets) {
            _this.panel.targets = [{}];
        }
        _this.events.on('refresh', _this.onMetricsPanelRefresh.bind(_this));
        _this.events.on('init-edit-mode', _this.onInitMetricsPanelEditMode.bind(_this));
        _this.events.on('panel-teardown', _this.onPanelTearDown.bind(_this));
        return _this;
    }
    MetricsPanelCtrl.prototype.onPanelTearDown = function () {
        if (this.dataSubscription) {
            this.dataSubscription.unsubscribe();
            this.dataSubscription = null;
        }
    };
    MetricsPanelCtrl.prototype.onInitMetricsPanelEditMode = function () {
        this.addEditorTab('Metrics', __WEBPACK_IMPORTED_MODULE_7__metrics_tab__["a" /* metricsTabDirective */]);
        this.addEditorTab('Time range', 'public/app/features/panel/partials/panelTime.html');
    };
    MetricsPanelCtrl.prototype.onMetricsPanelRefresh = function () {
        var _this = this;
        // ignore fetching data if another panel is in fullscreen
        if (this.otherPanelInFullscreenMode()) {
            return;
        }
        // if we have snapshot data use that
        if (this.panel.snapshotData) {
            this.updateTimeRange();
            var data = this.panel.snapshotData;
            // backward compatability
            if (!__WEBPACK_IMPORTED_MODULE_2_lodash___default.a.isArray(data)) {
                data = data.data;
            }
            this.events.emit('data-snapshot-load', data);
            return;
        }
        // // ignore if we have data stream
        if (this.dataStream) {
            return;
        }
        // clear loading/error state
        delete this.error;
        this.loading = true;
        // load datasource service
        this.setTimeQueryStart();
        this.datasourceSrv.get(this.panel.datasource)
            .then(this.updateTimeRange.bind(this))
            .then(this.issueQueries.bind(this))
            .then(this.handleQueryResult.bind(this))
            .catch(function (err) {
            // if cancelled  keep loading set to true
            if (err.cancelled) {
                console.log('Panel request cancelled', err);
                return;
            }
            _this.loading = false;
            _this.error = err.message || "Request Error";
            _this.inspector = { error: err };
            if (err.data) {
                if (err.data.message) {
                    _this.error = err.data.message;
                }
                if (err.data.error) {
                    _this.error = err.data.error;
                }
            }
            _this.events.emit('data-error', err);
            console.log('Panel data error:', err);
        });
    };
    MetricsPanelCtrl.prototype.setTimeQueryStart = function () {
        this.timing.queryStart = new Date().getTime();
    };
    MetricsPanelCtrl.prototype.setTimeQueryEnd = function () {
        this.timing.queryEnd = new Date().getTime();
    };
    MetricsPanelCtrl.prototype.updateTimeRange = function (datasource) {
        this.datasource = datasource || this.datasource;
        this.range = this.timeSrv.timeRange();
        this.applyPanelTimeOverrides();
        if (this.panel.maxDataPoints) {
            this.resolution = this.panel.maxDataPoints;
        }
        else {
            this.resolution = Math.ceil(__WEBPACK_IMPORTED_MODULE_1_jquery___default()(window).width() * (this.panel.span / 12));
        }
        this.calculateInterval();
        return this.datasource;
    };
    MetricsPanelCtrl.prototype.calculateInterval = function () {
        var intervalOverride = this.panel.interval;
        // if no panel interval check datasource
        if (intervalOverride) {
            intervalOverride = this.templateSrv.replace(intervalOverride, this.panel.scopedVars);
        }
        else if (this.datasource && this.datasource.interval) {
            intervalOverride = this.datasource.interval;
        }
        var res = __WEBPACK_IMPORTED_MODULE_3_app_core_utils_kbn__["default"].calculateInterval(this.range, this.resolution, intervalOverride);
        this.interval = res.interval;
        this.intervalMs = res.intervalMs;
    };
    MetricsPanelCtrl.prototype.applyPanelTimeOverrides = function () {
        this.timeInfo = '';
        // check panel time overrrides
        if (this.panel.timeFrom) {
            var timeFromInterpolated = this.templateSrv.replace(this.panel.timeFrom, this.panel.scopedVars);
            var timeFromInfo = __WEBPACK_IMPORTED_MODULE_5_app_core_utils_rangeutil__["a" /* describeTextRange */](timeFromInterpolated);
            if (timeFromInfo.invalid) {
                this.timeInfo = 'invalid time override';
                return;
            }
            if (__WEBPACK_IMPORTED_MODULE_2_lodash___default.a.isString(this.range.raw.from)) {
                var timeFromDate = __WEBPACK_IMPORTED_MODULE_6_app_core_utils_datemath__["parse"](timeFromInfo.from);
                this.timeInfo = timeFromInfo.display;
                this.range.from = timeFromDate;
                this.range.to = __WEBPACK_IMPORTED_MODULE_6_app_core_utils_datemath__["parse"](timeFromInfo.to);
                this.range.raw.from = timeFromInfo.from;
                this.range.raw.to = timeFromInfo.to;
            }
        }
        if (this.panel.timeShift) {
            var timeShiftInterpolated = this.templateSrv.replace(this.panel.timeShift, this.panel.scopedVars);
            var timeShiftInfo = __WEBPACK_IMPORTED_MODULE_5_app_core_utils_rangeutil__["a" /* describeTextRange */](timeShiftInterpolated);
            if (timeShiftInfo.invalid) {
                this.timeInfo = 'invalid timeshift';
                return;
            }
            var timeShift = '-' + timeShiftInterpolated;
            this.timeInfo += ' timeshift ' + timeShift;
            this.range.from = __WEBPACK_IMPORTED_MODULE_6_app_core_utils_datemath__["parseDateMath"](timeShift, this.range.from, false);
            this.range.to = __WEBPACK_IMPORTED_MODULE_6_app_core_utils_datemath__["parseDateMath"](timeShift, this.range.to, true);
            this.range.raw = { from: this.range.from, to: this.range.to };
        }
        if (this.panel.hideTimeOverride) {
            this.timeInfo = '';
        }
    };
    MetricsPanelCtrl.prototype.issueQueries = function (datasource) {
        this.datasource = datasource;
        if (!this.panel.targets || this.panel.targets.length === 0) {
            return this.$q.when([]);
        }
        // make shallow copy of scoped vars,
        // and add built in variables interval and interval_ms
        var scopedVars = Object.assign({}, this.panel.scopedVars, {
            "__interval": { text: this.interval, value: this.interval },
            "__interval_ms": { text: this.intervalMs, value: this.intervalMs },
        });
        var metricsQuery = {
            timezone: this.dashboard.getTimezone(),
            panelId: this.panel.id,
            range: this.range,
            rangeRaw: this.range.raw,
            interval: this.interval,
            intervalMs: this.intervalMs,
            targets: this.panel.targets,
            maxDataPoints: this.resolution,
            scopedVars: scopedVars,
            cacheTimeout: this.panel.cacheTimeout
        };
        return datasource.query(metricsQuery);
    };
    MetricsPanelCtrl.prototype.handleQueryResult = function (result) {
        this.setTimeQueryEnd();
        this.loading = false;
        // check for if data source returns subject
        if (result && result.subscribe) {
            this.handleDataStream(result);
            return;
        }
        if (this.dashboard.snapshot) {
            this.panel.snapshotData = result.data;
        }
        if (!result || !result.data) {
            console.log('Data source query result invalid, missing data field:', result);
            result = { data: [] };
        }
        this.events.emit('data-received', result.data);
    };
    MetricsPanelCtrl.prototype.handleDataStream = function (stream) {
        var _this = this;
        // if we already have a connection
        if (this.dataStream) {
            console.log('two stream observables!');
            return;
        }
        this.dataStream = stream;
        this.dataSubscription = stream.subscribe({
            next: function (data) {
                console.log('dataSubject next!');
                if (data.range) {
                    _this.range = data.range;
                }
                _this.events.emit('data-received', data.data);
            },
            error: function (error) {
                _this.events.emit('data-error', error);
                console.log('panel: observer got error');
            },
            complete: function () {
                console.log('panel: observer got complete');
                _this.dataStream = null;
            }
        });
    };
    MetricsPanelCtrl.prototype.setDatasource = function (datasource) {
        var _this = this;
        // switching to mixed
        if (datasource.meta.mixed) {
            __WEBPACK_IMPORTED_MODULE_2_lodash___default.a.each(this.panel.targets, function (target) {
                target.datasource = _this.panel.datasource;
                if (!target.datasource) {
                    target.datasource = __WEBPACK_IMPORTED_MODULE_0_app_core_config__["default"].defaultDatasource;
                }
            });
        }
        else if (this.datasource && this.datasource.meta.mixed) {
            __WEBPACK_IMPORTED_MODULE_2_lodash___default.a.each(this.panel.targets, function (target) {
                delete target.datasource;
            });
        }
        this.panel.datasource = datasource.value;
        this.datasourceName = datasource.name;
        this.datasource = null;
        this.refresh();
    };
    MetricsPanelCtrl.prototype.addQuery = function (target) {
        target.refId = this.dashboard.getNextQueryLetter(this.panel);
        this.panel.targets.push(target);
        this.nextRefId = this.dashboard.getNextQueryLetter(this.panel);
    };
    MetricsPanelCtrl.prototype.removeQuery = function (target) {
        var index = __WEBPACK_IMPORTED_MODULE_2_lodash___default.a.indexOf(this.panel.targets, target);
        this.panel.targets.splice(index, 1);
        this.nextRefId = this.dashboard.getNextQueryLetter(this.panel);
        this.refresh();
    };
    MetricsPanelCtrl.prototype.moveQuery = function (target, direction) {
        var index = __WEBPACK_IMPORTED_MODULE_2_lodash___default.a.indexOf(this.panel.targets, target);
        __WEBPACK_IMPORTED_MODULE_2_lodash___default.a.move(this.panel.targets, index, index + direction);
    };
    return MetricsPanelCtrl;
}(__WEBPACK_IMPORTED_MODULE_4_app_features_panel_panel_ctrl__["a" /* PanelCtrl */]));



/***/ }),

/***/ 1427:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export MetricsTabCtrl */
/* harmony export (immutable) */ __webpack_exports__["a"] = metricsTabDirective;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_remarkable__ = __webpack_require__(469);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_remarkable___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_remarkable__);
///<reference path="../../headers/common.d.ts" />

var MetricsTabCtrl = /** @class */ (function () {
    /** @ngInject */
    MetricsTabCtrl.$inject = ["$scope", "$sce", "datasourceSrv", "backendSrv"];
    function MetricsTabCtrl($scope, $sce, datasourceSrv, backendSrv) {
        this.$sce = $sce;
        this.backendSrv = backendSrv;
        this.panelCtrl = $scope.ctrl;
        $scope.ctrl = this;
        this.panel = this.panelCtrl.panel;
        this.dashboard = this.panelCtrl.dashboard;
        this.datasources = datasourceSrv.getMetricSources();
        this.panelDsValue = this.panelCtrl.panel.datasource;
        for (var _i = 0, _a = this.datasources; _i < _a.length; _i++) {
            var ds = _a[_i];
            if (ds.value === this.panelDsValue) {
                this.datasourceInstance = ds;
            }
        }
        this.addQueryDropdown = { text: 'Add Query', value: null, fake: true };
        // update next ref id
        this.panelCtrl.nextRefId = this.dashboard.getNextQueryLetter(this.panel);
        this.updateDatasourceOptions();
    }
    MetricsTabCtrl.prototype.updateDatasourceOptions = function () {
        if (this.datasourceInstance) {
            this.hasQueryHelp = this.datasourceInstance.meta.hasQueryHelp;
            this.queryOptions = this.datasourceInstance.meta.queryOptions;
        }
    };
    MetricsTabCtrl.prototype.getOptions = function (includeBuiltin) {
        return Promise.resolve(this.datasources.filter(function (value) {
            return includeBuiltin || !value.meta.builtIn;
        }).map(function (ds) {
            return { value: ds.value, text: ds.name, datasource: ds };
        }));
    };
    MetricsTabCtrl.prototype.datasourceChanged = function (option) {
        if (!option) {
            return;
        }
        this.datasourceInstance = option.datasource;
        this.panelCtrl.setDatasource(option.datasource);
        this.updateDatasourceOptions();
    };
    MetricsTabCtrl.prototype.addMixedQuery = function (option) {
        if (!option) {
            return;
        }
        this.panelCtrl.addQuery({ isNew: true, datasource: option.datasource.name });
        this.addQueryDropdown = { text: 'Add Query', value: null, fake: true };
    };
    MetricsTabCtrl.prototype.addQuery = function () {
        this.panelCtrl.addQuery({ isNew: true });
    };
    MetricsTabCtrl.prototype.toggleHelp = function () {
        var _this = this;
        this.optionsOpen = false;
        this.queryTroubleshooterOpen = false;
        this.helpOpen = !this.helpOpen;
        this.backendSrv.get("/api/plugins/" + this.datasourceInstance.meta.id + "/markdown/query_help").then(function (res) {
            var md = new __WEBPACK_IMPORTED_MODULE_0_remarkable___default.a();
            _this.helpHtml = _this.$sce.trustAsHtml(md.render(res));
        });
    };
    MetricsTabCtrl.prototype.toggleOptions = function () {
        this.helpOpen = false;
        this.queryTroubleshooterOpen = false;
        this.optionsOpen = !this.optionsOpen;
    };
    MetricsTabCtrl.prototype.toggleQueryTroubleshooter = function () {
        this.helpOpen = false;
        this.optionsOpen = false;
        this.queryTroubleshooterOpen = !this.queryTroubleshooterOpen;
    };
    return MetricsTabCtrl;
}());

/** @ngInject **/
function metricsTabDirective() {
    'use strict';
    return {
        restrict: 'E',
        scope: true,
        templateUrl: 'public/app/features/panel/partials/metrics_tab.html',
        controller: MetricsTabCtrl,
    };
}


/***/ }),

/***/ 1428:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export AlertTabCtrl */
/* harmony export (immutable) */ __webpack_exports__["a"] = alertTab;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__threshold_mapper__ = __webpack_require__(1429);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_app_core_components_query_part_query_part__ = __webpack_require__(1308);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__alert_def__ = __webpack_require__(1307);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_app_core_config__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_app_core_app_events__ = __webpack_require__(53);
///<reference path="../../headers/common.d.ts" />






var AlertTabCtrl = /** @class */ (function () {
    /** @ngInject */
    AlertTabCtrl.$inject = ["$scope", "backendSrv", "dashboardSrv", "uiSegmentSrv", "$q", "datasourceSrv"];
    function AlertTabCtrl($scope, backendSrv, dashboardSrv, uiSegmentSrv, $q, datasourceSrv) {
        this.$scope = $scope;
        this.backendSrv = backendSrv;
        this.dashboardSrv = dashboardSrv;
        this.uiSegmentSrv = uiSegmentSrv;
        this.$q = $q;
        this.datasourceSrv = datasourceSrv;
        this.panelCtrl = $scope.ctrl;
        this.panel = this.panelCtrl.panel;
        this.$scope.ctrl = this;
        this.subTabIndex = 0;
        this.evalFunctions = __WEBPACK_IMPORTED_MODULE_3__alert_def__["a" /* default */].evalFunctions;
        this.evalOperators = __WEBPACK_IMPORTED_MODULE_3__alert_def__["a" /* default */].evalOperators;
        this.conditionTypes = __WEBPACK_IMPORTED_MODULE_3__alert_def__["a" /* default */].conditionTypes;
        this.noDataModes = __WEBPACK_IMPORTED_MODULE_3__alert_def__["a" /* default */].noDataModes;
        this.executionErrorModes = __WEBPACK_IMPORTED_MODULE_3__alert_def__["a" /* default */].executionErrorModes;
        this.appSubUrl = __WEBPACK_IMPORTED_MODULE_4_app_core_config__["default"].appSubUrl;
    }
    AlertTabCtrl.prototype.$onInit = function () {
        var _this = this;
        this.addNotificationSegment = this.uiSegmentSrv.newPlusButton();
        // subscribe to graph threshold handle changes
        var thresholdChangedEventHandler = this.graphThresholdChanged.bind(this);
        this.panelCtrl.events.on('threshold-changed', thresholdChangedEventHandler);
        // set panel alert edit mode
        this.$scope.$on("$destroy", function () {
            _this.panelCtrl.events.off("threshold-changed", thresholdChangedEventHandler);
            _this.panelCtrl.editingThresholds = false;
            _this.panelCtrl.render();
        });
        // build notification model
        this.notifications = [];
        this.alertNotifications = [];
        this.alertHistory = [];
        return this.backendSrv.get('/api/alert-notifications').then(function (res) {
            _this.notifications = res;
            _this.initModel();
            _this.validateModel();
        });
    };
    AlertTabCtrl.prototype.getAlertHistory = function () {
        var _this = this;
        this.backendSrv.get("/api/annotations?dashboardId=" + this.panelCtrl.dashboard.id + "&panelId=" + this.panel.id + "&limit=50").then(function (res) {
            _this.alertHistory = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.map(res, function (ah) {
                ah.time = _this.dashboardSrv.getCurrent().formatDate(ah.time, 'MMM D, YYYY HH:mm:ss');
                ah.stateModel = __WEBPACK_IMPORTED_MODULE_3__alert_def__["a" /* default */].getStateDisplayModel(ah.newState);
                ah.info = __WEBPACK_IMPORTED_MODULE_3__alert_def__["a" /* default */].getAlertAnnotationInfo(ah);
                return ah;
            });
        });
    };
    AlertTabCtrl.prototype.getNotificationIcon = function (type) {
        switch (type) {
            case "email": return "fa fa-envelope";
            case "slack": return "fa fa-slack";
            case "victorops": return "fa fa-pagelines";
            case "webhook": return "fa fa-cubes";
            case "pagerduty": return "fa fa-bullhorn";
            case "opsgenie": return "fa fa-bell";
            case "hipchat": return "fa fa-mail-forward";
            case "pushover": return "fa fa-mobile";
            case "kafka": return "fa fa-random";
        }
        return 'fa fa-bell';
    };
    AlertTabCtrl.prototype.getNotifications = function () {
        var _this = this;
        return Promise.resolve(this.notifications.map(function (item) {
            return _this.uiSegmentSrv.newSegment(item.name);
        }));
    };
    AlertTabCtrl.prototype.changeTabIndex = function (newTabIndex) {
        this.subTabIndex = newTabIndex;
        if (this.subTabIndex === 2) {
            this.getAlertHistory();
        }
    };
    AlertTabCtrl.prototype.notificationAdded = function () {
        var model = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.find(this.notifications, { name: this.addNotificationSegment.value });
        if (!model) {
            return;
        }
        this.alertNotifications.push({
            name: model.name,
            iconClass: this.getNotificationIcon(model.type),
            isDefault: false
        });
        this.alert.notifications.push({ id: model.id });
        // reset plus button
        this.addNotificationSegment.value = this.uiSegmentSrv.newPlusButton().value;
        this.addNotificationSegment.html = this.uiSegmentSrv.newPlusButton().html;
    };
    AlertTabCtrl.prototype.removeNotification = function (index) {
        this.alert.notifications.splice(index, 1);
        this.alertNotifications.splice(index, 1);
    };
    AlertTabCtrl.prototype.initModel = function () {
        var _this = this;
        var alert = this.alert = this.panel.alert;
        if (!alert) {
            return;
        }
        alert.conditions = alert.conditions || [];
        if (alert.conditions.length === 0) {
            alert.conditions.push(this.buildDefaultCondition());
        }
        alert.noDataState = alert.noDataState || 'no_data';
        alert.executionErrorState = alert.executionErrorState || 'alerting';
        alert.frequency = alert.frequency || '60s';
        alert.handler = alert.handler || 1;
        alert.notifications = alert.notifications || [];
        var defaultName = this.panel.title + ' alert';
        alert.name = alert.name || defaultName;
        this.conditionModels = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.reduce(alert.conditions, function (memo, value) {
            memo.push(_this.buildConditionModel(value));
            return memo;
        }, []);
        __WEBPACK_IMPORTED_MODULE_1__threshold_mapper__["a" /* ThresholdMapper */].alertToGraphThresholds(this.panel);
        for (var _i = 0, _a = alert.notifications; _i < _a.length; _i++) {
            var addedNotification = _a[_i];
            var model = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.find(this.notifications, { id: addedNotification.id });
            if (model && model.isDefault === false) {
                model.iconClass = this.getNotificationIcon(model.type);
                this.alertNotifications.push(model);
            }
        }
        for (var _b = 0, _c = this.notifications; _b < _c.length; _b++) {
            var notification = _c[_b];
            if (notification.isDefault) {
                notification.iconClass = this.getNotificationIcon(notification.type);
                notification.bgColor = "#00678b";
                this.alertNotifications.push(notification);
            }
        }
        this.panelCtrl.editingThresholds = true;
        this.panelCtrl.render();
    };
    AlertTabCtrl.prototype.graphThresholdChanged = function (evt) {
        for (var _i = 0, _a = this.alert.conditions; _i < _a.length; _i++) {
            var condition = _a[_i];
            if (condition.type === 'query') {
                condition.evaluator.params[evt.handleIndex] = evt.threshold.value;
                this.evaluatorParamsChanged();
                break;
            }
        }
    };
    AlertTabCtrl.prototype.buildDefaultCondition = function () {
        return {
            type: 'query',
            query: { params: ['A', '5m', 'now'] },
            reducer: { type: 'avg', params: [] },
            evaluator: { type: 'gt', params: [null] },
            operator: { type: 'and' },
        };
    };
    AlertTabCtrl.prototype.validateModel = function () {
        var _this = this;
        if (!this.alert) {
            return;
        }
        var firstTarget;
        var fixed = false;
        var foundTarget = null;
        for (var _i = 0, _a = this.alert.conditions; _i < _a.length; _i++) {
            var condition = _a[_i];
            if (condition.type !== 'query') {
                continue;
            }
            for (var _b = 0, _c = this.panel.targets; _b < _c.length; _b++) {
                var target = _c[_b];
                if (!firstTarget) {
                    firstTarget = target;
                }
                if (condition.query.params[0] === target.refId) {
                    foundTarget = target;
                    break;
                }
            }
            if (!foundTarget) {
                if (firstTarget) {
                    condition.query.params[0] = firstTarget.refId;
                    foundTarget = firstTarget;
                    fixed = true;
                }
                else {
                    this.error = "Could not find any metric queries";
                }
            }
            var datasourceName = foundTarget.datasource || this.panel.datasource;
            this.datasourceSrv.get(datasourceName).then(function (ds) {
                if (!ds.meta.alerting) {
                    _this.error = 'The datasource does not support alerting queries';
                }
                else if (ds.targetContainsTemplate(foundTarget)) {
                    _this.error = 'Template variables are not supported in alert queries';
                }
                else {
                    _this.error = '';
                }
            });
        }
    };
    AlertTabCtrl.prototype.buildConditionModel = function (source) {
        var cm = { source: source, type: source.type };
        cm.queryPart = new __WEBPACK_IMPORTED_MODULE_2_app_core_components_query_part_query_part__["a" /* QueryPart */](source.query, __WEBPACK_IMPORTED_MODULE_3__alert_def__["a" /* default */].alertQueryDef);
        cm.reducerPart = __WEBPACK_IMPORTED_MODULE_3__alert_def__["a" /* default */].createReducerPart(source.reducer);
        cm.evaluator = source.evaluator;
        cm.operator = source.operator;
        return cm;
    };
    AlertTabCtrl.prototype.handleQueryPartEvent = function (conditionModel, evt) {
        var _this = this;
        switch (evt.name) {
            case "action-remove-part": {
                break;
            }
            case "get-part-actions": {
                return this.$q.when([]);
            }
            case "part-param-changed": {
                this.validateModel();
            }
            case "get-param-options": {
                var result = this.panel.targets.map(function (target) {
                    return _this.uiSegmentSrv.newSegment({ value: target.refId });
                });
                return this.$q.when(result);
            }
        }
    };
    AlertTabCtrl.prototype.handleReducerPartEvent = function (conditionModel, evt) {
        switch (evt.name) {
            case "action": {
                conditionModel.source.reducer.type = evt.action.value;
                conditionModel.reducerPart = __WEBPACK_IMPORTED_MODULE_3__alert_def__["a" /* default */].createReducerPart(conditionModel.source.reducer);
                break;
            }
            case "get-part-actions": {
                var result = [];
                for (var _i = 0, _a = __WEBPACK_IMPORTED_MODULE_3__alert_def__["a" /* default */].reducerTypes; _i < _a.length; _i++) {
                    var type = _a[_i];
                    if (type.value !== conditionModel.source.reducer.type) {
                        result.push(type);
                    }
                }
                return this.$q.when(result);
            }
        }
    };
    AlertTabCtrl.prototype.addCondition = function (type) {
        var condition = this.buildDefaultCondition();
        // add to persited model
        this.alert.conditions.push(condition);
        // add to view model
        this.conditionModels.push(this.buildConditionModel(condition));
    };
    AlertTabCtrl.prototype.removeCondition = function (index) {
        this.alert.conditions.splice(index, 1);
        this.conditionModels.splice(index, 1);
    };
    AlertTabCtrl.prototype.delete = function () {
        var _this = this;
        __WEBPACK_IMPORTED_MODULE_5_app_core_app_events__["a" /* default */].emit('confirm-modal', {
            title: 'Delete Alert',
            text: 'Are you sure you want to delete this alert rule?',
            text2: 'You need to save dashboard for the delete to take effect',
            icon: 'fa-trash',
            yesText: 'Delete',
            onConfirm: function () {
                delete _this.panel.alert;
                _this.alert = null;
                _this.panel.thresholds = [];
                _this.conditionModels = [];
                _this.panelCtrl.alertState = null;
                _this.panelCtrl.render();
            }
        });
    };
    AlertTabCtrl.prototype.enable = function () {
        this.panel.alert = {};
        this.initModel();
    };
    AlertTabCtrl.prototype.evaluatorParamsChanged = function () {
        __WEBPACK_IMPORTED_MODULE_1__threshold_mapper__["a" /* ThresholdMapper */].alertToGraphThresholds(this.panel);
        this.panelCtrl.render();
    };
    AlertTabCtrl.prototype.evaluatorTypeChanged = function (evaluator) {
        // ensure params array is correct length
        switch (evaluator.type) {
            case "lt":
            case "gt": {
                evaluator.params = [evaluator.params[0]];
                break;
            }
            case "within_range":
            case "outside_range": {
                evaluator.params = [evaluator.params[0], evaluator.params[1]];
                break;
            }
            case "no_value": {
                evaluator.params = [];
            }
        }
        this.evaluatorParamsChanged();
    };
    AlertTabCtrl.prototype.clearHistory = function () {
        var _this = this;
        __WEBPACK_IMPORTED_MODULE_5_app_core_app_events__["a" /* default */].emit('confirm-modal', {
            title: 'Delete Alert History',
            text: 'Are you sure you want to remove all history & annotations for this alert?',
            icon: 'fa-trash',
            yesText: 'Yes',
            onConfirm: function () {
                _this.backendSrv.post('/api/annotations/mass-delete', {
                    dashboardId: _this.panelCtrl.dashboard.id,
                    panelId: _this.panel.id,
                }).then(function (res) {
                    _this.alertHistory = [];
                    _this.panelCtrl.refresh();
                });
            }
        });
    };
    AlertTabCtrl.prototype.test = function () {
        var _this = this;
        this.testing = true;
        this.testResult = false;
        var payload = {
            dashboard: this.dashboardSrv.getCurrent().getSaveModelClone(),
            panelId: this.panelCtrl.panel.id,
        };
        return this.backendSrv.post('/api/alerts/test', payload).then(function (res) {
            _this.testResult = res;
            _this.testing = false;
        });
    };
    return AlertTabCtrl;
}());

/** @ngInject */
function alertTab() {
    'use strict';
    return {
        restrict: 'E',
        scope: true,
        templateUrl: 'public/app/features/alerting/partials/alert_tab.html',
        controller: AlertTabCtrl,
    };
}


/***/ }),

/***/ 1429:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ThresholdMapper; });
var ThresholdMapper = /** @class */ (function () {
    function ThresholdMapper() {
    }
    ThresholdMapper.alertToGraphThresholds = function (panel) {
        if (panel.type !== 'graph') {
            return false;
        }
        for (var i = 0; i < panel.alert.conditions.length; i++) {
            var condition = panel.alert.conditions[i];
            if (condition.type !== 'query') {
                continue;
            }
            var evaluator = condition.evaluator;
            var thresholds = panel.thresholds = [];
            switch (evaluator.type) {
                case "gt": {
                    var value = evaluator.params[0];
                    thresholds.push({ value: value, op: 'gt' });
                    break;
                }
                case "lt": {
                    var value = evaluator.params[0];
                    thresholds.push({ value: value, op: 'lt' });
                    break;
                }
                case "outside_range": {
                    var value1 = evaluator.params[0];
                    var value2 = evaluator.params[1];
                    if (value1 > value2) {
                        thresholds.push({ value: value1, op: 'gt' });
                        thresholds.push({ value: value2, op: 'lt' });
                    }
                    else {
                        thresholds.push({ value: value1, op: 'lt' });
                        thresholds.push({ value: value2, op: 'gt' });
                    }
                    break;
                }
                case "within_range": {
                    var value1 = evaluator.params[0];
                    var value2 = evaluator.params[1];
                    if (value1 > value2) {
                        thresholds.push({ value: value1, op: 'lt' });
                        thresholds.push({ value: value2, op: 'gt' });
                    }
                    else {
                        thresholds.push({ value: value1, op: 'gt' });
                        thresholds.push({ value: value2, op: 'lt' });
                    }
                    break;
                }
            }
            break;
        }
        for (var _i = 0, _a = panel.thresholds; _i < _a.length; _i++) {
            var t = _a[_i];
            t.fill = true;
            t.line = true;
            t.colorMode = 'critical';
        }
        var updated = true;
        return updated;
    };
    return ThresholdMapper;
}());



/***/ }),

/***/ 1430:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_app_plugins_datasource_graphite_module__ = __webpack_require__(1431);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_app_plugins_datasource_cloudwatch_module__ = __webpack_require__(1440);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_app_plugins_datasource_elasticsearch_module__ = __webpack_require__(1444);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_app_plugins_datasource_opentsdb_module__ = __webpack_require__(1453);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_app_plugins_datasource_grafana_module__ = __webpack_require__(1457);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_app_plugins_datasource_influxdb_module__ = __webpack_require__(1459);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_app_plugins_datasource_mixed_module__ = __webpack_require__(1464);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_app_plugins_datasource_mysql_module__ = __webpack_require__(1466);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_app_plugins_datasource_postgres_module__ = __webpack_require__(1470);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9_app_plugins_datasource_prometheus_module__ = __webpack_require__(1474);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10_app_plugins_panel_text_module__ = __webpack_require__(1481);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11_app_plugins_panel_graph_module__ = __webpack_require__(1482);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12_app_plugins_panel_dashlist_module__ = __webpack_require__(1494);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13_app_plugins_panel_pluginlist_module__ = __webpack_require__(1495);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14_app_plugins_panel_alertlist_module__ = __webpack_require__(1496);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15_app_plugins_panel_heatmap_module__ = __webpack_require__(1497);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16_app_plugins_panel_table_module__ = __webpack_require__(1504);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17_app_plugins_panel_singlestat_module__ = __webpack_require__(1508);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18_app_plugins_panel_gettingstarted_module__ = __webpack_require__(1510);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19_app_plugins_app_testdata_module__ = __webpack_require__(1511);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_20_app_plugins_app_testdata_datasource_module__ = __webpack_require__(1512);





















var builtInPlugins = {
    "app/plugins/datasource/graphite/module": __WEBPACK_IMPORTED_MODULE_0_app_plugins_datasource_graphite_module__,
    "app/plugins/datasource/cloudwatch/module": __WEBPACK_IMPORTED_MODULE_1_app_plugins_datasource_cloudwatch_module__,
    "app/plugins/datasource/elasticsearch/module": __WEBPACK_IMPORTED_MODULE_2_app_plugins_datasource_elasticsearch_module__,
    "app/plugins/datasource/opentsdb/module": __WEBPACK_IMPORTED_MODULE_3_app_plugins_datasource_opentsdb_module__,
    "app/plugins/datasource/grafana/module": __WEBPACK_IMPORTED_MODULE_4_app_plugins_datasource_grafana_module__,
    "app/plugins/datasource/influxdb/module": __WEBPACK_IMPORTED_MODULE_5_app_plugins_datasource_influxdb_module__,
    "app/plugins/datasource/mixed/module": __WEBPACK_IMPORTED_MODULE_6_app_plugins_datasource_mixed_module__,
    "app/plugins/datasource/mysql/module": __WEBPACK_IMPORTED_MODULE_7_app_plugins_datasource_mysql_module__,
    "app/plugins/datasource/postgres/module": __WEBPACK_IMPORTED_MODULE_8_app_plugins_datasource_postgres_module__,
    "app/plugins/datasource/prometheus/module": __WEBPACK_IMPORTED_MODULE_9_app_plugins_datasource_prometheus_module__,
    "app/plugins/app/testdata/module": __WEBPACK_IMPORTED_MODULE_19_app_plugins_app_testdata_module__,
    "app/plugins/app/testdata/datasource/module": __WEBPACK_IMPORTED_MODULE_20_app_plugins_app_testdata_datasource_module__,
    "app/plugins/panel/text/module": __WEBPACK_IMPORTED_MODULE_10_app_plugins_panel_text_module__,
    "app/plugins/panel/graph/module": __WEBPACK_IMPORTED_MODULE_11_app_plugins_panel_graph_module__,
    "app/plugins/panel/dashlist/module": __WEBPACK_IMPORTED_MODULE_12_app_plugins_panel_dashlist_module__,
    "app/plugins/panel/pluginlist/module": __WEBPACK_IMPORTED_MODULE_13_app_plugins_panel_pluginlist_module__,
    "app/plugins/panel/alertlist/module": __WEBPACK_IMPORTED_MODULE_14_app_plugins_panel_alertlist_module__,
    "app/plugins/panel/heatmap/module": __WEBPACK_IMPORTED_MODULE_15_app_plugins_panel_heatmap_module__,
    "app/plugins/panel/table/module": __WEBPACK_IMPORTED_MODULE_16_app_plugins_panel_table_module__,
    "app/plugins/panel/singlestat/module": __WEBPACK_IMPORTED_MODULE_17_app_plugins_panel_singlestat_module__,
    "app/plugins/panel/gettingstarted/module": __WEBPACK_IMPORTED_MODULE_18_app_plugins_panel_gettingstarted_module__,
};
/* harmony default export */ __webpack_exports__["a"] = (builtInPlugins);


/***/ }),

/***/ 1431:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AnnotationsQueryCtrl", function() { return AnnotationsQueryCtrl; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__datasource__ = __webpack_require__(1432);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__query_ctrl__ = __webpack_require__(1433);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__config_ctrl__ = __webpack_require__(1439);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "Datasource", function() { return __WEBPACK_IMPORTED_MODULE_0__datasource__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "QueryCtrl", function() { return __WEBPACK_IMPORTED_MODULE_1__query_ctrl__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "ConfigCtrl", function() { return __WEBPACK_IMPORTED_MODULE_2__config_ctrl__["a"]; });



var AnnotationsQueryCtrl = /** @class */ (function () {
    function AnnotationsQueryCtrl() {
    }
    AnnotationsQueryCtrl.templateUrl = 'partials/annotations.editor.html';
    return AnnotationsQueryCtrl;
}());



/***/ }),

/***/ 1432:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ 
GraphiteDatasource.$inject = ["instanceSettings", "$q", "backendSrv", "templateSrv"];__webpack_exports__["a"] = GraphiteDatasource;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_app_core_utils_datemath__ = __webpack_require__(467);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_app_core_utils_version__ = __webpack_require__(1329);
///<reference path="../../../headers/common.d.ts" />



/** @ngInject */
function GraphiteDatasource(instanceSettings, $q, backendSrv, templateSrv) {
    var _this = this;
    this.basicAuth = instanceSettings.basicAuth;
    this.url = instanceSettings.url;
    this.name = instanceSettings.name;
    this.graphiteVersion = instanceSettings.jsonData.graphiteVersion || '0.9';
    this.supportsTags = supportsTags(this.graphiteVersion);
    this.cacheTimeout = instanceSettings.cacheTimeout;
    this.withCredentials = instanceSettings.withCredentials;
    this.render_method = instanceSettings.render_method || 'POST';
    this.getQueryOptionsInfo = function () {
        return {
            "maxDataPoints": true,
            "cacheTimeout": true,
            "links": [
                {
                    text: "Help",
                    url: "http://docs.grafana.org/features/datasources/graphite/#using-graphite-in-grafana"
                }
            ]
        };
    };
    this.query = function (options) {
        var graphOptions = {
            from: this.translateTime(options.rangeRaw.from, false),
            until: this.translateTime(options.rangeRaw.to, true),
            targets: options.targets,
            format: options.format,
            cacheTimeout: options.cacheTimeout || this.cacheTimeout,
            maxDataPoints: options.maxDataPoints,
        };
        var params = this.buildGraphiteParams(graphOptions, options.scopedVars);
        if (params.length === 0) {
            return $q.when({ data: [] });
        }
        var httpOptions = {
            method: 'POST',
            url: '/render',
            data: params.join('&'),
            headers: {
                'Content-Type': 'application/x-www-form-urlencoded'
            },
        };
        if (options.panelId) {
            httpOptions.requestId = this.name + '.panelId.' + options.panelId;
        }
        return this.doGraphiteRequest(httpOptions).then(this.convertDataPointsToMs);
    };
    this.convertDataPointsToMs = function (result) {
        if (!result || !result.data) {
            return [];
        }
        for (var i = 0; i < result.data.length; i++) {
            var series = result.data[i];
            for (var y = 0; y < series.datapoints.length; y++) {
                series.datapoints[y][1] *= 1000;
            }
        }
        return result;
    };
    this.parseTags = function (tagString) {
        var tags = [];
        tags = tagString.split(',');
        if (tags.length === 1) {
            tags = tagString.split(' ');
            if (tags[0] === '') {
                tags = [];
            }
        }
        return tags;
    };
    this.annotationQuery = function (options) {
        var _this = this;
        // Graphite metric as annotation
        if (options.annotation.target) {
            var target = templateSrv.replace(options.annotation.target, {}, 'glob');
            var graphiteQuery = {
                rangeRaw: options.rangeRaw,
                targets: [{ target: target }],
                format: 'json',
                maxDataPoints: 100
            };
            return this.query(graphiteQuery).then(function (result) {
                var list = [];
                for (var i = 0; i < result.data.length; i++) {
                    var target = result.data[i];
                    for (var y = 0; y < target.datapoints.length; y++) {
                        var datapoint = target.datapoints[y];
                        if (!datapoint[0]) {
                            continue;
                        }
                        list.push({
                            annotation: options.annotation,
                            time: datapoint[1],
                            title: target.target
                        });
                    }
                }
                return list;
            });
        }
        else {
            // Graphite event as annotation
            var tags = templateSrv.replace(options.annotation.tags);
            return this.events({ range: options.rangeRaw, tags: tags }).then(function (results) {
                var list = [];
                for (var i = 0; i < results.data.length; i++) {
                    var e = results.data[i];
                    var tags = e.tags;
                    if (__WEBPACK_IMPORTED_MODULE_0_lodash___default.a.isString(e.tags)) {
                        tags = _this.parseTags(e.tags);
                    }
                    list.push({
                        annotation: options.annotation,
                        time: e.when * 1000,
                        title: e.what,
                        tags: tags,
                        text: e.data
                    });
                }
                return list;
            });
        }
    };
    this.events = function (options) {
        try {
            var tags = '';
            if (options.tags) {
                tags = '&tags=' + options.tags;
            }
            return this.doGraphiteRequest({
                method: 'GET',
                url: '/events/get_data?from=' + this.translateTime(options.range.from, false) +
                    '&until=' + this.translateTime(options.range.to, true) + tags,
            });
        }
        catch (err) {
            return $q.reject(err);
        }
    };
    this.targetContainsTemplate = function (target) {
        return templateSrv.variableExists(target.target);
    };
    this.translateTime = function (date, roundUp) {
        if (__WEBPACK_IMPORTED_MODULE_0_lodash___default.a.isString(date)) {
            if (date === 'now') {
                return 'now';
            }
            else if (date.indexOf('now-') >= 0 && date.indexOf('/') === -1) {
                date = date.substring(3);
                date = date.replace('m', 'min');
                date = date.replace('M', 'mon');
                return date;
            }
            date = __WEBPACK_IMPORTED_MODULE_1_app_core_utils_datemath__["parse"](date, roundUp);
        }
        // graphite' s from filter is exclusive
        // here we step back one minute in order
        // to guarantee that we get all the data that
        // exists for the specified range
        if (roundUp) {
            if (date.get('s')) {
                date.add(1, 'm');
            }
        }
        else if (roundUp === false) {
            if (date.get('s')) {
                date.subtract(1, 'm');
            }
        }
        return date.unix();
    };
    this.metricFindQuery = function (query, optionalOptions) {
        var options = optionalOptions || {};
        var interpolatedQuery = templateSrv.replace(query);
        var httpOptions = {
            method: 'GET',
            url: '/metrics/find',
            params: {
                query: interpolatedQuery
            },
            // for cancellations
            requestId: options.requestId,
        };
        if (options && options.range) {
            httpOptions.params.from = this.translateTime(options.range.from, false);
            httpOptions.params.until = this.translateTime(options.range.to, true);
        }
        return this.doGraphiteRequest(httpOptions).then(function (results) {
            return __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.map(results.data, function (metric) {
                return {
                    text: metric.text,
                    expandable: metric.expandable ? true : false
                };
            });
        });
    };
    this.getTags = function (optionalOptions) {
        var options = optionalOptions || {};
        var httpOptions = {
            method: 'GET',
            url: '/tags',
            // for cancellations
            requestId: options.requestId,
        };
        if (options && options.range) {
            httpOptions.params.from = this.translateTime(options.range.from, false);
            httpOptions.params.until = this.translateTime(options.range.to, true);
        }
        return this.doGraphiteRequest(httpOptions).then(function (results) {
            return __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.map(results.data, function (tag) {
                return {
                    text: tag.tag,
                    id: tag.id
                };
            });
        });
    };
    this.getTagValues = function (tag, optionalOptions) {
        var options = optionalOptions || {};
        var httpOptions = {
            method: 'GET',
            url: '/tags/' + tag,
            // for cancellations
            requestId: options.requestId,
        };
        if (options && options.range) {
            httpOptions.params.from = this.translateTime(options.range.from, false);
            httpOptions.params.until = this.translateTime(options.range.to, true);
        }
        return this.doGraphiteRequest(httpOptions).then(function (results) {
            if (results.data && results.data.values) {
                return __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.map(results.data.values, function (value) {
                    return {
                        text: value.value,
                        id: value.id
                    };
                });
            }
            else {
                return [];
            }
        });
    };
    this.getTagsAutoComplete = function (expression, tagPrefix) {
        var httpOptions = {
            method: 'GET',
            url: '/tags/autoComplete/tags',
            params: {
                expr: expression
            }
        };
        if (tagPrefix) {
            httpOptions.params.tagPrefix = tagPrefix;
        }
        return _this.doGraphiteRequest(httpOptions).then(function (results) {
            if (results.data) {
                return __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.map(results.data, function (tag) {
                    return { text: tag };
                });
            }
            else {
                return [];
            }
        });
    };
    this.getTagValuesAutoComplete = function (expression, tag, valuePrefix) {
        var httpOptions = {
            method: 'GET',
            url: '/tags/autoComplete/values',
            params: {
                expr: expression,
                tag: tag
            }
        };
        if (valuePrefix) {
            httpOptions.params.valuePrefix = valuePrefix;
        }
        return _this.doGraphiteRequest(httpOptions).then(function (results) {
            if (results.data) {
                return __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.map(results.data, function (value) {
                    return { text: value };
                });
            }
            else {
                return [];
            }
        });
    };
    this.getVersion = function () {
        var httpOptions = {
            method: 'GET',
            url: '/version/_',
        };
        return this.doGraphiteRequest(httpOptions).then(function (results) {
            if (results.data) {
                var semver = new __WEBPACK_IMPORTED_MODULE_2_app_core_utils_version__["a" /* SemVersion */](results.data);
                return semver.isValid() ? results.data : '';
            }
            return '';
        }).catch(function () {
            return '';
        });
    };
    this.testDatasource = function () {
        return this.metricFindQuery('*').then(function () {
            return { status: "success", message: "Data source is working" };
        });
    };
    this.doGraphiteRequest = function (options) {
        if (this.basicAuth || this.withCredentials) {
            options.withCredentials = true;
        }
        if (this.basicAuth) {
            options.headers = options.headers || {};
            options.headers.Authorization = this.basicAuth;
        }
        options.url = this.url + options.url;
        options.inspect = { type: 'graphite' };
        return backendSrv.datasourceRequest(options);
    };
    this._seriesRefLetters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
    this.buildGraphiteParams = function (options, scopedVars) {
        var graphite_options = ['from', 'until', 'rawData', 'format', 'maxDataPoints', 'cacheTimeout'];
        var clean_options = [], targets = {};
        var target, targetValue, i;
        var regex = /\#([A-Z])/g;
        var intervalFormatFixRegex = /'(\d+)m'/gi;
        var hasTargets = false;
        options['format'] = 'json';
        function fixIntervalFormat(match) {
            return match.replace('m', 'min').replace('M', 'mon');
        }
        for (i = 0; i < options.targets.length; i++) {
            target = options.targets[i];
            if (!target.target) {
                continue;
            }
            if (!target.refId) {
                target.refId = this._seriesRefLetters[i];
            }
            targetValue = templateSrv.replace(target.target, scopedVars);
            targetValue = targetValue.replace(intervalFormatFixRegex, fixIntervalFormat);
            targets[target.refId] = targetValue;
        }
        function nestedSeriesRegexReplacer(match, g1) {
            return targets[g1] || match;
        }
        for (i = 0; i < options.targets.length; i++) {
            target = options.targets[i];
            if (!target.target) {
                continue;
            }
            targetValue = targets[target.refId];
            targetValue = targetValue.replace(regex, nestedSeriesRegexReplacer);
            targets[target.refId] = targetValue;
            if (!target.hide) {
                hasTargets = true;
                clean_options.push("target=" + encodeURIComponent(targetValue));
            }
        }
        __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.each(options, function (value, key) {
            if (__WEBPACK_IMPORTED_MODULE_0_lodash___default.a.indexOf(graphite_options, key) === -1) {
                return;
            }
            if (value) {
                clean_options.push(key + "=" + encodeURIComponent(value));
            }
        });
        if (!hasTargets) {
            return [];
        }
        return clean_options;
    };
}
function supportsTags(version) {
    return Object(__WEBPACK_IMPORTED_MODULE_2_app_core_utils_version__["b" /* isVersionGtOrEq */])(version, '1.1');
}


/***/ }),

/***/ 1433:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return GraphiteQueryCtrl; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__add_graphite_func__ = __webpack_require__(1434);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__add_graphite_func___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__add_graphite_func__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__func_editor__ = __webpack_require__(1435);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__func_editor___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__func_editor__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_lodash__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__gfunc__ = __webpack_require__(1317);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__graphite_query__ = __webpack_require__(1436);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_app_plugins_sdk__ = __webpack_require__(1305);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_app_core_app_events__ = __webpack_require__(53);
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();







var GRAPHITE_TAG_OPERATORS = ['=', '!=', '=~', '!=~'];
var TAG_PREFIX = 'tag: ';
var GraphiteQueryCtrl = /** @class */ (function (_super) {
    __extends(GraphiteQueryCtrl, _super);
    /** @ngInject **/
    GraphiteQueryCtrl.$inject = ["$scope", "$injector", "uiSegmentSrv", "templateSrv"];
    function GraphiteQueryCtrl($scope, $injector, uiSegmentSrv, templateSrv) {
        var _this = _super.call(this, $scope, $injector) || this;
        _this.uiSegmentSrv = uiSegmentSrv;
        _this.templateSrv = templateSrv;
        _this.supportsTags = _this.datasource.supportsTags;
        if (_this.target) {
            _this.target.target = _this.target.target || '';
            _this.queryModel = new __WEBPACK_IMPORTED_MODULE_4__graphite_query__["a" /* default */](_this.target, templateSrv);
            _this.buildSegments();
        }
        _this.removeTagValue = '-- remove tag --';
        return _this;
    }
    GraphiteQueryCtrl.prototype.parseTarget = function () {
        this.queryModel.parseTarget();
        this.buildSegments();
    };
    GraphiteQueryCtrl.prototype.toggleEditorMode = function () {
        this.target.textEditor = !this.target.textEditor;
        this.parseTarget();
    };
    GraphiteQueryCtrl.prototype.buildSegments = function () {
        var _this = this;
        this.segments = __WEBPACK_IMPORTED_MODULE_2_lodash___default.a.map(this.queryModel.segments, function (segment) {
            return _this.uiSegmentSrv.newSegment(segment);
        });
        var checkOtherSegmentsIndex = this.queryModel.checkOtherSegmentsIndex || 0;
        this.checkOtherSegments(checkOtherSegmentsIndex);
        if (this.queryModel.seriesByTagUsed) {
            this.fixTagSegments();
        }
    };
    GraphiteQueryCtrl.prototype.addSelectMetricSegment = function () {
        this.queryModel.addSelectMetricSegment();
        this.segments.push(this.uiSegmentSrv.newSelectMetric());
    };
    GraphiteQueryCtrl.prototype.checkOtherSegments = function (fromIndex) {
        var _this = this;
        if (fromIndex === 0) {
            this.addSelectMetricSegment();
            return;
        }
        var path = this.queryModel.getSegmentPathUpTo(fromIndex + 1);
        if (path === "") {
            return Promise.resolve();
        }
        return this.datasource.metricFindQuery(path).then(function (segments) {
            if (segments.length === 0) {
                if (path !== '') {
                    _this.queryModel.segments = _this.queryModel.segments.splice(0, fromIndex);
                    _this.segments = _this.segments.splice(0, fromIndex);
                    _this.addSelectMetricSegment();
                }
            }
            else if (segments[0].expandable) {
                if (_this.segments.length === fromIndex) {
                    _this.addSelectMetricSegment();
                }
                else {
                    return _this.checkOtherSegments(fromIndex + 1);
                }
            }
        }).catch(function (err) {
            __WEBPACK_IMPORTED_MODULE_6_app_core_app_events__["a" /* default */].emit('alert-error', ['Error', err]);
        });
    };
    GraphiteQueryCtrl.prototype.setSegmentFocus = function (segmentIndex) {
        __WEBPACK_IMPORTED_MODULE_2_lodash___default.a.each(this.segments, function (segment, index) {
            segment.focus = segmentIndex === index;
        });
    };
    GraphiteQueryCtrl.prototype.getAltSegments = function (index) {
        var _this = this;
        var query = index === 0 ? '*' : this.queryModel.getSegmentPathUpTo(index) + '.*';
        var options = { range: this.panelCtrl.range, requestId: "get-alt-segments" };
        return this.datasource.metricFindQuery(query, options).then(function (segments) {
            var altSegments = __WEBPACK_IMPORTED_MODULE_2_lodash___default.a.map(segments, function (segment) {
                return _this.uiSegmentSrv.newSegment({ value: segment.text, expandable: segment.expandable });
            });
            if (altSegments.length === 0) {
                return altSegments;
            }
            // add template variables
            __WEBPACK_IMPORTED_MODULE_2_lodash___default.a.each(_this.templateSrv.variables, function (variable) {
                altSegments.unshift(_this.uiSegmentSrv.newSegment({
                    type: 'template',
                    value: '$' + variable.name,
                    expandable: true,
                }));
            });
            // add wildcard option
            altSegments.unshift(_this.uiSegmentSrv.newSegment('*'));
            if (_this.supportsTags && index === 0) {
                _this.removeTaggedEntry(altSegments);
                return _this.addAltTagSegments(index, altSegments);
            }
            else {
                return altSegments;
            }
        }).catch(function (err) {
            return [];
        });
    };
    GraphiteQueryCtrl.prototype.addAltTagSegments = function (index, altSegments) {
        return this.getTagsAsSegments().then(function (tagSegments) {
            tagSegments = __WEBPACK_IMPORTED_MODULE_2_lodash___default.a.map(tagSegments, function (segment) {
                segment.value = TAG_PREFIX + segment.value;
                return segment;
            });
            return altSegments.concat.apply(altSegments, tagSegments);
        });
    };
    GraphiteQueryCtrl.prototype.removeTaggedEntry = function (altSegments) {
        altSegments = __WEBPACK_IMPORTED_MODULE_2_lodash___default.a.remove(altSegments, function (s) { return s.value === '_tagged'; });
    };
    GraphiteQueryCtrl.prototype.segmentValueChanged = function (segment, segmentIndex) {
        var _this = this;
        this.error = null;
        this.queryModel.updateSegmentValue(segment, segmentIndex);
        if (this.queryModel.functions.length > 0 && this.queryModel.functions[0].def.fake) {
            this.queryModel.functions = [];
        }
        if (segment.type === 'tag') {
            var tag = removeTagPrefix(segment.value);
            this.addSeriesByTagFunc(tag);
            return;
        }
        if (segment.expandable) {
            return this.checkOtherSegments(segmentIndex + 1).then(function () {
                _this.setSegmentFocus(segmentIndex + 1);
                _this.targetChanged();
            });
        }
        else {
            this.spliceSegments(segmentIndex + 1);
        }
        this.setSegmentFocus(segmentIndex + 1);
        this.targetChanged();
    };
    GraphiteQueryCtrl.prototype.spliceSegments = function (index) {
        this.segments = this.segments.splice(0, index);
        this.queryModel.segments = this.queryModel.segments.splice(0, index);
    };
    GraphiteQueryCtrl.prototype.emptySegments = function () {
        this.queryModel.segments = [];
        this.segments = [];
    };
    GraphiteQueryCtrl.prototype.targetTextChanged = function () {
        this.updateModelTarget();
        this.refresh();
    };
    GraphiteQueryCtrl.prototype.updateModelTarget = function () {
        this.queryModel.updateModelTarget(this.panelCtrl.panel.targets);
    };
    GraphiteQueryCtrl.prototype.targetChanged = function () {
        if (this.queryModel.error) {
            return;
        }
        var oldTarget = this.queryModel.target.target;
        this.updateModelTarget();
        if (this.queryModel.target !== oldTarget) {
            var lastSegment = this.segments.length > 0 ? this.segments[this.segments.length - 1] : {};
            if (lastSegment.value !== 'select metric') {
                this.panelCtrl.refresh();
            }
        }
    };
    GraphiteQueryCtrl.prototype.addFunction = function (funcDef) {
        var newFunc = __WEBPACK_IMPORTED_MODULE_3__gfunc__["default"].createFuncInstance(funcDef, { withDefaultParams: true });
        newFunc.added = true;
        this.queryModel.addFunction(newFunc);
        this.smartlyHandleNewAliasByNode(newFunc);
        if (this.segments.length === 1 && this.segments[0].fake) {
            this.emptySegments();
        }
        if (!newFunc.params.length && newFunc.added) {
            this.targetChanged();
        }
        if (newFunc.def.name === 'seriesByTag') {
            this.parseTarget();
        }
    };
    GraphiteQueryCtrl.prototype.removeFunction = function (func) {
        this.queryModel.removeFunction(func);
        this.targetChanged();
    };
    GraphiteQueryCtrl.prototype.addSeriesByTagFunc = function (tag) {
        var funcDef = __WEBPACK_IMPORTED_MODULE_3__gfunc__["default"].getFuncDef('seriesByTag');
        var newFunc = __WEBPACK_IMPORTED_MODULE_3__gfunc__["default"].createFuncInstance(funcDef, { withDefaultParams: false });
        var tagParam = tag + "=select tag value";
        newFunc.params = [tagParam];
        this.queryModel.addFunction(newFunc);
        newFunc.added = true;
        this.emptySegments();
        this.targetChanged();
        this.parseTarget();
    };
    GraphiteQueryCtrl.prototype.smartlyHandleNewAliasByNode = function (func) {
        if (func.def.name !== 'aliasByNode') {
            return;
        }
        for (var i = 0; i < this.segments.length; i++) {
            if (this.segments[i].value.indexOf('*') >= 0) {
                func.params[0] = i;
                func.added = false;
                this.targetChanged();
                return;
            }
        }
    };
    GraphiteQueryCtrl.prototype.getAllTags = function () {
        var _this = this;
        return this.datasource.getTags().then(function (values) {
            var altTags = __WEBPACK_IMPORTED_MODULE_2_lodash___default.a.map(values, 'text');
            altTags.splice(0, 0, _this.removeTagValue);
            return mapToDropdownOptions(altTags);
        });
    };
    GraphiteQueryCtrl.prototype.getTags = function (index, tagPrefix) {
        var _this = this;
        var tagExpressions = this.queryModel.renderTagExpressions(index);
        return this.datasource.getTagsAutoComplete(tagExpressions, tagPrefix)
            .then(function (values) {
            var altTags = __WEBPACK_IMPORTED_MODULE_2_lodash___default.a.map(values, 'text');
            altTags.splice(0, 0, _this.removeTagValue);
            return mapToDropdownOptions(altTags);
        });
    };
    GraphiteQueryCtrl.prototype.getTagsAsSegments = function () {
        var _this = this;
        var tagExpressions = this.queryModel.renderTagExpressions();
        return this.datasource.getTagsAutoComplete(tagExpressions)
            .then(function (values) {
            return __WEBPACK_IMPORTED_MODULE_2_lodash___default.a.map(values, function (val) {
                return _this.uiSegmentSrv.newSegment({ value: val.text, type: 'tag', expandable: false });
            });
        });
    };
    GraphiteQueryCtrl.prototype.getTagOperators = function () {
        return mapToDropdownOptions(GRAPHITE_TAG_OPERATORS);
    };
    GraphiteQueryCtrl.prototype.getAllTagValues = function (tag) {
        var tagKey = tag.key;
        return this.datasource.getTagValues(tagKey).then(function (values) {
            var altValues = __WEBPACK_IMPORTED_MODULE_2_lodash___default.a.map(values, 'text');
            return mapToDropdownOptions(altValues);
        });
    };
    GraphiteQueryCtrl.prototype.getTagValues = function (tag, index, valuePrefix) {
        var tagExpressions = this.queryModel.renderTagExpressions(index);
        var tagKey = tag.key;
        return this.datasource.getTagValuesAutoComplete(tagExpressions, tagKey, valuePrefix).then(function (values) {
            var altValues = __WEBPACK_IMPORTED_MODULE_2_lodash___default.a.map(values, 'text');
            return mapToDropdownOptions(altValues);
        });
    };
    GraphiteQueryCtrl.prototype.tagChanged = function (tag, tagIndex) {
        this.queryModel.updateTag(tag, tagIndex);
        this.targetChanged();
    };
    GraphiteQueryCtrl.prototype.addNewTag = function (segment) {
        var newTagKey = segment.value;
        var newTag = { key: newTagKey, operator: '=', value: 'select tag value' };
        this.queryModel.addTag(newTag);
        this.targetChanged();
        this.fixTagSegments();
    };
    GraphiteQueryCtrl.prototype.removeTag = function (index) {
        this.queryModel.removeTag(index);
        this.targetChanged();
    };
    GraphiteQueryCtrl.prototype.fixTagSegments = function () {
        // Adding tag with the same name as just removed works incorrectly if single segment is used (instead of array)
        this.addTagSegments = [this.uiSegmentSrv.newPlusButton()];
    };
    GraphiteQueryCtrl.prototype.showDelimiter = function (index) {
        return index !== this.queryModel.tags.length - 1;
    };
    GraphiteQueryCtrl.templateUrl = 'partials/query.editor.html';
    return GraphiteQueryCtrl;
}(__WEBPACK_IMPORTED_MODULE_5_app_plugins_sdk__["QueryCtrl"]));

function mapToDropdownOptions(results) {
    return __WEBPACK_IMPORTED_MODULE_2_lodash___default.a.map(results, function (value) {
        return { text: value, value: value };
    });
}
function removeTagPrefix(value) {
    return value.replace(TAG_PREFIX, '');
}


/***/ }),

/***/ 1434:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
  __webpack_require__(12),
  __webpack_require__(7),
  __webpack_require__(13),
  __webpack_require__(1317),
], __WEBPACK_AMD_DEFINE_RESULT__ = function (angular, _, $, gfunc) {
  'use strict';

  gfunc = gfunc.default;

  angular
    .module('grafana.directives')
    .directive('graphiteAddFunc', ["$compile", function($compile) {
      var inputTemplate = '<input type="text"'+
                            ' class="gf-form-input"' +
                            ' spellcheck="false" style="display:none"></input>';

      var buttonTemplate = '<a  class="gf-form-label query-part dropdown-toggle"' +
                              ' tabindex="1" gf-dropdown="functionMenu" data-toggle="dropdown">' +
                              '<i class="fa fa-plus"></i></a>';

      return {
        link: function($scope, elem) {
          var ctrl = $scope.ctrl;
          var graphiteVersion = ctrl.datasource.graphiteVersion;
          var categories = gfunc.getCategories(graphiteVersion);
          var allFunctions = getAllFunctionNames(categories);

          $scope.functionMenu = createFunctionDropDownMenu(categories);

          var $input = $(inputTemplate);
          var $button = $(buttonTemplate);
          $input.appendTo(elem);
          $button.appendTo(elem);

          $input.attr('data-provide', 'typeahead');
          $input.typeahead({
            source: allFunctions,
            minLength: 1,
            items: 10,
            updater: function (value) {
              var funcDef = gfunc.getFuncDef(value);
              if (!funcDef) {
                // try find close match
                value = value.toLowerCase();
                funcDef = _.find(allFunctions, function(funcName) {
                  return funcName.toLowerCase().indexOf(value) === 0;
                });

                if (!funcDef) { return; }
              }

              $scope.$apply(function() {
                ctrl.addFunction(funcDef);
              });

              $input.trigger('blur');
              return '';
            }
          });

          $button.click(function() {
            $button.hide();
            $input.show();
            $input.focus();
          });

          $input.keyup(function() {
            elem.toggleClass('open', $input.val() === '');
          });

          $input.blur(function() {
            // clicking the function dropdown menu wont
            // work if you remove class at once
            setTimeout(function() {
              $input.val('');
              $input.hide();
              $button.show();
              elem.removeClass('open');
            }, 200);
          });

          $compile(elem.contents())($scope);
        }
      };
    }]);

  function getAllFunctionNames(categories) {
    return _.reduce(categories, function(list, category) {
      _.each(category, function(func) {
        list.push(func.name);
      });
      return list;
    }, []);
  }

  function createFunctionDropDownMenu(categories) {
    return _.map(categories, function(list, category) {
      var submenu = _.map(list, function(value) {
        return {
          text: value.name,
          click: "ctrl.addFunction('" + value.name + "')",
        };
      });

      return {
        text: category,
        submenu: submenu
      };
    });
  }
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ 1435:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
  __webpack_require__(12),
  __webpack_require__(7),
  __webpack_require__(13),
], __WEBPACK_AMD_DEFINE_RESULT__ = function (angular, _, $) {
  'use strict';

  angular
    .module('grafana.directives')
    .directive('graphiteFuncEditor', ["$compile", "templateSrv", function($compile, templateSrv) {

      var funcSpanTemplate = '<a ng-click="">{{func.def.name}}</a><span>(</span>';
      var paramTemplate = '<input type="text" style="display:none"' +
                          ' class="input-mini tight-form-func-param"></input>';

      var funcControlsTemplate =
         '<div class="tight-form-func-controls">' +
           '<span class="pointer fa fa-arrow-left"></span>' +
           '<span class="pointer fa fa-question-circle"></span>' +
           '<span class="pointer fa fa-remove" ></span>' +
           '<span class="pointer fa fa-arrow-right"></span>' +
         '</div>';

      return {
        restrict: 'A',
        link: function postLink($scope, elem) {
          var $funcLink = $(funcSpanTemplate);
          var $funcControls = $(funcControlsTemplate);
          var ctrl = $scope.ctrl;
          var func = $scope.func;
          var funcDef = func.def;
          var scheduledRelink = false;
          var paramCountAtLink = 0;

          function clickFuncParam(paramIndex) {
            /*jshint validthis:true */

            var $link = $(this);
            var $input = $link.next();

            $input.val(func.params[paramIndex]);
            $input.css('width', ($link.width() + 16) + 'px');

            $link.hide();
            $input.show();
            $input.focus();
            $input.select();

            var typeahead = $input.data('typeahead');
            if (typeahead) {
              $input.val('');
              typeahead.lookup();
            }
          }

          function scheduledRelinkIfNeeded() {
            if (paramCountAtLink === func.params.length) {
              return;
            }

            if (!scheduledRelink) {
              scheduledRelink = true;
              setTimeout(function() {
                relink();
                scheduledRelink = false;
              }, 200);
            }
          }

          function inputBlur(paramIndex) {
            /*jshint validthis:true */
            var $input = $(this);
            var $link = $input.prev();
            var newValue = $input.val();

            if (newValue !== '' || func.def.params[paramIndex].optional) {
              $link.html(templateSrv.highlightVariablesAsHtml(newValue));

              func.updateParam($input.val(), paramIndex);
              scheduledRelinkIfNeeded();

              $scope.$apply(function() {
                ctrl.targetChanged();
              });

              $input.hide();
              $link.show();
            }
          }

          function inputKeyPress(paramIndex, e) {
            /*jshint validthis:true */
            if(e.which === 13) {
              inputBlur.call(this, paramIndex);
            }
          }

          function inputKeyDown() {
            /*jshint validthis:true */
            this.style.width = (3 + this.value.length) * 8 + 'px';
          }

          function addTypeahead($input, paramIndex) {
            $input.attr('data-provide', 'typeahead');

            var options = funcDef.params[paramIndex].options;
            if (funcDef.params[paramIndex].type === 'int') {
              options = _.map(options, function(val) { return val.toString(); });
            }

            $input.typeahead({
              source: options,
              minLength: 0,
              items: 20,
              updater: function (value) {
                setTimeout(function() {
                  inputBlur.call($input[0], paramIndex);
                }, 0);
                return value;
              }
            });

            var typeahead = $input.data('typeahead');
            typeahead.lookup = function () {
              this.query = this.$element.val() || '';
              return this.process(this.source);
            };
          }

          function toggleFuncControls() {
            var targetDiv = elem.closest('.tight-form');

            if (elem.hasClass('show-function-controls')) {
              elem.removeClass('show-function-controls');
              targetDiv.removeClass('has-open-function');
              $funcControls.hide();
              return;
            }

            elem.addClass('show-function-controls');
            targetDiv.addClass('has-open-function');

            $funcControls.show();
          }

          function addElementsAndCompile() {
            $funcControls.appendTo(elem);
            $funcLink.appendTo(elem);

            _.each(funcDef.params, function(param, index) {
              if (param.optional && func.params.length <= index) {
                return;
              }

              if (index > 0) {
                $('<span>, </span>').appendTo(elem);
              }

              var paramValue = templateSrv.highlightVariablesAsHtml(func.params[index]);
              var $paramLink = $('<a ng-click="" class="graphite-func-param-link">' + paramValue + '</a>');
              var $input = $(paramTemplate);

              paramCountAtLink++;

              $paramLink.appendTo(elem);
              $input.appendTo(elem);

              $input.blur(_.partial(inputBlur, index));
              $input.keyup(inputKeyDown);
              $input.keypress(_.partial(inputKeyPress, index));
              $paramLink.click(_.partial(clickFuncParam, index));

              if (funcDef.params[index].options) {
                addTypeahead($input, index);
              }

            });

            $('<span>)</span>').appendTo(elem);

            $compile(elem.contents())($scope);
          }

          function ifJustAddedFocusFistParam() {
            if ($scope.func.added) {
              $scope.func.added = false;
              setTimeout(function() {
                elem.find('.graphite-func-param-link').first().click();
              }, 10);
            }
          }

          function registerFuncControlsToggle() {
            $funcLink.click(toggleFuncControls);
          }

          function registerFuncControlsActions() {
            $funcControls.click(function(e) {
              var $target = $(e.target);
              if ($target.hasClass('fa-remove')) {
                toggleFuncControls();
                $scope.$apply(function() {
                  ctrl.removeFunction($scope.func);
                });
                return;
              }

              if ($target.hasClass('fa-arrow-left')) {
                $scope.$apply(function() {
                  _.move(ctrl.functions, $scope.$index, $scope.$index - 1);
                  ctrl.targetChanged();
                });
                return;
              }

              if ($target.hasClass('fa-arrow-right')) {
                $scope.$apply(function() {
                  _.move(ctrl.functions, $scope.$index, $scope.$index + 1);
                  ctrl.targetChanged();
                });
                return;
              }

              if ($target.hasClass('fa-question-circle')) {
                window.open("http://graphite.readthedocs.org/en/latest/functions.html#graphite.render.functions." + funcDef.name,'_blank');
                return;
              }
            });
          }

          function relink() {
            elem.children().remove();

            addElementsAndCompile();
            ifJustAddedFocusFistParam();
            registerFuncControlsToggle();
            registerFuncControlsActions();
          }

          relink();
        }
      };

    }]);

}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ 1436:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__gfunc__ = __webpack_require__(1317);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__parser__ = __webpack_require__(1437);



var GraphiteQuery = /** @class */ (function () {
    /** @ngInject */
    GraphiteQuery.$inject = ["target", "templateSrv", "scopedVars"];
    function GraphiteQuery(target, templateSrv, scopedVars) {
        this.target = target;
        this.parseTarget();
        this.removeTagValue = '-- remove tag --';
    }
    GraphiteQuery.prototype.parseTarget = function () {
        this.functions = [];
        this.segments = [];
        this.tags = [];
        this.error = null;
        if (this.target.textEditor) {
            return;
        }
        var parser = new __WEBPACK_IMPORTED_MODULE_2__parser__["a" /* Parser */](this.target.target);
        var astNode = parser.getAst();
        if (astNode === null) {
            this.checkOtherSegmentsIndex = 0;
            return;
        }
        if (astNode.type === 'error') {
            this.error = astNode.message + " at position: " + astNode.pos;
            this.target.textEditor = true;
            return;
        }
        try {
            this.parseTargetRecursive(astNode, null, 0);
        }
        catch (err) {
            console.log('error parsing target:', err.message);
            this.error = err.message;
            this.target.textEditor = true;
        }
        this.checkOtherSegmentsIndex = this.segments.length - 1;
        this.checkForSeriesByTag();
    };
    GraphiteQuery.prototype.checkForSeriesByTag = function () {
        var seriesByTagFunc = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.find(this.functions, function (func) { return func.def.name === 'seriesByTag'; });
        if (seriesByTagFunc) {
            this.seriesByTagUsed = true;
            seriesByTagFunc.hidden = true;
            var tags = this.splitSeriesByTagParams(seriesByTagFunc);
            this.tags = tags;
        }
    };
    GraphiteQuery.prototype.getSegmentPathUpTo = function (index) {
        var arr = this.segments.slice(0, index);
        return __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.reduce(arr, function (result, segment) {
            return result ? (result + "." + segment.value) : segment.value;
        }, "");
    };
    GraphiteQuery.prototype.parseTargetRecursive = function (astNode, func, index) {
        var _this = this;
        if (astNode === null) {
            return null;
        }
        switch (astNode.type) {
            case 'function':
                var innerFunc = __WEBPACK_IMPORTED_MODULE_1__gfunc__["default"].createFuncInstance(astNode.name, { withDefaultParams: false });
                __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.each(astNode.params, function (param, index) {
                    _this.parseTargetRecursive(param, innerFunc, index);
                });
                innerFunc.updateText();
                this.functions.push(innerFunc);
                break;
            case 'series-ref':
                this.addFunctionParameter(func, astNode.value, index, this.segments.length > 0);
                break;
            case 'bool':
            case 'string':
            case 'number':
                if ((index - 1) >= func.def.params.length) {
                    throw { message: 'invalid number of parameters to method ' + func.def.name };
                }
                var shiftBack = this.isShiftParamsBack(func);
                this.addFunctionParameter(func, astNode.value, index, shiftBack);
                break;
            case 'metric':
                if (this.segments.length > 0) {
                    if (astNode.segments.length !== 1) {
                        throw { message: 'Multiple metric params not supported, use text editor.' };
                    }
                    this.addFunctionParameter(func, astNode.segments[0].value, index, true);
                    break;
                }
                this.segments = astNode.segments;
        }
    };
    GraphiteQuery.prototype.isShiftParamsBack = function (func) {
        return func.def.name !== 'seriesByTag';
    };
    GraphiteQuery.prototype.updateSegmentValue = function (segment, index) {
        this.segments[index].value = segment.value;
    };
    GraphiteQuery.prototype.addSelectMetricSegment = function () {
        this.segments.push({ value: "select metric" });
    };
    GraphiteQuery.prototype.addFunction = function (newFunc) {
        this.functions.push(newFunc);
        this.moveAliasFuncLast();
    };
    GraphiteQuery.prototype.moveAliasFuncLast = function () {
        var aliasFunc = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.find(this.functions, function (func) {
            return func.def.name === 'alias' ||
                func.def.name === 'aliasByNode' ||
                func.def.name === 'aliasByMetric';
        });
        if (aliasFunc) {
            this.functions = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.without(this.functions, aliasFunc);
            this.functions.push(aliasFunc);
        }
    };
    GraphiteQuery.prototype.addFunctionParameter = function (func, value, index, shiftBack) {
        if (shiftBack) {
            index = Math.max(index - 1, 0);
        }
        func.params[index] = value;
    };
    GraphiteQuery.prototype.removeFunction = function (func) {
        this.functions = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.without(this.functions, func);
    };
    GraphiteQuery.prototype.updateModelTarget = function (targets) {
        // render query
        if (!this.target.textEditor) {
            var metricPath = this.getSegmentPathUpTo(this.segments.length);
            this.target.target = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.reduce(this.functions, wrapFunction, metricPath);
        }
        this.updateRenderedTarget(this.target, targets);
        // loop through other queries and update targetFull as needed
        for (var _i = 0, _a = targets || []; _i < _a.length; _i++) {
            var target = _a[_i];
            if (target.refId !== this.target.refId) {
                this.updateRenderedTarget(target, targets);
            }
        }
    };
    GraphiteQuery.prototype.updateRenderedTarget = function (target, targets) {
        // render nested query
        var targetsByRefId = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.keyBy(targets, 'refId');
        // no references to self
        delete targetsByRefId[target.refId];
        var nestedSeriesRefRegex = /\#([A-Z])/g;
        var targetWithNestedQueries = target.target;
        // Keep interpolating until there are no query references
        // The reason for the loop is that the referenced query might contain another reference to another query
        while (targetWithNestedQueries.match(nestedSeriesRefRegex)) {
            var updated = targetWithNestedQueries.replace(nestedSeriesRefRegex, function (match, g1) {
                var t = targetsByRefId[g1];
                if (!t) {
                    return match;
                }
                // no circular references
                delete targetsByRefId[g1];
                return t.target;
            });
            if (updated === targetWithNestedQueries) {
                break;
            }
            targetWithNestedQueries = updated;
        }
        delete target.targetFull;
        if (target.target !== targetWithNestedQueries) {
            target.targetFull = targetWithNestedQueries;
        }
    };
    GraphiteQuery.prototype.splitSeriesByTagParams = function (func) {
        var tagPattern = /([^\!=~]+)([\!=~]+)([^\!=~]+)/;
        return __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.flatten(__WEBPACK_IMPORTED_MODULE_0_lodash___default.a.map(func.params, function (param) {
            var matches = tagPattern.exec(param);
            if (matches) {
                var tag = matches.slice(1);
                if (tag.length === 3) {
                    return {
                        key: tag[0],
                        operator: tag[1],
                        value: tag[2]
                    };
                }
            }
            return [];
        }));
    };
    GraphiteQuery.prototype.getSeriesByTagFuncIndex = function () {
        return __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.findIndex(this.functions, function (func) { return func.def.name === 'seriesByTag'; });
    };
    GraphiteQuery.prototype.getSeriesByTagFunc = function () {
        var seriesByTagFuncIndex = this.getSeriesByTagFuncIndex();
        if (seriesByTagFuncIndex >= 0) {
            return this.functions[seriesByTagFuncIndex];
        }
        else {
            return undefined;
        }
    };
    GraphiteQuery.prototype.addTag = function (tag) {
        var newTagParam = renderTagString(tag);
        this.getSeriesByTagFunc().params.push(newTagParam);
        this.tags.push(tag);
    };
    GraphiteQuery.prototype.removeTag = function (index) {
        this.getSeriesByTagFunc().params.splice(index, 1);
        this.tags.splice(index, 1);
    };
    GraphiteQuery.prototype.updateTag = function (tag, tagIndex) {
        this.error = null;
        if (tag.key === this.removeTagValue) {
            this.removeTag(tagIndex);
            return;
        }
        var newTagParam = renderTagString(tag);
        this.getSeriesByTagFunc().params[tagIndex] = newTagParam;
        this.tags[tagIndex] = tag;
    };
    GraphiteQuery.prototype.renderTagExpressions = function (excludeIndex) {
        if (excludeIndex === void 0) { excludeIndex = -1; }
        return __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.compact(__WEBPACK_IMPORTED_MODULE_0_lodash___default.a.map(this.tags, function (tagExpr, index) {
            // Don't render tag that we want to lookup
            if (index !== excludeIndex) {
                return tagExpr.key + tagExpr.operator + tagExpr.value;
            }
        }));
    };
    return GraphiteQuery;
}());
/* harmony default export */ __webpack_exports__["a"] = (GraphiteQuery);
function wrapFunction(target, func) {
    return func.render(target);
}
function renderTagString(tag) {
    return tag.key + tag.operator + tag.value;
}


/***/ }),

/***/ 1437:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = Parser;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__lexer__ = __webpack_require__(1438);

function Parser(expression) {
    this.expression = expression;
    this.lexer = new __WEBPACK_IMPORTED_MODULE_0__lexer__["a" /* Lexer */](expression);
    this.tokens = this.lexer.tokenize();
    this.index = 0;
}
Parser.prototype = {
    getAst: function () {
        return this.start();
    },
    start: function () {
        try {
            return this.functionCall() || this.metricExpression();
        }
        catch (e) {
            return {
                type: 'error',
                message: e.message,
                pos: e.pos
            };
        }
    },
    curlyBraceSegment: function () {
        if (this.match('identifier', '{') || this.match('{')) {
            var curlySegment = "";
            while (!this.match('') && !this.match('}')) {
                curlySegment += this.consumeToken().value;
            }
            if (!this.match('}')) {
                this.errorMark("Expected closing '}'");
            }
            curlySegment += this.consumeToken().value;
            // if curly segment is directly followed by identifier
            // include it in the segment
            if (this.match('identifier')) {
                curlySegment += this.consumeToken().value;
            }
            return {
                type: 'segment',
                value: curlySegment
            };
        }
        else {
            return null;
        }
    },
    metricSegment: function () {
        var curly = this.curlyBraceSegment();
        if (curly) {
            return curly;
        }
        if (this.match('identifier') || this.match('number')) {
            // hack to handle float numbers in metric segments
            var parts = this.consumeToken().value.split('.');
            if (parts.length === 2) {
                this.tokens.splice(this.index, 0, { type: '.' });
                this.tokens.splice(this.index + 1, 0, { type: 'number', value: parts[1] });
            }
            return {
                type: 'segment',
                value: parts[0]
            };
        }
        if (!this.match('templateStart')) {
            this.errorMark('Expected metric identifier');
        }
        this.consumeToken();
        if (!this.match('identifier')) {
            this.errorMark('Expected identifier after templateStart');
        }
        var node = {
            type: 'template',
            value: this.consumeToken().value
        };
        if (!this.match('templateEnd')) {
            this.errorMark('Expected templateEnd');
        }
        this.consumeToken();
        return node;
    },
    metricExpression: function () {
        if (!this.match('templateStart') && !this.match('identifier') && !this.match('number') && !this.match('{')) {
            return null;
        }
        var node = {
            type: 'metric',
            segments: []
        };
        node.segments.push(this.metricSegment());
        while (this.match('.')) {
            this.consumeToken();
            var segment = this.metricSegment();
            if (!segment) {
                this.errorMark('Expected metric identifier');
            }
            node.segments.push(segment);
        }
        return node;
    },
    functionCall: function () {
        if (!this.match('identifier', '(')) {
            return null;
        }
        var node = {
            type: 'function',
            name: this.consumeToken().value,
        };
        // consume left parenthesis
        this.consumeToken();
        node.params = this.functionParameters();
        if (!this.match(')')) {
            this.errorMark('Expected closing parenthesis');
        }
        this.consumeToken();
        return node;
    },
    boolExpression: function () {
        if (!this.match('bool')) {
            return null;
        }
        return {
            type: 'bool',
            value: this.consumeToken().value === 'true',
        };
    },
    functionParameters: function () {
        if (this.match(')') || this.match('')) {
            return [];
        }
        var param = this.functionCall() ||
            this.numericLiteral() ||
            this.seriesRefExpression() ||
            this.boolExpression() ||
            this.metricExpression() ||
            this.stringLiteral();
        if (!this.match(',')) {
            return [param];
        }
        this.consumeToken();
        return [param].concat(this.functionParameters());
    },
    seriesRefExpression: function () {
        if (!this.match('identifier')) {
            return null;
        }
        var value = this.tokens[this.index].value;
        if (!value.match(/\#[A-Z]/)) {
            return null;
        }
        var token = this.consumeToken();
        return {
            type: 'series-ref',
            value: token.value
        };
    },
    numericLiteral: function () {
        if (!this.match('number')) {
            return null;
        }
        return {
            type: 'number',
            value: parseFloat(this.consumeToken().value)
        };
    },
    stringLiteral: function () {
        if (!this.match('string')) {
            return null;
        }
        var token = this.consumeToken();
        if (token.isUnclosed) {
            throw { message: 'Unclosed string parameter', pos: token.pos };
        }
        return {
            type: 'string',
            value: token.value
        };
    },
    errorMark: function (text) {
        var currentToken = this.tokens[this.index];
        var type = currentToken ? currentToken.type : 'end of string';
        throw {
            message: text + " instead found " + type,
            pos: currentToken ? currentToken.pos : this.lexer.char
        };
    },
    // returns token value and incre
    consumeToken: function () {
        this.index++;
        return this.tokens[this.index - 1];
    },
    matchToken: function (type, index) {
        var token = this.tokens[this.index + index];
        return (token === undefined && type === '') ||
            token && token.type === type;
    },
    match: function (token1, token2) {
        return this.matchToken(token1, 0) &&
            (!token2 || this.matchToken(token2, 1));
    },
};


/***/ }),

/***/ 1438:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = Lexer;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_lodash__);
///<reference path="../../../headers/common.d.ts" />

// This is auto generated from the unicode tables.
// The tables are at:
// http://www.fileformat.info/info/unicode/category/Lu/list.htm
// http://www.fileformat.info/info/unicode/category/Ll/list.htm
// http://www.fileformat.info/info/unicode/category/Lt/list.htm
// http://www.fileformat.info/info/unicode/category/Lm/list.htm
// http://www.fileformat.info/info/unicode/category/Lo/list.htm
// http://www.fileformat.info/info/unicode/category/Nl/list.htm
var unicodeLetterTable = [
    170, 170, 181, 181, 186, 186, 192, 214,
    216, 246, 248, 705, 710, 721, 736, 740, 748, 748, 750, 750,
    880, 884, 886, 887, 890, 893, 902, 902, 904, 906, 908, 908,
    910, 929, 931, 1013, 1015, 1153, 1162, 1319, 1329, 1366,
    1369, 1369, 1377, 1415, 1488, 1514, 1520, 1522, 1568, 1610,
    1646, 1647, 1649, 1747, 1749, 1749, 1765, 1766, 1774, 1775,
    1786, 1788, 1791, 1791, 1808, 1808, 1810, 1839, 1869, 1957,
    1969, 1969, 1994, 2026, 2036, 2037, 2042, 2042, 2048, 2069,
    2074, 2074, 2084, 2084, 2088, 2088, 2112, 2136, 2308, 2361,
    2365, 2365, 2384, 2384, 2392, 2401, 2417, 2423, 2425, 2431,
    2437, 2444, 2447, 2448, 2451, 2472, 2474, 2480, 2482, 2482,
    2486, 2489, 2493, 2493, 2510, 2510, 2524, 2525, 2527, 2529,
    2544, 2545, 2565, 2570, 2575, 2576, 2579, 2600, 2602, 2608,
    2610, 2611, 2613, 2614, 2616, 2617, 2649, 2652, 2654, 2654,
    2674, 2676, 2693, 2701, 2703, 2705, 2707, 2728, 2730, 2736,
    2738, 2739, 2741, 2745, 2749, 2749, 2768, 2768, 2784, 2785,
    2821, 2828, 2831, 2832, 2835, 2856, 2858, 2864, 2866, 2867,
    2869, 2873, 2877, 2877, 2908, 2909, 2911, 2913, 2929, 2929,
    2947, 2947, 2949, 2954, 2958, 2960, 2962, 2965, 2969, 2970,
    2972, 2972, 2974, 2975, 2979, 2980, 2984, 2986, 2990, 3001,
    3024, 3024, 3077, 3084, 3086, 3088, 3090, 3112, 3114, 3123,
    3125, 3129, 3133, 3133, 3160, 3161, 3168, 3169, 3205, 3212,
    3214, 3216, 3218, 3240, 3242, 3251, 3253, 3257, 3261, 3261,
    3294, 3294, 3296, 3297, 3313, 3314, 3333, 3340, 3342, 3344,
    3346, 3386, 3389, 3389, 3406, 3406, 3424, 3425, 3450, 3455,
    3461, 3478, 3482, 3505, 3507, 3515, 3517, 3517, 3520, 3526,
    3585, 3632, 3634, 3635, 3648, 3654, 3713, 3714, 3716, 3716,
    3719, 3720, 3722, 3722, 3725, 3725, 3732, 3735, 3737, 3743,
    3745, 3747, 3749, 3749, 3751, 3751, 3754, 3755, 3757, 3760,
    3762, 3763, 3773, 3773, 3776, 3780, 3782, 3782, 3804, 3805,
    3840, 3840, 3904, 3911, 3913, 3948, 3976, 3980, 4096, 4138,
    4159, 4159, 4176, 4181, 4186, 4189, 4193, 4193, 4197, 4198,
    4206, 4208, 4213, 4225, 4238, 4238, 4256, 4293, 4304, 4346,
    4348, 4348, 4352, 4680, 4682, 4685, 4688, 4694, 4696, 4696,
    4698, 4701, 4704, 4744, 4746, 4749, 4752, 4784, 4786, 4789,
    4792, 4798, 4800, 4800, 4802, 4805, 4808, 4822, 4824, 4880,
    4882, 4885, 4888, 4954, 4992, 5007, 5024, 5108, 5121, 5740,
    5743, 5759, 5761, 5786, 5792, 5866, 5870, 5872, 5888, 5900,
    5902, 5905, 5920, 5937, 5952, 5969, 5984, 5996, 5998, 6000,
    6016, 6067, 6103, 6103, 6108, 6108, 6176, 6263, 6272, 6312,
    6314, 6314, 6320, 6389, 6400, 6428, 6480, 6509, 6512, 6516,
    6528, 6571, 6593, 6599, 6656, 6678, 6688, 6740, 6823, 6823,
    6917, 6963, 6981, 6987, 7043, 7072, 7086, 7087, 7104, 7141,
    7168, 7203, 7245, 7247, 7258, 7293, 7401, 7404, 7406, 7409,
    7424, 7615, 7680, 7957, 7960, 7965, 7968, 8005, 8008, 8013,
    8016, 8023, 8025, 8025, 8027, 8027, 8029, 8029, 8031, 8061,
    8064, 8116, 8118, 8124, 8126, 8126, 8130, 8132, 8134, 8140,
    8144, 8147, 8150, 8155, 8160, 8172, 8178, 8180, 8182, 8188,
    8305, 8305, 8319, 8319, 8336, 8348, 8450, 8450, 8455, 8455,
    8458, 8467, 8469, 8469, 8473, 8477, 8484, 8484, 8486, 8486,
    8488, 8488, 8490, 8493, 8495, 8505, 8508, 8511, 8517, 8521,
    8526, 8526, 8544, 8584, 11264, 11310, 11312, 11358,
    11360, 11492, 11499, 11502, 11520, 11557, 11568, 11621,
    11631, 11631, 11648, 11670, 11680, 11686, 11688, 11694,
    11696, 11702, 11704, 11710, 11712, 11718, 11720, 11726,
    11728, 11734, 11736, 11742, 11823, 11823, 12293, 12295,
    12321, 12329, 12337, 12341, 12344, 12348, 12353, 12438,
    12445, 12447, 12449, 12538, 12540, 12543, 12549, 12589,
    12593, 12686, 12704, 12730, 12784, 12799, 13312, 13312,
    19893, 19893, 19968, 19968, 40907, 40907, 40960, 42124,
    42192, 42237, 42240, 42508, 42512, 42527, 42538, 42539,
    42560, 42606, 42623, 42647, 42656, 42735, 42775, 42783,
    42786, 42888, 42891, 42894, 42896, 42897, 42912, 42921,
    43002, 43009, 43011, 43013, 43015, 43018, 43020, 43042,
    43072, 43123, 43138, 43187, 43250, 43255, 43259, 43259,
    43274, 43301, 43312, 43334, 43360, 43388, 43396, 43442,
    43471, 43471, 43520, 43560, 43584, 43586, 43588, 43595,
    43616, 43638, 43642, 43642, 43648, 43695, 43697, 43697,
    43701, 43702, 43705, 43709, 43712, 43712, 43714, 43714,
    43739, 43741, 43777, 43782, 43785, 43790, 43793, 43798,
    43808, 43814, 43816, 43822, 43968, 44002, 44032, 44032,
    55203, 55203, 55216, 55238, 55243, 55291, 63744, 64045,
    64048, 64109, 64112, 64217, 64256, 64262, 64275, 64279,
    64285, 64285, 64287, 64296, 64298, 64310, 64312, 64316,
    64318, 64318, 64320, 64321, 64323, 64324, 64326, 64433,
    64467, 64829, 64848, 64911, 64914, 64967, 65008, 65019,
    65136, 65140, 65142, 65276, 65313, 65338, 65345, 65370,
    65382, 65470, 65474, 65479, 65482, 65487, 65490, 65495,
    65498, 65500, 65536, 65547, 65549, 65574, 65576, 65594,
    65596, 65597, 65599, 65613, 65616, 65629, 65664, 65786,
    65856, 65908, 66176, 66204, 66208, 66256, 66304, 66334,
    66352, 66378, 66432, 66461, 66464, 66499, 66504, 66511,
    66513, 66517, 66560, 66717, 67584, 67589, 67592, 67592,
    67594, 67637, 67639, 67640, 67644, 67644, 67647, 67669,
    67840, 67861, 67872, 67897, 68096, 68096, 68112, 68115,
    68117, 68119, 68121, 68147, 68192, 68220, 68352, 68405,
    68416, 68437, 68448, 68466, 68608, 68680, 69635, 69687,
    69763, 69807, 73728, 74606, 74752, 74850, 77824, 78894,
    92160, 92728, 110592, 110593, 119808, 119892, 119894, 119964,
    119966, 119967, 119970, 119970, 119973, 119974, 119977, 119980,
    119982, 119993, 119995, 119995, 119997, 120003, 120005, 120069,
    120071, 120074, 120077, 120084, 120086, 120092, 120094, 120121,
    120123, 120126, 120128, 120132, 120134, 120134, 120138, 120144,
    120146, 120485, 120488, 120512, 120514, 120538, 120540, 120570,
    120572, 120596, 120598, 120628, 120630, 120654, 120656, 120686,
    120688, 120712, 120714, 120744, 120746, 120770, 120772, 120779,
    131072, 131072, 173782, 173782, 173824, 173824, 177972, 177972,
    177984, 177984, 178205, 178205, 194560, 195101
];
var identifierStartTable = [];
for (var i = 0; i < 128; i++) {
    identifierStartTable[i] =
        i >= 48 && i <= 57 || // 0-9
            i === 36 || // $
            i === 126 || // ~
            i === 124 || // |
            i >= 65 && i <= 90 || // A-Z
            i === 95 || // _
            i === 45 || // -
            i === 42 || // *
            i === 58 || // :
            i === 91 || // templateStart [
            i === 93 || // templateEnd ]
            i === 63 || // ?
            i === 37 || // %
            i === 35 || // #
            i === 61 || // =
            i >= 97 && i <= 122; // a-z
}
var identifierPartTable = identifierStartTable;
function Lexer(expression) {
    this.input = expression;
    this.char = 1;
    this.from = 1;
}
Lexer.prototype = {
    peek: function (i) {
        return this.input.charAt(i || 0);
    },
    skip: function (i) {
        i = i || 1;
        this.char += i;
        this.input = this.input.slice(i);
    },
    tokenize: function () {
        var list = [];
        var token;
        while (token = this.next()) {
            list.push(token);
        }
        return list;
    },
    next: function () {
        this.from = this.char;
        // Move to the next non-space character.
        var start;
        if (/\s/.test(this.peek())) {
            start = this.char;
            while (/\s/.test(this.peek())) {
                this.from += 1;
                this.skip();
            }
            if (this.peek() === "") {
                return null;
            }
        }
        var match = this.scanStringLiteral();
        if (match) {
            return match;
        }
        match =
            this.scanPunctuator() ||
                this.scanNumericLiteral() ||
                this.scanIdentifier() ||
                this.scanTemplateSequence();
        if (match) {
            this.skip(match.value.length);
            return match;
        }
        // No token could be matched, give up.
        return null;
    },
    scanTemplateSequence: function () {
        if (this.peek() === '[' && this.peek(1) === '[') {
            return {
                type: 'templateStart',
                value: '[[',
                pos: this.char
            };
        }
        if (this.peek() === ']' && this.peek(1) === ']') {
            return {
                type: 'templateEnd',
                value: '[[',
                pos: this.char
            };
        }
        return null;
    },
    /*
     * Extract a JavaScript identifier out of the next sequence of
     * characters or return 'null' if its not possible. In addition,
     * to Identifier this method can also produce BooleanLiteral
     * (true/false) and NullLiteral (null).
     */
    scanIdentifier: function () {
        var id = "";
        var index = 0;
        var type, char;
        // Detects any character in the Unicode categories "Uppercase
        // letter (Lu)", "Lowercase letter (Ll)", "Titlecase letter
        // (Lt)", "Modifier letter (Lm)", "Other letter (Lo)", or
        // "Letter number (Nl)".
        //
        // Both approach and unicodeLetterTable were borrowed from
        // Google's Traceur.
        function isUnicodeLetter(code) {
            for (var i = 0; i < unicodeLetterTable.length;) {
                if (code < unicodeLetterTable[i++]) {
                    return false;
                }
                if (code <= unicodeLetterTable[i++]) {
                    return true;
                }
            }
            return false;
        }
        function isHexDigit(str) {
            return (/^[0-9a-fA-F]$/).test(str);
        }
        var readUnicodeEscapeSequence = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.bind(function () {
            /*jshint validthis:true */
            index += 1;
            if (this.peek(index) !== "u") {
                return null;
            }
            var ch1 = this.peek(index + 1);
            var ch2 = this.peek(index + 2);
            var ch3 = this.peek(index + 3);
            var ch4 = this.peek(index + 4);
            var code;
            if (isHexDigit(ch1) && isHexDigit(ch2) && isHexDigit(ch3) && isHexDigit(ch4)) {
                code = parseInt(ch1 + ch2 + ch3 + ch4, 16);
                if (isUnicodeLetter(code)) {
                    index += 5;
                    return "\\u" + ch1 + ch2 + ch3 + ch4;
                }
                return null;
            }
            return null;
        }, this);
        var getIdentifierStart = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.bind(function () {
            /*jshint validthis:true */
            var chr = this.peek(index);
            var code = chr.charCodeAt(0);
            if (chr === '*') {
                index += 1;
                return chr;
            }
            if (code === 92) {
                return readUnicodeEscapeSequence();
            }
            if (code < 128) {
                if (identifierStartTable[code]) {
                    index += 1;
                    return chr;
                }
                return null;
            }
            if (isUnicodeLetter(code)) {
                index += 1;
                return chr;
            }
            return null;
        }, this);
        var getIdentifierPart = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.bind(function () {
            /*jshint validthis:true */
            var chr = this.peek(index);
            var code = chr.charCodeAt(0);
            if (code === 92) {
                return readUnicodeEscapeSequence();
            }
            if (code < 128) {
                if (identifierPartTable[code]) {
                    index += 1;
                    return chr;
                }
                return null;
            }
            if (isUnicodeLetter(code)) {
                index += 1;
                return chr;
            }
            return null;
        }, this);
        char = getIdentifierStart();
        if (char === null) {
            return null;
        }
        id = char;
        for (;;) {
            char = getIdentifierPart();
            if (char === null) {
                break;
            }
            id += char;
        }
        switch (id) {
            case 'true': {
                type = 'bool';
                break;
            }
            case 'false': {
                type = 'bool';
                break;
            }
            default:
                type = "identifier";
        }
        return {
            type: type,
            value: id,
            pos: this.char
        };
    },
    /*
     * Extract a numeric literal out of the next sequence of
     * characters or return 'null' if its not possible. This method
     * supports all numeric literals described in section 7.8.3
     * of the EcmaScript 5 specification.
     *
     * This method's implementation was heavily influenced by the
     * scanNumericLiteral function in the Esprima parser's source code.
     */
    scanNumericLiteral: function () {
        var index = 0;
        var value = "";
        var length = this.input.length;
        var char = this.peek(index);
        var bad;
        function isDecimalDigit(str) {
            return (/^[0-9]$/).test(str);
        }
        function isOctalDigit(str) {
            return (/^[0-7]$/).test(str);
        }
        function isHexDigit(str) {
            return (/^[0-9a-fA-F]$/).test(str);
        }
        function isIdentifierStart(ch) {
            return (ch === "$") || (ch === "_") || (ch === "\\") ||
                (ch >= "a" && ch <= "z") || (ch >= "A" && ch <= "Z");
        }
        // handle negative num literals
        if (char === '-') {
            value += char;
            index += 1;
            char = this.peek(index);
        }
        // Numbers must start either with a decimal digit or a point.
        if (char !== "." && !isDecimalDigit(char)) {
            return null;
        }
        if (char !== ".") {
            value += this.peek(index);
            index += 1;
            char = this.peek(index);
            if (value === "0") {
                // Base-16 numbers.
                if (char === "x" || char === "X") {
                    index += 1;
                    value += char;
                    while (index < length) {
                        char = this.peek(index);
                        if (!isHexDigit(char)) {
                            break;
                        }
                        value += char;
                        index += 1;
                    }
                    if (value.length <= 2) {
                        return {
                            type: 'number',
                            value: value,
                            isMalformed: true,
                            pos: this.char
                        };
                    }
                    if (index < length) {
                        char = this.peek(index);
                        if (isIdentifierStart(char)) {
                            return null;
                        }
                    }
                    return {
                        type: 'number',
                        value: value,
                        base: 16,
                        isMalformed: false,
                        pos: this.char
                    };
                }
                // Base-8 numbers.
                if (isOctalDigit(char)) {
                    index += 1;
                    value += char;
                    bad = false;
                    while (index < length) {
                        char = this.peek(index);
                        // Numbers like '019' (note the 9) are not valid octals
                        // but we still parse them and mark as malformed.
                        if (isDecimalDigit(char)) {
                            bad = true;
                        }
                        if (!isOctalDigit(char)) {
                            // if the char is a non punctuator then its not a valid number
                            if (!this.isPunctuator(char)) {
                                return null;
                            }
                            break;
                        }
                        value += char;
                        index += 1;
                    }
                    if (index < length) {
                        char = this.peek(index);
                        if (isIdentifierStart(char)) {
                            return null;
                        }
                    }
                    return {
                        type: 'number',
                        value: value,
                        base: 8,
                        isMalformed: bad
                    };
                }
                // Decimal numbers that start with '0' such as '09' are illegal
                // but we still parse them and return as malformed.
                if (isDecimalDigit(char)) {
                    index += 1;
                    value += char;
                }
            }
            while (index < length) {
                char = this.peek(index);
                if (!isDecimalDigit(char)) {
                    break;
                }
                value += char;
                index += 1;
            }
        }
        // Decimal digits.
        if (char === ".") {
            value += char;
            index += 1;
            while (index < length) {
                char = this.peek(index);
                if (!isDecimalDigit(char)) {
                    break;
                }
                value += char;
                index += 1;
            }
        }
        // Exponent part.
        if (char === "e" || char === "E") {
            value += char;
            index += 1;
            char = this.peek(index);
            if (char === "+" || char === "-") {
                value += this.peek(index);
                index += 1;
            }
            char = this.peek(index);
            if (isDecimalDigit(char)) {
                value += char;
                index += 1;
                while (index < length) {
                    char = this.peek(index);
                    if (!isDecimalDigit(char)) {
                        break;
                    }
                    value += char;
                    index += 1;
                }
            }
            else {
                return null;
            }
        }
        if (index < length) {
            char = this.peek(index);
            if (!this.isPunctuator(char)) {
                return null;
            }
        }
        return {
            type: 'number',
            value: value,
            base: 10,
            pos: this.char,
            isMalformed: !isFinite(+value)
        };
    },
    isPunctuator: function (ch1) {
        switch (ch1) {
            case ".":
            case "(":
            case ")":
            case ",":
            case "{":
            case "}":
                return true;
        }
        return false;
    },
    scanPunctuator: function () {
        var ch1 = this.peek();
        if (this.isPunctuator(ch1)) {
            return {
                type: ch1,
                value: ch1,
                pos: this.char
            };
        }
        return null;
    },
    /*
     * Extract a string out of the next sequence of characters and/or
     * lines or return 'null' if its not possible. Since strings can
     * span across multiple lines this method has to move the char
     * pointer.
     *
     * This method recognizes pseudo-multiline JavaScript strings:
     *
     *   var str = "hello\
     *   world";
     */
    scanStringLiteral: function () {
        /*jshint loopfunc:true */
        var quote = this.peek();
        // String must start with a quote.
        if (quote !== "\"" && quote !== "'") {
            return null;
        }
        var value = "";
        this.skip();
        while (this.peek() !== quote) {
            if (this.peek() === "") {
                return {
                    type: 'string',
                    value: value,
                    isUnclosed: true,
                    quote: quote,
                    pos: this.char
                };
            }
            var char = this.peek();
            var jump = 1; // A length of a jump, after we're done
            // parsing this character.
            value += char;
            this.skip(jump);
        }
        this.skip();
        return {
            type: 'string',
            value: value,
            isUnclosed: false,
            quote: quote,
            pos: this.char
        };
    },
};


/***/ }),

/***/ 1439:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return GraphiteConfigCtrl; });
///<reference path="../../../headers/common.d.ts" />
var GraphiteConfigCtrl = /** @class */ (function () {
    /** @ngInject */
    GraphiteConfigCtrl.$inject = ["$scope", "datasourceSrv"];
    function GraphiteConfigCtrl($scope, datasourceSrv) {
        this.graphiteVersions = [
            { name: '0.9.x', value: '0.9' },
            { name: '1.0.x', value: '1.0' },
            { name: '1.1.x', value: '1.1' },
        ];
        this.datasourceSrv = datasourceSrv;
        this.current.jsonData = this.current.jsonData || {};
        this.current.jsonData.graphiteVersion = this.current.jsonData.graphiteVersion || '0.9';
        this.autoDetectGraphiteVersion();
    }
    GraphiteConfigCtrl.prototype.autoDetectGraphiteVersion = function () {
        var _this = this;
        this.datasourceSrv.loadDatasource(this.current.name)
            .then(function (ds) {
            return ds.getVersion();
        }).then(function (version) {
            _this.graphiteVersions.push({ name: version, value: version });
            _this.current.jsonData.graphiteVersion = version;
        });
    };
    GraphiteConfigCtrl.templateUrl = 'public/app/plugins/datasource/graphite/partials/config.html';
    return GraphiteConfigCtrl;
}());



/***/ }),

/***/ 1440:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AnnotationsQueryCtrl", function() { return CloudWatchAnnotationsQueryCtrl; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__query_parameter_ctrl__ = __webpack_require__(1330);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__query_parameter_ctrl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__query_parameter_ctrl__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__datasource__ = __webpack_require__(1441);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__datasource___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__datasource__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__query_ctrl__ = __webpack_require__(1442);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__config_ctrl__ = __webpack_require__(1443);
/* harmony reexport (default from non-hamory) */ __webpack_require__.d(__webpack_exports__, "Datasource", function() { return __WEBPACK_IMPORTED_MODULE_1__datasource___default.a; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "QueryCtrl", function() { return __WEBPACK_IMPORTED_MODULE_2__query_ctrl__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "ConfigCtrl", function() { return __WEBPACK_IMPORTED_MODULE_3__config_ctrl__["a"]; });




var CloudWatchAnnotationsQueryCtrl = /** @class */ (function () {
    function CloudWatchAnnotationsQueryCtrl() {
    }
    CloudWatchAnnotationsQueryCtrl.templateUrl = 'partials/annotations.editor.html';
    return CloudWatchAnnotationsQueryCtrl;
}());



/***/ }),

/***/ 1441:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
  __webpack_require__(12),
  __webpack_require__(7),
  __webpack_require__(1),
  __webpack_require__(467),
  __webpack_require__(464),
  __webpack_require__(1306),
], __WEBPACK_AMD_DEFINE_RESULT__ = function (angular, _, moment, dateMath, kbn, templatingVariable) {
  'use strict';

  CloudWatchDatasource.$inject = ["instanceSettings", "$q", "backendSrv", "templateSrv", "timeSrv"];
  kbn = kbn.default;

  /** @ngInject */
  function CloudWatchDatasource(instanceSettings, $q, backendSrv, templateSrv, timeSrv) {
    this.type = 'cloudwatch';
    this.name = instanceSettings.name;
    this.supportMetrics = true;
    this.proxyUrl = instanceSettings.url;
    this.defaultRegion = instanceSettings.jsonData.defaultRegion;
    this.instanceSettings = instanceSettings;
    this.standardStatistics = [
      'Average',
      'Maximum',
      'Minimum',
      'Sum',
      'SampleCount'
    ];

    var self = this;
    this.query = function(options) {
      options = angular.copy(options);
      options.targets = this.expandTemplateVariable(options.targets, options.scopedVars, templateSrv);

      var queries = _.filter(options.targets, function (item) {
        return item.hide !== true &&
          !!item.region &&
          !!item.namespace &&
          !!item.metricName &&
          !_.isEmpty(item.statistics);
      }).map(function (item) {
        item.region = templateSrv.replace(item.region, options.scopedVars);
        item.namespace = templateSrv.replace(item.namespace, options.scopedVars);
        item.metricName = templateSrv.replace(item.metricName, options.scopedVars);
        item.dimensions = self.convertDimensionFormat(item.dimensions, options.scopeVars);
        item.period = String(self.getPeriod(item, options)); // use string format for period in graph query, and alerting

        return _.extend({
          refId: item.refId,
          intervalMs: options.intervalMs,
          maxDataPoints: options.maxDataPoints,
          datasourceId: self.instanceSettings.id,
          type: 'timeSeriesQuery',
        }, item);
      });

      // No valid targets, return the empty result to save a round trip.
      if (_.isEmpty(queries)) {
        var d = $q.defer();
        d.resolve({ data: [] });
        return d.promise;
      }

      var request = {
        from: options.range.from.valueOf().toString(),
        to: options.range.to.valueOf().toString(),
        queries: queries
      };

      return this.performTimeSeriesQuery(request);
    };

    this.getPeriod = function(target, options, now) {
      var start = this.convertToCloudWatchTime(options.range.from, false);
      var end = this.convertToCloudWatchTime(options.range.to, true);
      now = Math.round((now || Date.now()) / 1000);

      var period;
      var range = end - start;

      var hourSec = 60 * 60;
      var daySec = hourSec * 24;
      var periodUnit = 60;
      if (!target.period) {
        if (now - start <= (daySec * 15)) { // until 15 days ago
          if (target.namespace === 'AWS/EC2') {
            periodUnit = period = 300;
          } else {
            periodUnit = period = 60;
          }
        } else if (now - start <= (daySec * 63)) { // until 63 days ago
          periodUnit = period = 60 * 5;
        } else if (now - start <= (daySec * 455)) { // until 455 days ago
          periodUnit = period = 60 * 60;
        } else { // over 455 days, should return error, but try to long period
          periodUnit = period = 60 * 60;
        }
      } else {
        if (/^\d+$/.test(target.period)) {
          period = parseInt(target.period, 10);
        } else {
          period = kbn.interval_to_seconds(templateSrv.replace(target.period, options.scopedVars));
        }
      }
      if (period < 1) {
        period = 1;
      }
      if (range / period >= 1440) {
        period = Math.ceil(range / 1440 / periodUnit) * periodUnit;
      }

      return period;
    };

    this.performTimeSeriesQuery = function(request) {
      return backendSrv.post('/api/tsdb/query', request).then(function (res) {
        var data = [];

        if (res.results) {
          _.forEach(res.results, function (queryRes) {
            _.forEach(queryRes.series, function (series) {
              data.push({target: series.name, datapoints: series.points});
            });
          });
        }

        return {data: data};
      });
    };

    function transformSuggestDataFromTable(suggestData) {
      return _.map(suggestData.results['metricFindQuery'].tables[0].rows, function (v) {
        return {
          text: v[0],
          value: v[1]
        };
      });
    }

    this.doMetricQueryRequest = function (subtype, parameters) {
      var range = timeSrv.timeRange();
      return backendSrv.post('/api/tsdb/query', {
        from: range.from.valueOf().toString(),
        to: range.to.valueOf().toString(),
        queries: [
          _.extend({
            refId: 'metricFindQuery',
            intervalMs: 1, // dummy
            maxDataPoints: 1, // dummy
            datasourceId: this.instanceSettings.id,
            type: 'metricFindQuery',
            subtype: subtype
          }, parameters)
        ]
      }).then(function (r) { return transformSuggestDataFromTable(r); });
    };

    this.getRegions = function () {
      return this.doMetricQueryRequest('regions', null);
    };

    this.getNamespaces = function() {
      return this.doMetricQueryRequest('namespaces', null);
    };

    this.getMetrics = function (namespace, region) {
      return this.doMetricQueryRequest('metrics', {
        region: templateSrv.replace(region),
        namespace: templateSrv.replace(namespace)
      });
    };

    this.getDimensionKeys = function(namespace, region) {
      return this.doMetricQueryRequest('dimension_keys', {
        region: templateSrv.replace(region),
        namespace: templateSrv.replace(namespace)
      });
    };

    this.getDimensionValues = function(region, namespace, metricName, dimensionKey, filterDimensions) {
      return this.doMetricQueryRequest('dimension_values', {
        region: templateSrv.replace(region),
        namespace: templateSrv.replace(namespace),
        metricName: templateSrv.replace(metricName),
        dimensionKey: templateSrv.replace(dimensionKey),
        dimensions: this.convertDimensionFormat(filterDimensions, {}),
      });
    };

    this.getEbsVolumeIds = function(region, instanceId) {
      return this.doMetricQueryRequest('ebs_volume_ids', {
        region: templateSrv.replace(region),
        instanceId: templateSrv.replace(instanceId)
      });
    };

    this.getEc2InstanceAttribute = function(region, attributeName, filters) {
      return this.doMetricQueryRequest('ec2_instance_attribute', {
        region: templateSrv.replace(region),
        attributeName: templateSrv.replace(attributeName),
        filters: filters
      });
    };

    this.metricFindQuery = function(query) {
      var region;
      var namespace;
      var metricName;

      var regionQuery = query.match(/^regions\(\)/);
      if (regionQuery) {
        return this.getRegions();
      }

      var namespaceQuery = query.match(/^namespaces\(\)/);
      if (namespaceQuery) {
        return this.getNamespaces();
      }

      var metricNameQuery = query.match(/^metrics\(([^\)]+?)(,\s?([^,]+?))?\)/);
      if (metricNameQuery) {
        namespace = metricNameQuery[1];
        region = metricNameQuery[3];
        return this.getMetrics(namespace, region);
      }

      var dimensionKeysQuery = query.match(/^dimension_keys\(([^\)]+?)(,\s?([^,]+?))?\)/);
      if (dimensionKeysQuery) {
        namespace = dimensionKeysQuery[1];
        region = dimensionKeysQuery[3];
        return this.getDimensionKeys(namespace, region);
      }

      var dimensionValuesQuery = query.match(/^dimension_values\(([^,]+?),\s?([^,]+?),\s?([^,]+?),\s?([^,]+?)\)/);
      if (dimensionValuesQuery) {
        region = dimensionValuesQuery[1];
        namespace = dimensionValuesQuery[2];
        metricName = dimensionValuesQuery[3];
        var dimensionKey = dimensionValuesQuery[4];

        return this.getDimensionValues(region, namespace, metricName, dimensionKey, {});
      }

      var ebsVolumeIdsQuery = query.match(/^ebs_volume_ids\(([^,]+?),\s?([^,]+?)\)/);
      if (ebsVolumeIdsQuery) {
        region = ebsVolumeIdsQuery[1];
        var instanceId = ebsVolumeIdsQuery[2];
        return this.getEbsVolumeIds(region, instanceId);
      }

      var ec2InstanceAttributeQuery = query.match(/^ec2_instance_attribute\(([^,]+?),\s?([^,]+?),\s?(.+?)\)/);
      if (ec2InstanceAttributeQuery) {
        region = ec2InstanceAttributeQuery[1];
        var targetAttributeName = ec2InstanceAttributeQuery[2];
        var filterJson = JSON.parse(templateSrv.replace(ec2InstanceAttributeQuery[3]));
        return this.getEc2InstanceAttribute(region, targetAttributeName, filterJson);
      }

      return $q.when([]);
    };

    this.annotationQuery = function (options) {
      var annotation = options.annotation;
      var statistics = _.map(annotation.statistics, function (s) { return templateSrv.replace(s); });
      var defaultPeriod = annotation.prefixMatching ? '' : '300';
      var period = annotation.period || defaultPeriod;
      period = parseInt(period, 10);
      var parameters = {
        prefixMatching: annotation.prefixMatching,
        region: templateSrv.replace(annotation.region),
        namespace: templateSrv.replace(annotation.namespace),
        metricName: templateSrv.replace(annotation.metricName),
        dimensions: this.convertDimensionFormat(annotation.dimensions, {}),
        statistics: statistics,
        period: period,
        actionPrefix: annotation.actionPrefix || '',
        alarmNamePrefix: annotation.alarmNamePrefix || ''
      };

      return backendSrv.post('/api/tsdb/query', {
        from: options.range.from.valueOf().toString(),
        to: options.range.to.valueOf().toString(),
        queries: [
          _.extend({
            refId: 'annotationQuery',
            intervalMs: 1, // dummy
            maxDataPoints: 1, // dummy
            datasourceId: this.instanceSettings.id,
            type: 'annotationQuery'
          }, parameters)
        ]
      }).then(function (r) {
        return _.map(r.results['annotationQuery'].tables[0].rows, function (v) {
          return {
            annotation: annotation,
            time: Date.parse(v[0]),
            title: v[1],
            tags: [v[2]],
            text: v[3]
          };
        });
      });
    };

    this.targetContainsTemplate = function(target) {
      return templateSrv.variableExists(target.region) ||
      templateSrv.variableExists(target.namespace) ||
      templateSrv.variableExists(target.metricName) ||
      _.find(target.dimensions, function(v, k) {
        return templateSrv.variableExists(k) || templateSrv.variableExists(v);
      });
    };

    this.testDatasource = function() {
      /* use billing metrics for test */
      var region = this.defaultRegion;
      var namespace = 'AWS/Billing';
      var metricName = 'EstimatedCharges';
      var dimensions = {};

      return this.getDimensionValues(region, namespace, metricName, 'ServiceName', dimensions).then(function () {
        return { status: 'success', message: 'Data source is working' };
      }, function (err) {
        return { status: 'error', message: err.message };
      });
    };

    this.awsRequest = function(data) {
      var options = {
        method: 'POST',
        url: this.proxyUrl,
        data: data
      };

      return backendSrv.datasourceRequest(options).then(function(result) {
        return result.data;
      });
    };

    this.getDefaultRegion = function() {
      return this.defaultRegion;
    };

    this.getExpandedVariables = function(target, dimensionKey, variable, templateSrv) {
      /* if the all checkbox is marked we should add all values to the targets */
      var allSelected = _.find(variable.options, {'selected': true, 'text': 'All'});
      return _.chain(variable.options)
      .filter(function(v) {
        if (allSelected) {
          return v.text !== 'All';
        } else {
          return v.selected;
        }
      })
      .map(function(v) {
        var t = angular.copy(target);
        var scopedVar = {};
        scopedVar[variable.name] = v;
        t.refId = target.refId + '_' + v.value;
        t.dimensions[dimensionKey] = templateSrv.replace(t.dimensions[dimensionKey], scopedVar);
        return t;
      }).value();
    };

    this.expandTemplateVariable = function(targets, scopedVars, templateSrv) {
      var self = this;
      return _.chain(targets)
      .map(function(target) {
        var dimensionKey = _.findKey(target.dimensions, function(v) {
          return templateSrv.variableExists(v) && !_.has(scopedVars, templateSrv.getVariableName(v));
        });

        if (dimensionKey) {
          var multiVariable = _.find(templateSrv.variables, function(variable) {
            return templatingVariable.containsVariable(target.dimensions[dimensionKey], variable.name) && variable.multi;
          });
          var variable = _.find(templateSrv.variables, function(variable) {
            return templatingVariable.containsVariable(target.dimensions[dimensionKey], variable.name);
          });
          return self.getExpandedVariables(target, dimensionKey, multiVariable || variable, templateSrv);
        } else {
          return [target];
        }
      }).flatten().value();
    };

    this.convertToCloudWatchTime = function(date, roundUp) {
      if (_.isString(date)) {
        date = dateMath.parse(date, roundUp);
      }
      return Math.round(date.valueOf() / 1000);
    };

    this.convertDimensionFormat = function(dimensions, scopedVars) {
      var convertedDimensions = {};
      _.each(dimensions, function (value, key) {
        convertedDimensions[templateSrv.replace(key, scopedVars)] = templateSrv.replace(value, scopedVars);
      });
      return convertedDimensions;
    };

  }

  return CloudWatchDatasource;
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ 1442:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CloudWatchQueryCtrl; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__query_parameter_ctrl__ = __webpack_require__(1330);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__query_parameter_ctrl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__query_parameter_ctrl__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_app_plugins_sdk__ = __webpack_require__(1305);
///<reference path="../../../headers/common.d.ts" />
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();


var CloudWatchQueryCtrl = /** @class */ (function (_super) {
    __extends(CloudWatchQueryCtrl, _super);
    /** @ngInject **/
    CloudWatchQueryCtrl.$inject = ["$scope", "$injector"];
    function CloudWatchQueryCtrl($scope, $injector) {
        var _this = _super.call(this, $scope, $injector) || this;
        _this.aliasSyntax = '{{metric}} {{stat}} {{namespace}} {{region}} {{<dimension name>}}';
        return _this;
    }
    CloudWatchQueryCtrl.templateUrl = 'partials/query.editor.html';
    return CloudWatchQueryCtrl;
}(__WEBPACK_IMPORTED_MODULE_1_app_plugins_sdk__["QueryCtrl"]));



/***/ }),

/***/ 1443:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CloudWatchConfigCtrl; });
///<reference path="../../../headers/common.d.ts" />
var CloudWatchConfigCtrl = /** @class */ (function () {
    /** @ngInject */
    CloudWatchConfigCtrl.$inject = ["$scope"];
    function CloudWatchConfigCtrl($scope) {
        this.accessKeyExist = false;
        this.secretKeyExist = false;
        this.authTypes = [
            { name: 'Access & secret key', value: 'keys' },
            { name: 'Credentials file', value: 'credentials' },
            { name: 'ARN', value: 'arn' },
        ];
        this.indexPatternTypes = [
            { name: 'No pattern', value: undefined },
            { name: 'Hourly', value: 'Hourly', example: '[logstash-]YYYY.MM.DD.HH' },
            { name: 'Daily', value: 'Daily', example: '[logstash-]YYYY.MM.DD' },
            { name: 'Weekly', value: 'Weekly', example: '[logstash-]GGGG.WW' },
            { name: 'Monthly', value: 'Monthly', example: '[logstash-]YYYY.MM' },
            { name: 'Yearly', value: 'Yearly', example: '[logstash-]YYYY' },
        ];
        this.current.jsonData.timeField = this.current.jsonData.timeField || '@timestamp';
        this.current.jsonData.authType = this.current.jsonData.authType || 'credentials';
        this.accessKeyExist = this.current.secureJsonFields.accessKey;
        this.secretKeyExist = this.current.secureJsonFields.secretKey;
    }
    CloudWatchConfigCtrl.prototype.resetAccessKey = function () {
        this.accessKeyExist = false;
    };
    CloudWatchConfigCtrl.prototype.resetSecretKey = function () {
        this.secretKeyExist = false;
    };
    CloudWatchConfigCtrl.templateUrl = 'partials/config.html';
    return CloudWatchConfigCtrl;
}());



/***/ }),

/***/ 1444:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "QueryOptionsCtrl", function() { return ElasticQueryOptionsCtrl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AnnotationsQueryCtrl", function() { return ElasticAnnotationsQueryCtrl; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__datasource__ = __webpack_require__(1445);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__query_ctrl__ = __webpack_require__(1449);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__config_ctrl__ = __webpack_require__(1452);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "Datasource", function() { return __WEBPACK_IMPORTED_MODULE_0__datasource__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "QueryCtrl", function() { return __WEBPACK_IMPORTED_MODULE_1__query_ctrl__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "ConfigCtrl", function() { return __WEBPACK_IMPORTED_MODULE_2__config_ctrl__["a"]; });



var ElasticQueryOptionsCtrl = /** @class */ (function () {
    function ElasticQueryOptionsCtrl() {
    }
    ElasticQueryOptionsCtrl.templateUrl = 'partials/query.options.html';
    return ElasticQueryOptionsCtrl;
}());
var ElasticAnnotationsQueryCtrl = /** @class */ (function () {
    function ElasticAnnotationsQueryCtrl() {
    }
    ElasticAnnotationsQueryCtrl.templateUrl = 'partials/annotations.editor.html';
    return ElasticAnnotationsQueryCtrl;
}());



/***/ }),

/***/ 1445:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ElasticDatasource; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_angular__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_angular___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_angular__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_lodash__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_moment__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_moment___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_moment__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__query_builder__ = __webpack_require__(1446);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__index_pattern__ = __webpack_require__(1447);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__elastic_response__ = __webpack_require__(1448);
///<reference path="../../../headers/common.d.ts" />






var ElasticDatasource = /** @class */ (function () {
    /** @ngInject */
    ElasticDatasource.$inject = ["instanceSettings", "$q", "backendSrv", "templateSrv", "timeSrv"];
    function ElasticDatasource(instanceSettings, $q, backendSrv, templateSrv, timeSrv) {
        this.$q = $q;
        this.backendSrv = backendSrv;
        this.templateSrv = templateSrv;
        this.timeSrv = timeSrv;
        this.basicAuth = instanceSettings.basicAuth;
        this.withCredentials = instanceSettings.withCredentials;
        this.url = instanceSettings.url;
        this.name = instanceSettings.name;
        this.index = instanceSettings.index;
        this.timeField = instanceSettings.jsonData.timeField;
        this.esVersion = instanceSettings.jsonData.esVersion;
        this.indexPattern = new __WEBPACK_IMPORTED_MODULE_4__index_pattern__["a" /* IndexPattern */](instanceSettings.index, instanceSettings.jsonData.interval);
        this.interval = instanceSettings.jsonData.timeInterval;
        this.queryBuilder = new __WEBPACK_IMPORTED_MODULE_3__query_builder__["a" /* ElasticQueryBuilder */]({
            timeField: this.timeField,
            esVersion: this.esVersion,
        });
    }
    ElasticDatasource.prototype.request = function (method, url, data) {
        var options = {
            url: this.url + "/" + url,
            method: method,
            data: data
        };
        if (this.basicAuth || this.withCredentials) {
            options.withCredentials = true;
        }
        if (this.basicAuth) {
            options.headers = {
                "Authorization": this.basicAuth
            };
        }
        return this.backendSrv.datasourceRequest(options);
    };
    ElasticDatasource.prototype.get = function (url) {
        var range = this.timeSrv.timeRange();
        var index_list = this.indexPattern.getIndexList(range.from.valueOf(), range.to.valueOf());
        if (__WEBPACK_IMPORTED_MODULE_1_lodash___default.a.isArray(index_list) && index_list.length) {
            return this.request('GET', index_list[0] + url).then(function (results) {
                results.data.$$config = results.config;
                return results.data;
            });
        }
        else {
            return this.request('GET', this.indexPattern.getIndexForToday() + url).then(function (results) {
                results.data.$$config = results.config;
                return results.data;
            });
        }
    };
    ElasticDatasource.prototype.post = function (url, data) {
        return this.request('POST', url, data).then(function (results) {
            results.data.$$config = results.config;
            return results.data;
        }).catch(function (err) {
            if (err.data && err.data.error) {
                throw { message: 'Elasticsearch error: ' + err.data.error.reason, error: err.data.error };
            }
            throw err;
        });
    };
    ElasticDatasource.prototype.annotationQuery = function (options) {
        var annotation = options.annotation;
        var timeField = annotation.timeField || '@timestamp';
        var queryString = annotation.query || '*';
        var tagsField = annotation.tagsField || 'tags';
        var textField = annotation.textField || null;
        var range = {};
        range[timeField] = {
            from: options.range.from.valueOf(),
            to: options.range.to.valueOf(),
            format: "epoch_millis",
        };
        var queryInterpolated = this.templateSrv.replace(queryString, {}, 'lucene');
        var query = {
            "bool": {
                "filter": [
                    { "range": range },
                    {
                        "query_string": {
                            "query": queryInterpolated
                        }
                    }
                ]
            }
        };
        var data = {
            "query": query,
            "size": 10000
        };
        // fields field not supported on ES 5.x
        if (this.esVersion < 5) {
            data["fields"] = [timeField, "_source"];
        }
        var header = { search_type: "query_then_fetch", "ignore_unavailable": true };
        // old elastic annotations had index specified on them
        if (annotation.index) {
            header.index = annotation.index;
        }
        else {
            header.index = this.indexPattern.getIndexList(options.range.from, options.range.to);
        }
        var payload = __WEBPACK_IMPORTED_MODULE_0_angular___default.a.toJson(header) + '\n' + __WEBPACK_IMPORTED_MODULE_0_angular___default.a.toJson(data) + '\n';
        return this.post('_msearch', payload).then(function (res) {
            var list = [];
            var hits = res.responses[0].hits.hits;
            var getFieldFromSource = function (source, fieldName) {
                if (!fieldName) {
                    return;
                }
                var fieldNames = fieldName.split('.');
                var fieldValue = source;
                for (var i = 0; i < fieldNames.length; i++) {
                    fieldValue = fieldValue[fieldNames[i]];
                    if (!fieldValue) {
                        console.log('could not find field in annotation: ', fieldName);
                        return '';
                    }
                }
                return fieldValue;
            };
            for (var i = 0; i < hits.length; i++) {
                var source = hits[i]._source;
                var time = source[timeField];
                if (typeof hits[i].fields !== 'undefined') {
                    var fields = hits[i].fields;
                    if (__WEBPACK_IMPORTED_MODULE_1_lodash___default.a.isString(fields[timeField]) || __WEBPACK_IMPORTED_MODULE_1_lodash___default.a.isNumber(fields[timeField])) {
                        time = fields[timeField];
                    }
                }
                var event = {
                    annotation: annotation,
                    time: __WEBPACK_IMPORTED_MODULE_2_moment___default.a.utc(time).valueOf(),
                    text: getFieldFromSource(source, textField),
                    tags: getFieldFromSource(source, tagsField),
                };
                // legacy support for title tield
                if (annotation.titleField) {
                    var title = getFieldFromSource(source, annotation.titleField);
                    if (title) {
                        event.text = title + '\n' + event.text;
                    }
                }
                if (typeof event.tags === 'string') {
                    event.tags = event.tags.split(',');
                }
                list.push(event);
            }
            return list;
        });
    };
    ElasticDatasource.prototype.testDatasource = function () {
        this.timeSrv.setTime({ from: 'now-1m', to: 'now' }, true);
        // validate that the index exist and has date field
        return this.getFields({ type: 'date' }).then(function (dateFields) {
            var timeField = __WEBPACK_IMPORTED_MODULE_1_lodash___default.a.find(dateFields, { text: this.timeField });
            if (!timeField) {
                return { status: "error", message: "No date field named " + this.timeField + ' found' };
            }
            return { status: "success", message: "Index OK. Time field name OK." };
        }.bind(this), function (err) {
            console.log(err);
            if (err.data && err.data.error) {
                var message = __WEBPACK_IMPORTED_MODULE_0_angular___default.a.toJson(err.data.error);
                if (err.data.error.reason) {
                    message = err.data.error.reason;
                }
                return { status: "error", message: message };
            }
            else {
                return { status: "error", message: err.status };
            }
        });
    };
    ElasticDatasource.prototype.getQueryHeader = function (searchType, timeFrom, timeTo) {
        return __WEBPACK_IMPORTED_MODULE_0_angular___default.a.toJson({
            search_type: searchType,
            "ignore_unavailable": true,
            index: this.indexPattern.getIndexList(timeFrom, timeTo),
        });
    };
    ElasticDatasource.prototype.query = function (options) {
        var payload = "";
        var target;
        var sentTargets = [];
        // add global adhoc filters to timeFilter
        var adhocFilters = this.templateSrv.getAdhocFilters(this.name);
        for (var i = 0; i < options.targets.length; i++) {
            target = options.targets[i];
            if (target.hide) {
                continue;
            }
            var queryString = this.templateSrv.replace(target.query || '*', options.scopedVars, 'lucene');
            var queryObj = this.queryBuilder.build(target, adhocFilters, queryString);
            var esQuery = __WEBPACK_IMPORTED_MODULE_0_angular___default.a.toJson(queryObj);
            var searchType = (queryObj.size === 0 && this.esVersion < 5) ? 'count' : 'query_then_fetch';
            var header = this.getQueryHeader(searchType, options.range.from, options.range.to);
            payload += header + '\n';
            payload += esQuery + '\n';
            sentTargets.push(target);
        }
        if (sentTargets.length === 0) {
            return this.$q.when([]);
        }
        payload = payload.replace(/\$timeFrom/g, options.range.from.valueOf());
        payload = payload.replace(/\$timeTo/g, options.range.to.valueOf());
        payload = this.templateSrv.replace(payload, options.scopedVars);
        return this.post('_msearch', payload).then(function (res) {
            return new __WEBPACK_IMPORTED_MODULE_5__elastic_response__["a" /* ElasticResponse */](sentTargets, res).getTimeSeries();
        });
    };
    ElasticDatasource.prototype.getFields = function (query) {
        return this.get('/_mapping').then(function (result) {
            var typeMap = {
                'float': 'number',
                'double': 'number',
                'integer': 'number',
                'long': 'number',
                'date': 'date',
                'string': 'string',
                'text': 'string',
                'scaled_float': 'number',
                'nested': 'nested'
            };
            function shouldAddField(obj, key, query) {
                if (key[0] === '_') {
                    return false;
                }
                if (!query.type) {
                    return true;
                }
                // equal query type filter, or via typemap translation
                return query.type === obj.type || query.type === typeMap[obj.type];
            }
            // Store subfield names: [system, process, cpu, total] -> system.process.cpu.total
            var fieldNameParts = [];
            var fields = {};
            function getFieldsRecursively(obj) {
                for (var key in obj) {
                    var subObj = obj[key];
                    // Check mapping field for nested fields
                    if (__WEBPACK_IMPORTED_MODULE_1_lodash___default.a.isObject(subObj.properties)) {
                        fieldNameParts.push(key);
                        getFieldsRecursively(subObj.properties);
                    }
                    if (__WEBPACK_IMPORTED_MODULE_1_lodash___default.a.isObject(subObj.fields)) {
                        fieldNameParts.push(key);
                        getFieldsRecursively(subObj.fields);
                    }
                    if (__WEBPACK_IMPORTED_MODULE_1_lodash___default.a.isString(subObj.type)) {
                        var fieldName = fieldNameParts.concat(key).join('.');
                        // Hide meta-fields and check field type
                        if (shouldAddField(subObj, key, query)) {
                            fields[fieldName] = {
                                text: fieldName,
                                type: subObj.type
                            };
                        }
                    }
                }
                fieldNameParts.pop();
            }
            for (var indexName in result) {
                var index = result[indexName];
                if (index && index.mappings) {
                    var mappings = index.mappings;
                    for (var typeName in mappings) {
                        var properties = mappings[typeName].properties;
                        getFieldsRecursively(properties);
                    }
                }
            }
            // transform to array
            return __WEBPACK_IMPORTED_MODULE_1_lodash___default.a.map(fields, function (value) {
                return value;
            });
        });
    };
    ElasticDatasource.prototype.getTerms = function (queryDef) {
        var range = this.timeSrv.timeRange();
        var searchType = this.esVersion >= 5 ? 'query_then_fetch' : 'count';
        var header = this.getQueryHeader(searchType, range.from, range.to);
        var esQuery = __WEBPACK_IMPORTED_MODULE_0_angular___default.a.toJson(this.queryBuilder.getTermsQuery(queryDef));
        esQuery = esQuery.replace(/\$timeFrom/g, range.from.valueOf());
        esQuery = esQuery.replace(/\$timeTo/g, range.to.valueOf());
        esQuery = header + '\n' + esQuery + '\n';
        return this.post('_msearch?search_type=' + searchType, esQuery).then(function (res) {
            if (!res.responses[0].aggregations) {
                return [];
            }
            var buckets = res.responses[0].aggregations["1"].buckets;
            return __WEBPACK_IMPORTED_MODULE_1_lodash___default.a.map(buckets, function (bucket) {
                return {
                    text: bucket.key_as_string || bucket.key,
                    value: bucket.key
                };
            });
        });
    };
    ElasticDatasource.prototype.metricFindQuery = function (query) {
        query = __WEBPACK_IMPORTED_MODULE_0_angular___default.a.fromJson(query);
        if (!query) {
            return this.$q.when([]);
        }
        if (query.find === 'fields') {
            query.field = this.templateSrv.replace(query.field, {}, 'lucene');
            return this.getFields(query);
        }
        if (query.find === 'terms') {
            query.query = this.templateSrv.replace(query.query || '*', {}, 'lucene');
            return this.getTerms(query);
        }
    };
    ElasticDatasource.prototype.getTagKeys = function () {
        return this.getFields({});
    };
    ElasticDatasource.prototype.getTagValues = function (options) {
        return this.getTerms({ field: options.key, query: '*' });
    };
    return ElasticDatasource;
}());



/***/ }),

/***/ 1446:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ElasticQueryBuilder; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__query_def__ = __webpack_require__(1311);

var ElasticQueryBuilder = /** @class */ (function () {
    function ElasticQueryBuilder(options) {
        this.timeField = options.timeField;
        this.esVersion = options.esVersion;
    }
    ElasticQueryBuilder.prototype.getRangeFilter = function () {
        var filter = {};
        filter[this.timeField] = {
            gte: "$timeFrom",
            lte: "$timeTo",
            format: "epoch_millis",
        };
        return filter;
    };
    ElasticQueryBuilder.prototype.buildTermsAgg = function (aggDef, queryNode, target) {
        var metricRef, metric, y;
        queryNode.terms = { "field": aggDef.field };
        if (!aggDef.settings) {
            return queryNode;
        }
        queryNode.terms.size = parseInt(aggDef.settings.size, 10) === 0 ? 500 : parseInt(aggDef.settings.size, 10);
        if (aggDef.settings.orderBy !== void 0) {
            queryNode.terms.order = {};
            queryNode.terms.order[aggDef.settings.orderBy] = aggDef.settings.order;
            // if metric ref, look it up and add it to this agg level
            metricRef = parseInt(aggDef.settings.orderBy, 10);
            if (!isNaN(metricRef)) {
                for (y = 0; y < target.metrics.length; y++) {
                    metric = target.metrics[y];
                    if (metric.id === aggDef.settings.orderBy) {
                        queryNode.aggs = {};
                        queryNode.aggs[metric.id] = {};
                        queryNode.aggs[metric.id][metric.type] = { field: metric.field };
                        break;
                    }
                }
            }
        }
        if (aggDef.settings.min_doc_count !== void 0) {
            queryNode.terms.min_doc_count = parseInt(aggDef.settings.min_doc_count, 10);
        }
        if (aggDef.settings.missing) {
            queryNode.terms.missing = aggDef.settings.missing;
        }
        return queryNode;
    };
    ElasticQueryBuilder.prototype.getDateHistogramAgg = function (aggDef) {
        var esAgg = {};
        var settings = aggDef.settings || {};
        esAgg.interval = settings.interval;
        esAgg.field = this.timeField;
        esAgg.min_doc_count = settings.min_doc_count || 0;
        esAgg.extended_bounds = { min: "$timeFrom", max: "$timeTo" };
        esAgg.format = "epoch_millis";
        if (esAgg.interval === 'auto') {
            esAgg.interval = "$__interval";
        }
        if (settings.missing) {
            esAgg.missing = settings.missing;
        }
        return esAgg;
    };
    ElasticQueryBuilder.prototype.getHistogramAgg = function (aggDef) {
        var esAgg = {};
        var settings = aggDef.settings || {};
        esAgg.interval = settings.interval;
        esAgg.field = aggDef.field;
        esAgg.min_doc_count = settings.min_doc_count || 0;
        if (settings.missing) {
            esAgg.missing = settings.missing;
        }
        return esAgg;
    };
    ElasticQueryBuilder.prototype.getFiltersAgg = function (aggDef) {
        var filterObj = {};
        for (var i = 0; i < aggDef.settings.filters.length; i++) {
            var query = aggDef.settings.filters[i].query;
            var label = aggDef.settings.filters[i].label;
            label = label === '' || label === undefined ? query : label;
            filterObj[label] = {
                query_string: {
                    query: query,
                    analyze_wildcard: true
                }
            };
        }
        return filterObj;
    };
    ElasticQueryBuilder.prototype.documentQuery = function (query, size) {
        query.size = size;
        query.sort = {};
        query.sort[this.timeField] = { order: 'desc', unmapped_type: 'boolean' };
        // fields field not supported on ES 5.x
        if (this.esVersion < 5) {
            query.fields = ["*", "_source"];
        }
        query.script_fields = {};
        if (this.esVersion < 5) {
            query.fielddata_fields = [this.timeField];
        }
        else {
            query.docvalue_fields = [this.timeField];
        }
        return query;
    };
    ElasticQueryBuilder.prototype.addAdhocFilters = function (query, adhocFilters) {
        if (!adhocFilters) {
            return;
        }
        var i, filter, condition, queryCondition;
        for (i = 0; i < adhocFilters.length; i++) {
            filter = adhocFilters[i];
            condition = {};
            condition[filter.key] = filter.value;
            queryCondition = {};
            queryCondition[filter.key] = { query: filter.value };
            switch (filter.operator) {
                case "=":
                    if (!query.query.bool.must) {
                        query.query.bool.must = [];
                    }
                    query.query.bool.must.push({ match_phrase: queryCondition });
                    break;
                case "!=":
                    if (!query.query.bool.must_not) {
                        query.query.bool.must_not = [];
                    }
                    query.query.bool.must_not.push({ match_phrase: queryCondition });
                    break;
                case "<":
                    condition[filter.key] = { "lt": filter.value };
                    query.query.bool.filter.push({ "range": condition });
                    break;
                case ">":
                    condition[filter.key] = { "gt": filter.value };
                    query.query.bool.filter.push({ "range": condition });
                    break;
                case "=~":
                    query.query.bool.filter.push({ "regexp": condition });
                    break;
                case "!~":
                    query.query.bool.filter.push({ "bool": { "must_not": { "regexp": condition } } });
                    break;
            }
        }
    };
    ElasticQueryBuilder.prototype.build = function (target, adhocFilters, queryString) {
        // make sure query has defaults;
        target.metrics = target.metrics || [{ type: 'count', id: '1' }];
        target.dsType = 'elasticsearch';
        target.bucketAggs = target.bucketAggs || [{ type: 'date_histogram', id: '2', settings: { interval: 'auto' } }];
        target.timeField = this.timeField;
        var i, nestedAggs, metric;
        var query = {
            "size": 0,
            "query": {
                "bool": {
                    "filter": [
                        { "range": this.getRangeFilter() },
                        {
                            "query_string": {
                                "analyze_wildcard": true,
                                "query": queryString,
                            }
                        }
                    ]
                }
            }
        };
        this.addAdhocFilters(query, adhocFilters);
        // handle document query
        if (target.bucketAggs.length === 0) {
            metric = target.metrics[0];
            if (!metric || metric.type !== 'raw_document') {
                throw { message: 'Invalid query' };
            }
            var size = (metric.settings && metric.settings.size) || 500;
            return this.documentQuery(query, size);
        }
        nestedAggs = query;
        for (i = 0; i < target.bucketAggs.length; i++) {
            var aggDef = target.bucketAggs[i];
            var esAgg = {};
            switch (aggDef.type) {
                case 'date_histogram': {
                    esAgg["date_histogram"] = this.getDateHistogramAgg(aggDef);
                    break;
                }
                case 'histogram': {
                    esAgg["histogram"] = this.getHistogramAgg(aggDef);
                    break;
                }
                case 'filters': {
                    esAgg["filters"] = { filters: this.getFiltersAgg(aggDef) };
                    break;
                }
                case 'terms': {
                    this.buildTermsAgg(aggDef, esAgg, target);
                    break;
                }
                case 'geohash_grid': {
                    esAgg['geohash_grid'] = { field: aggDef.field, precision: aggDef.settings.precision };
                    break;
                }
            }
            nestedAggs.aggs = nestedAggs.aggs || {};
            nestedAggs.aggs[aggDef.id] = esAgg;
            nestedAggs = esAgg;
        }
        nestedAggs.aggs = {};
        for (i = 0; i < target.metrics.length; i++) {
            metric = target.metrics[i];
            if (metric.type === 'count') {
                continue;
            }
            var aggField = {};
            var metricAgg = null;
            if (__WEBPACK_IMPORTED_MODULE_0__query_def__["isPipelineAgg"](metric.type)) {
                if (metric.pipelineAgg && /^\d*$/.test(metric.pipelineAgg)) {
                    metricAgg = { buckets_path: metric.pipelineAgg };
                }
                else {
                    continue;
                }
            }
            else {
                metricAgg = { field: metric.field };
            }
            for (var prop in metric.settings) {
                if (metric.settings.hasOwnProperty(prop) && metric.settings[prop] !== null) {
                    metricAgg[prop] = metric.settings[prop];
                }
            }
            aggField[metric.type] = metricAgg;
            nestedAggs.aggs[metric.id] = aggField;
        }
        return query;
    };
    ElasticQueryBuilder.prototype.getTermsQuery = function (queryDef) {
        var query = {
            "size": 0,
            "query": {
                "bool": {
                    "filter": [{ "range": this.getRangeFilter() }]
                }
            }
        };
        if (queryDef.query) {
            query.query.bool.filter.push({
                "query_string": {
                    "analyze_wildcard": true,
                    "query": queryDef.query,
                }
            });
        }
        var size = 500;
        if (queryDef.size) {
            size = queryDef.size;
        }
        query.aggs = {
            "1": {
                "terms": {
                    "field": queryDef.field,
                    "size": size,
                    "order": {
                        "_term": "asc"
                    }
                },
            }
        };
        return query;
    };
    return ElasticQueryBuilder;
}());



/***/ }),

/***/ 1447:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return IndexPattern; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_moment__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_moment___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_moment__);

var intervalMap = {
    "Hourly": { startOf: 'hour', amount: 'hours' },
    "Daily": { startOf: 'day', amount: 'days' },
    "Weekly": { startOf: 'isoWeek', amount: 'weeks' },
    "Monthly": { startOf: 'month', amount: 'months' },
    "Yearly": { startOf: 'year', amount: 'years' },
};
var IndexPattern = /** @class */ (function () {
    function IndexPattern(pattern, interval) {
        this.pattern = pattern;
        this.interval = interval;
    }
    IndexPattern.prototype.getIndexForToday = function () {
        if (this.interval) {
            return __WEBPACK_IMPORTED_MODULE_0_moment___default.a.utc().format(this.pattern);
        }
        else {
            return this.pattern;
        }
    };
    IndexPattern.prototype.getIndexList = function (from, to) {
        if (!this.interval) {
            return this.pattern;
        }
        var intervalInfo = intervalMap[this.interval];
        var start = __WEBPACK_IMPORTED_MODULE_0_moment___default()(from).utc().startOf(intervalInfo.startOf);
        var endEpoch = __WEBPACK_IMPORTED_MODULE_0_moment___default()(to).utc().startOf(intervalInfo.startOf).valueOf();
        var indexList = [];
        while (start.valueOf() <= endEpoch) {
            indexList.push(start.format(this.pattern));
            start.add(1, intervalInfo.amount);
        }
        return indexList;
    };
    return IndexPattern;
}());



/***/ }),

/***/ 1448:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ElasticResponse; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__query_def__ = __webpack_require__(1311);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_app_core_table_model__ = __webpack_require__(1310);
///<reference path="../../../headers/common.d.ts" />



var ElasticResponse = /** @class */ (function () {
    function ElasticResponse(targets, response) {
        this.targets = targets;
        this.response = response;
        this.targets = targets;
        this.response = response;
    }
    ElasticResponse.prototype.processMetrics = function (esAgg, target, seriesList, props) {
        var metric, y, i, newSeries, bucket, value;
        for (y = 0; y < target.metrics.length; y++) {
            metric = target.metrics[y];
            if (metric.hide) {
                continue;
            }
            switch (metric.type) {
                case 'count': {
                    newSeries = { datapoints: [], metric: 'count', props: props };
                    for (i = 0; i < esAgg.buckets.length; i++) {
                        bucket = esAgg.buckets[i];
                        value = bucket.doc_count;
                        newSeries.datapoints.push([value, bucket.key]);
                    }
                    seriesList.push(newSeries);
                    break;
                }
                case 'percentiles': {
                    if (esAgg.buckets.length === 0) {
                        break;
                    }
                    var firstBucket = esAgg.buckets[0];
                    var percentiles = firstBucket[metric.id].values;
                    for (var percentileName in percentiles) {
                        newSeries = { datapoints: [], metric: 'p' + percentileName, props: props, field: metric.field };
                        for (i = 0; i < esAgg.buckets.length; i++) {
                            bucket = esAgg.buckets[i];
                            var values = bucket[metric.id].values;
                            newSeries.datapoints.push([values[percentileName], bucket.key]);
                        }
                        seriesList.push(newSeries);
                    }
                    break;
                }
                case 'extended_stats': {
                    for (var statName in metric.meta) {
                        if (!metric.meta[statName]) {
                            continue;
                        }
                        newSeries = { datapoints: [], metric: statName, props: props, field: metric.field };
                        for (i = 0; i < esAgg.buckets.length; i++) {
                            bucket = esAgg.buckets[i];
                            var stats = bucket[metric.id];
                            // add stats that are in nested obj to top level obj
                            stats.std_deviation_bounds_upper = stats.std_deviation_bounds.upper;
                            stats.std_deviation_bounds_lower = stats.std_deviation_bounds.lower;
                            newSeries.datapoints.push([stats[statName], bucket.key]);
                        }
                        seriesList.push(newSeries);
                    }
                    break;
                }
                default: {
                    newSeries = { datapoints: [], metric: metric.type, field: metric.field, props: props };
                    for (i = 0; i < esAgg.buckets.length; i++) {
                        bucket = esAgg.buckets[i];
                        value = bucket[metric.id];
                        if (value !== undefined) {
                            if (value.normalized_value) {
                                newSeries.datapoints.push([value.normalized_value, bucket.key]);
                            }
                            else {
                                newSeries.datapoints.push([value.value, bucket.key]);
                            }
                        }
                    }
                    seriesList.push(newSeries);
                    break;
                }
            }
        }
    };
    ElasticResponse.prototype.processAggregationDocs = function (esAgg, aggDef, target, table, props) {
        // add columns
        if (table.columns.length === 0) {
            for (var _i = 0, _a = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.keys(props); _i < _a.length; _i++) {
                var propKey = _a[_i];
                table.addColumn({ text: propKey, filterable: true });
            }
            table.addColumn({ text: aggDef.field, filterable: true });
        }
        // helper func to add values to value array
        var addMetricValue = function (values, metricName, value) {
            table.addColumn({ text: metricName });
            values.push(value);
        };
        for (var _b = 0, _c = esAgg.buckets; _b < _c.length; _b++) {
            var bucket = _c[_b];
            var values = [];
            for (var _d = 0, _e = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.values(props); _d < _e.length; _d++) {
                var propValues = _e[_d];
                values.push(propValues);
            }
            // add bucket key (value)
            values.push(bucket.key);
            for (var _f = 0, _g = target.metrics; _f < _g.length; _f++) {
                var metric = _g[_f];
                switch (metric.type) {
                    case "count": {
                        addMetricValue(values, this.getMetricName(metric.type), bucket.doc_count);
                        break;
                    }
                    case 'extended_stats': {
                        for (var statName in metric.meta) {
                            if (!metric.meta[statName]) {
                                continue;
                            }
                            var stats = bucket[metric.id];
                            // add stats that are in nested obj to top level obj
                            stats.std_deviation_bounds_upper = stats.std_deviation_bounds.upper;
                            stats.std_deviation_bounds_lower = stats.std_deviation_bounds.lower;
                            addMetricValue(values, this.getMetricName(statName), stats[statName]);
                        }
                        break;
                    }
                    default: {
                        var metricName = this.getMetricName(metric.type);
                        var otherMetrics = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.filter(target.metrics, { type: metric.type });
                        // if more of the same metric type include field field name in property
                        if (otherMetrics.length > 1) {
                            metricName += ' ' + metric.field;
                        }
                        addMetricValue(values, metricName, bucket[metric.id].value);
                        break;
                    }
                }
            }
            table.rows.push(values);
        }
    };
    // This is quite complex
    // neeed to recurise down the nested buckets to build series
    ElasticResponse.prototype.processBuckets = function (aggs, target, seriesList, table, props, depth) {
        var bucket, aggDef, esAgg, aggId;
        var maxDepth = target.bucketAggs.length - 1;
        for (aggId in aggs) {
            aggDef = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.find(target.bucketAggs, { id: aggId });
            esAgg = aggs[aggId];
            if (!aggDef) {
                continue;
            }
            if (depth === maxDepth) {
                if (aggDef.type === 'date_histogram') {
                    this.processMetrics(esAgg, target, seriesList, props);
                }
                else {
                    this.processAggregationDocs(esAgg, aggDef, target, table, props);
                }
            }
            else {
                for (var nameIndex in esAgg.buckets) {
                    bucket = esAgg.buckets[nameIndex];
                    props = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.clone(props);
                    if (bucket.key !== void 0) {
                        props[aggDef.field] = bucket.key;
                    }
                    else {
                        props["filter"] = nameIndex;
                    }
                    if (bucket.key_as_string) {
                        props[aggDef.field] = bucket.key_as_string;
                    }
                    this.processBuckets(bucket, target, seriesList, table, props, depth + 1);
                }
            }
        }
    };
    ElasticResponse.prototype.getMetricName = function (metric) {
        var metricDef = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.find(__WEBPACK_IMPORTED_MODULE_1__query_def__["metricAggTypes"], { value: metric });
        if (!metricDef) {
            metricDef = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.find(__WEBPACK_IMPORTED_MODULE_1__query_def__["extendedStats"], { value: metric });
        }
        return metricDef ? metricDef.text : metric;
    };
    ElasticResponse.prototype.getSeriesName = function (series, target, metricTypeCount) {
        var metricName = this.getMetricName(series.metric);
        if (target.alias) {
            var regex = /\{\{([\s\S]+?)\}\}/g;
            return target.alias.replace(regex, function (match, g1, g2) {
                var group = g1 || g2;
                if (group.indexOf('term ') === 0) {
                    return series.props[group.substring(5)];
                }
                if (series.props[group] !== void 0) {
                    return series.props[group];
                }
                if (group === 'metric') {
                    return metricName;
                }
                if (group === 'field') {
                    return series.field;
                }
                return match;
            });
        }
        if (series.field && __WEBPACK_IMPORTED_MODULE_1__query_def__["isPipelineAgg"](series.metric)) {
            var appliedAgg = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.find(target.metrics, { id: series.field });
            if (appliedAgg) {
                metricName += ' ' + __WEBPACK_IMPORTED_MODULE_1__query_def__["describeMetric"](appliedAgg);
            }
            else {
                metricName = 'Unset';
            }
        }
        else if (series.field) {
            metricName += ' ' + series.field;
        }
        var propKeys = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.keys(series.props);
        if (propKeys.length === 0) {
            return metricName;
        }
        var name = '';
        for (var propName in series.props) {
            name += series.props[propName] + ' ';
        }
        if (metricTypeCount === 1) {
            return name.trim();
        }
        return name.trim() + ' ' + metricName;
    };
    ElasticResponse.prototype.nameSeries = function (seriesList, target) {
        var metricTypeCount = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.uniq(__WEBPACK_IMPORTED_MODULE_0_lodash___default.a.map(seriesList, 'metric')).length;
        for (var i = 0; i < seriesList.length; i++) {
            var series = seriesList[i];
            series.target = this.getSeriesName(series, target, metricTypeCount);
        }
    };
    ElasticResponse.prototype.processHits = function (hits, seriesList) {
        var series = { target: 'docs', type: 'docs', datapoints: [], total: hits.total, filterable: true };
        var propName, hit, doc, i;
        for (i = 0; i < hits.hits.length; i++) {
            hit = hits.hits[i];
            doc = {
                _id: hit._id,
                _type: hit._type,
                _index: hit._index
            };
            if (hit._source) {
                for (propName in hit._source) {
                    doc[propName] = hit._source[propName];
                }
            }
            for (propName in hit.fields) {
                doc[propName] = hit.fields[propName];
            }
            series.datapoints.push(doc);
        }
        seriesList.push(series);
    };
    ElasticResponse.prototype.trimDatapoints = function (aggregations, target) {
        var histogram = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.find(target.bucketAggs, { type: 'date_histogram' });
        var shouldDropFirstAndLast = histogram && histogram.settings && histogram.settings.trimEdges;
        if (shouldDropFirstAndLast) {
            var trim = histogram.settings.trimEdges;
            for (var prop in aggregations) {
                var points = aggregations[prop];
                if (points.datapoints.length > trim * 2) {
                    points.datapoints = points.datapoints.slice(trim, points.datapoints.length - trim);
                }
            }
        }
    };
    ElasticResponse.prototype.getErrorFromElasticResponse = function (response, err) {
        var result = {};
        result.data = JSON.stringify(err, null, 4);
        if (err.root_cause && err.root_cause.length > 0 && err.root_cause[0].reason) {
            result.message = err.root_cause[0].reason;
        }
        else {
            result.message = err.reason || 'Unkown elatic error response';
        }
        if (response.$$config) {
            result.config = response.$$config;
        }
        return result;
    };
    ElasticResponse.prototype.getTimeSeries = function () {
        var seriesList = [];
        for (var i = 0; i < this.response.responses.length; i++) {
            var response = this.response.responses[i];
            if (response.error) {
                throw this.getErrorFromElasticResponse(this.response, response.error);
            }
            if (response.hits && response.hits.hits.length > 0) {
                this.processHits(response.hits, seriesList);
            }
            if (response.aggregations) {
                var aggregations = response.aggregations;
                var target = this.targets[i];
                var tmpSeriesList = [];
                var table = new __WEBPACK_IMPORTED_MODULE_2_app_core_table_model__["default"]();
                this.processBuckets(aggregations, target, tmpSeriesList, table, {}, 0);
                this.trimDatapoints(tmpSeriesList, target);
                this.nameSeries(tmpSeriesList, target);
                for (var y = 0; y < tmpSeriesList.length; y++) {
                    seriesList.push(tmpSeriesList[y]);
                }
                if (table.rows.length > 0) {
                    seriesList.push(table);
                }
            }
        }
        return { data: seriesList };
    };
    return ElasticResponse;
}());



/***/ }),

/***/ 1449:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ElasticQueryCtrl; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__bucket_agg__ = __webpack_require__(1450);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__bucket_agg___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__bucket_agg__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__metric_agg__ = __webpack_require__(1451);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__metric_agg___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__metric_agg__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_angular__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_angular___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_angular__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_lodash__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__query_def__ = __webpack_require__(1311);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_app_plugins_sdk__ = __webpack_require__(1305);
///<reference path="../../../headers/common.d.ts" />
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();






var ElasticQueryCtrl = /** @class */ (function (_super) {
    __extends(ElasticQueryCtrl, _super);
    /** @ngInject **/
    ElasticQueryCtrl.$inject = ["$scope", "$injector", "$rootScope", "uiSegmentSrv"];
    function ElasticQueryCtrl($scope, $injector, $rootScope, uiSegmentSrv) {
        var _this = _super.call(this, $scope, $injector) || this;
        _this.$rootScope = $rootScope;
        _this.uiSegmentSrv = uiSegmentSrv;
        _this.esVersion = _this.datasource.esVersion;
        _this.queryUpdated();
        return _this;
    }
    ElasticQueryCtrl.prototype.getFields = function (type) {
        var jsonStr = __WEBPACK_IMPORTED_MODULE_2_angular___default.a.toJson({ find: 'fields', type: type });
        return this.datasource.metricFindQuery(jsonStr)
            .then(this.uiSegmentSrv.transformToSegments(false))
            .catch(this.handleQueryError.bind(this));
    };
    ElasticQueryCtrl.prototype.queryUpdated = function () {
        var newJson = __WEBPACK_IMPORTED_MODULE_2_angular___default.a.toJson(this.datasource.queryBuilder.build(this.target), true);
        if (this.rawQueryOld && newJson !== this.rawQueryOld) {
            this.refresh();
        }
        this.rawQueryOld = newJson;
        this.$rootScope.appEvent('elastic-query-updated');
    };
    ElasticQueryCtrl.prototype.getCollapsedText = function () {
        var metricAggs = this.target.metrics;
        var bucketAggs = this.target.bucketAggs;
        var metricAggTypes = __WEBPACK_IMPORTED_MODULE_4__query_def__["getMetricAggTypes"](this.esVersion);
        var bucketAggTypes = __WEBPACK_IMPORTED_MODULE_4__query_def__["bucketAggTypes"];
        var text = '';
        if (this.target.query) {
            text += 'Query: ' + this.target.query + ', ';
        }
        text += 'Metrics: ';
        __WEBPACK_IMPORTED_MODULE_3_lodash___default.a.each(metricAggs, function (metric, index) {
            var aggDef = __WEBPACK_IMPORTED_MODULE_3_lodash___default.a.find(metricAggTypes, { value: metric.type });
            text += aggDef.text + '(';
            if (aggDef.requiresField) {
                text += metric.field;
            }
            text += '), ';
        });
        __WEBPACK_IMPORTED_MODULE_3_lodash___default.a.each(bucketAggs, function (bucketAgg, index) {
            if (index === 0) {
                text += ' Group by: ';
            }
            var aggDef = __WEBPACK_IMPORTED_MODULE_3_lodash___default.a.find(bucketAggTypes, { value: bucketAgg.type });
            text += aggDef.text + '(';
            if (aggDef.requiresField) {
                text += bucketAgg.field;
            }
            text += '), ';
        });
        if (this.target.alias) {
            text += 'Alias: ' + this.target.alias;
        }
        return text;
    };
    ElasticQueryCtrl.prototype.handleQueryError = function (err) {
        this.error = err.message || 'Failed to issue metric query';
        return [];
    };
    ElasticQueryCtrl.templateUrl = 'partials/query.editor.html';
    return ElasticQueryCtrl;
}(__WEBPACK_IMPORTED_MODULE_5_app_plugins_sdk__["QueryCtrl"]));



/***/ }),

/***/ 1450:
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
  __webpack_require__(12),
  __webpack_require__(7),
  __webpack_require__(1311),
], __WEBPACK_AMD_DEFINE_RESULT__ = function (angular, _, queryDef) {
  'use strict';

  var module = angular.module('grafana.directives');

  module.directive('elasticBucketAgg', function() {
    return {
      templateUrl: 'public/app/plugins/datasource/elasticsearch/partials/bucket_agg.html',
      controller: 'ElasticBucketAggCtrl',
      restrict: 'E',
      scope: {
        target: "=",
        index: "=",
        onChange: "&",
        getFields: "&",
      }
    };
  });

  module.controller('ElasticBucketAggCtrl', ["$scope", "uiSegmentSrv", "$q", "$rootScope", function($scope, uiSegmentSrv, $q, $rootScope) {
    var bucketAggs = $scope.target.bucketAggs;

    $scope.orderByOptions = [];

    $scope.getBucketAggTypes = function() {
      return queryDef.bucketAggTypes;
    };

    $scope.getOrderOptions = function() {
      return queryDef.orderOptions;
    };

    $scope.getSizeOptions = function() {
      return queryDef.sizeOptions;
    };

    $rootScope.onAppEvent('elastic-query-updated', function() {
      $scope.validateModel();
    }, $scope);

    $scope.init = function() {
      $scope.agg = bucketAggs[$scope.index];
      $scope.validateModel();
    };

    $scope.onChangeInternal = function() {
      $scope.onChange();
    };

    $scope.onTypeChanged = function() {
      $scope.agg.settings = {};
      $scope.showOptions = false;

      switch($scope.agg.type) {
        case 'date_histogram':
        case 'histogram':
        case 'terms':  {
          delete $scope.agg.query;
          $scope.agg.field = 'select field';
          break;
        }
        case 'filters': {
          delete $scope.agg.field;
          $scope.agg.query = '*';
          break;
        }
        case 'geohash_grid': {
          $scope.agg.settings.precision = 3;
          break;
        }
      }

      $scope.validateModel();
      $scope.onChange();
    };

    $scope.validateModel = function() {
      $scope.index = _.indexOf(bucketAggs, $scope.agg);
      $scope.isFirst = $scope.index === 0;
      $scope.bucketAggCount = bucketAggs.length;

      var settingsLinkText = "";
      var settings = $scope.agg.settings || {};

      switch($scope.agg.type) {
        case 'terms': {
          settings.order = settings.order || "desc";
          settings.size = settings.size || "10";
          settings.min_doc_count = settings.min_doc_count || 1;
          settings.orderBy = settings.orderBy || "_term";

          if (settings.size !== '0') {
            settingsLinkText = queryDef.describeOrder(settings.order) + ' ' + settings.size + ', ';
          }

          if (settings.min_doc_count > 0) {
            settingsLinkText += 'Min Doc Count: ' + settings.min_doc_count + ', ';
          }

          settingsLinkText += 'Order by: ' + queryDef.describeOrderBy(settings.orderBy, $scope.target);

          if (settings.size === '0') {
            settingsLinkText += ' (' + settings.order + ')';
          }

          break;
        }
        case 'filters': {
          settings.filters = settings.filters || [{query: '*'}];
          settingsLinkText = _.reduce(settings.filters, function(memo, value, index) {
            memo += 'Q' + (index + 1) + '  = ' + value.query + ' ';
            return memo;
          }, '');
          if (settingsLinkText.length > 50) {
            settingsLinkText = settingsLinkText.substr(0, 50) + "...";
          }
          settingsLinkText = 'Filter Queries (' + settings.filters.length + ')';
          break;
        }
        case 'date_histogram': {
          settings.interval = settings.interval || 'auto';
          settings.min_doc_count = settings.min_doc_count || 0;
          $scope.agg.field = $scope.target.timeField;
          settingsLinkText = 'Interval: ' + settings.interval;

          if (settings.min_doc_count > 0) {
            settingsLinkText += ', Min Doc Count: ' + settings.min_doc_count;
          }

          if (settings.trimEdges === undefined || settings.trimEdges < 0) {
            settings.trimEdges = 0;
          }

          if (settings.trimEdges && settings.trimEdges > 0) {
            settingsLinkText += ', Trim edges: ' + settings.trimEdges;
          }
          break;
        }
        case 'histogram': {
          settings.interval = settings.interval || 1000;
          settings.min_doc_count = _.defaultTo(settings.min_doc_count, 1);
          settingsLinkText = 'Interval: ' + settings.interval;

          if (settings.min_doc_count > 0) {
            settingsLinkText += ', Min Doc Count: ' + settings.min_doc_count;
          }
          break;
        }
        case 'geohash_grid': {
          // limit precision to 7
          settings.precision = Math.max(Math.min(settings.precision, 7), 1);
          settingsLinkText = 'Precision: ' + settings.precision;
          break;
        }
      }

      $scope.settingsLinkText = settingsLinkText;
      $scope.agg.settings = settings;
      return true;
    };

    $scope.addFiltersQuery = function() {
      $scope.agg.settings.filters.push({query: '*'});
    };

    $scope.removeFiltersQuery = function(filter) {
      $scope.agg.settings.filters = _.without($scope.agg.settings.filters, filter);
    };

    $scope.toggleOptions = function() {
      $scope.showOptions = !$scope.showOptions;
    };

    $scope.getOrderByOptions = function() {
      return queryDef.getOrderByOptions($scope.target);
    };

    $scope.getFieldsInternal = function() {
      if ($scope.agg.type === 'date_histogram') {
        return $scope.getFields({$fieldType: 'date'});
      } else {
        return $scope.getFields();
      }
    };

    $scope.getIntervalOptions = function() {
      return $q.when(uiSegmentSrv.transformToSegments(true, 'interval')(queryDef.intervalOptions));
    };

    $scope.addBucketAgg = function() {
      // if last is date histogram add it before
      var lastBucket = bucketAggs[bucketAggs.length - 1];
      var addIndex = bucketAggs.length - 1;

      if (lastBucket && lastBucket.type === 'date_histogram') {
        addIndex - 1;
      }

      var id = _.reduce($scope.target.bucketAggs.concat($scope.target.metrics), function(max, val) {
        return parseInt(val.id) > max ? parseInt(val.id) : max;
      }, 0);

      bucketAggs.splice(addIndex, 0, {type: "terms", field: "select field", id: (id+1).toString(), fake: true});
      $scope.onChange();
    };

    $scope.removeBucketAgg = function() {
      bucketAggs.splice($scope.index, 1);
      $scope.onChange();
    };

    $scope.init();

  }]);

}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(201)(module)))

/***/ }),

/***/ 1451:
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
  __webpack_require__(12),
  __webpack_require__(7),
  __webpack_require__(1311)
], __WEBPACK_AMD_DEFINE_RESULT__ = function (angular, _, queryDef) {
  'use strict';

  var module = angular.module('grafana.directives');

  module.directive('elasticMetricAgg', function() {
    return {
      templateUrl: 'public/app/plugins/datasource/elasticsearch/partials/metric_agg.html',
      controller: 'ElasticMetricAggCtrl',
      restrict: 'E',
      scope: {
        target: "=",
        index: "=",
        onChange: "&",
        getFields: "&",
        esVersion: '='
      }
    };
  });

  module.controller('ElasticMetricAggCtrl', ["$scope", "uiSegmentSrv", "$q", "$rootScope", function($scope, uiSegmentSrv, $q, $rootScope) {
    var metricAggs = $scope.target.metrics;

    $scope.metricAggTypes = queryDef.getMetricAggTypes($scope.esVersion);
    $scope.extendedStats = queryDef.extendedStats;
    $scope.pipelineAggOptions = [];
    $scope.modelSettingsValues = {};

    $scope.init = function() {
      $scope.agg = metricAggs[$scope.index];
      $scope.validateModel();
      $scope.updatePipelineAggOptions();
    };

    $scope.updatePipelineAggOptions = function() {
      $scope.pipelineAggOptions = queryDef.getPipelineAggOptions($scope.target);
    };

    $rootScope.onAppEvent('elastic-query-updated', function() {
      $scope.index = _.indexOf(metricAggs, $scope.agg);
      $scope.updatePipelineAggOptions();
      $scope.validateModel();
    }, $scope);

    $scope.validateModel = function() {
      $scope.isFirst = $scope.index === 0;
      $scope.isSingle = metricAggs.length === 1;
      $scope.settingsLinkText = '';
      $scope.aggDef = _.find($scope.metricAggTypes, {value: $scope.agg.type});

      if (queryDef.isPipelineAgg($scope.agg.type)) {
        $scope.agg.pipelineAgg = $scope.agg.pipelineAgg || 'select metric';
        $scope.agg.field = $scope.agg.pipelineAgg;

        var pipelineOptions = queryDef.getPipelineOptions($scope.agg);
        if (pipelineOptions.length > 0) {
          _.each(pipelineOptions, function(opt) {
            $scope.agg.settings[opt.text] = $scope.agg.settings[opt.text] || opt.default;
          });
          $scope.settingsLinkText = 'Options';
        }
      } else if (!$scope.agg.field) {
        $scope.agg.field = 'select field';
      }
      switch($scope.agg.type) {
        case 'cardinality': {
          var precision_threshold = $scope.agg.settings.precision_threshold || '';
          $scope.settingsLinkText = 'Precision threshold: ' + precision_threshold;
          break;
        }
        case 'percentiles': {
          $scope.agg.settings.percents = $scope.agg.settings.percents || [25,50,75,95,99];
          $scope.settingsLinkText = 'Values: ' + $scope.agg.settings.percents.join(',');
          break;
        }
        case 'extended_stats': {
          if (_.keys($scope.agg.meta).length === 0)  {
            $scope.agg.meta.std_deviation_bounds_lower = true;
            $scope.agg.meta.std_deviation_bounds_upper = true;
          }

          var stats = _.reduce($scope.agg.meta, function(memo, val, key) {
            if (val) {
              var def = _.find($scope.extendedStats, {value: key});
              memo.push(def.text);
            }
            return memo;
          }, []);

          $scope.settingsLinkText = 'Stats: ' + stats.join(', ');
          break;
        }
        case 'moving_avg': {
          $scope.movingAvgModelTypes = queryDef.movingAvgModelOptions;
          $scope.modelSettings = queryDef.getMovingAvgSettings($scope.agg.settings.model, true);
          $scope.updateMovingAvgModelSettings();
          break;
        }
        case 'raw_document': {
          $scope.agg.settings.size = $scope.agg.settings.size || 500;
          $scope.settingsLinkText = 'Size: ' + $scope.agg.settings.size ;
          $scope.target.metrics.splice(0,$scope.target.metrics.length, $scope.agg);

          $scope.target.bucketAggs = [];
          break;
        }
      }
      if ($scope.aggDef.supportsInlineScript) {
        // I know this stores the inline script twice
        // but having it like this simplifes the query_builder
        var inlineScript = $scope.agg.inlineScript;
        if (inlineScript) {
          $scope.agg.settings.script = {inline: inlineScript};
        } else {
          delete $scope.agg.settings.script;
        }

        if ($scope.settingsLinkText === '') {
          $scope.settingsLinkText = 'Options';
        }
      }
    };

    $scope.toggleOptions = function() {
      $scope.showOptions = !$scope.showOptions;
      $scope.updatePipelineAggOptions();
    };

    $scope.onChangeInternal = function() {
      $scope.onChange();
    };

    $scope.updateMovingAvgModelSettings = function () {
      var modelSettingsKeys = [];
      var modelSettings = queryDef.getMovingAvgSettings($scope.agg.settings.model, false);
      for (var i=0; i < modelSettings.length; i++) {
        modelSettingsKeys.push(modelSettings[i].value);
      }

      for (var key in $scope.agg.settings.settings) {
        if (($scope.agg.settings.settings[key] === null) || (modelSettingsKeys.indexOf(key) === -1)) {
          delete $scope.agg.settings.settings[key];
        }
      }
    };

    $scope.onChangeClearInternal = function() {
      delete $scope.agg.settings.minimize;
      $scope.onChange();
    };

    $scope.onTypeChange = function() {
      $scope.agg.settings = {};
      $scope.agg.meta = {};
      $scope.showOptions = false;
      $scope.updatePipelineAggOptions();
      $scope.onChange();
    };

    $scope.getFieldsInternal = function() {
      if ($scope.agg.type === 'cardinality') {
        return $scope.getFields();
      }
      return $scope.getFields({$fieldType: 'number'});
    };

    $scope.addMetricAgg = function() {
      var addIndex = metricAggs.length;

      var id = _.reduce($scope.target.bucketAggs.concat($scope.target.metrics), function(max, val) {
        return parseInt(val.id) > max ? parseInt(val.id) : max;
      }, 0);

      metricAggs.splice(addIndex, 0, {type: "count", field: "select field", id: (id+1).toString()});
      $scope.onChange();
    };

    $scope.removeMetricAgg = function() {
      metricAggs.splice($scope.index, 1);
      $scope.onChange();
    };

    $scope.toggleShowMetric = function() {
      $scope.agg.hide = !$scope.agg.hide;
      if (!$scope.agg.hide) {
        delete $scope.agg.hide;
      }
      $scope.onChange();
    };

    $scope.init();

  }]);

}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(201)(module)))

/***/ }),

/***/ 1452:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ElasticConfigCtrl; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_lodash__);

var ElasticConfigCtrl = /** @class */ (function () {
    /** @ngInject */
    ElasticConfigCtrl.$inject = ["$scope"];
    function ElasticConfigCtrl($scope) {
        this.indexPatternTypes = [
            { name: 'No pattern', value: undefined },
            { name: 'Hourly', value: 'Hourly', example: '[logstash-]YYYY.MM.DD.HH' },
            { name: 'Daily', value: 'Daily', example: '[logstash-]YYYY.MM.DD' },
            { name: 'Weekly', value: 'Weekly', example: '[logstash-]GGGG.WW' },
            { name: 'Monthly', value: 'Monthly', example: '[logstash-]YYYY.MM' },
            { name: 'Yearly', value: 'Yearly', example: '[logstash-]YYYY' },
        ];
        this.esVersions = [
            { name: '2.x', value: 2 },
            { name: '5.x', value: 5 },
        ];
        this.current.jsonData.timeField = this.current.jsonData.timeField || '@timestamp';
        this.current.jsonData.esVersion = this.current.jsonData.esVersion || 5;
    }
    ElasticConfigCtrl.prototype.indexPatternTypeChanged = function () {
        var def = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.find(this.indexPatternTypes, { value: this.current.jsonData.interval });
        this.current.database = def.example || 'es-index-name';
    };
    ElasticConfigCtrl.templateUrl = 'public/app/plugins/datasource/elasticsearch/partials/config.html';
    return ElasticConfigCtrl;
}());



/***/ }),

/***/ 1453:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AnnotationsQueryCtrl", function() { return AnnotationsQueryCtrl; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__datasource__ = __webpack_require__(1454);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__datasource___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__datasource__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__query_ctrl__ = __webpack_require__(1455);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__config_ctrl__ = __webpack_require__(1456);
/* harmony reexport (default from non-hamory) */ __webpack_require__.d(__webpack_exports__, "Datasource", function() { return __WEBPACK_IMPORTED_MODULE_0__datasource___default.a; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "QueryCtrl", function() { return __WEBPACK_IMPORTED_MODULE_1__query_ctrl__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "ConfigCtrl", function() { return __WEBPACK_IMPORTED_MODULE_2__config_ctrl__["a"]; });



var AnnotationsQueryCtrl = /** @class */ (function () {
    function AnnotationsQueryCtrl() {
    }
    AnnotationsQueryCtrl.templateUrl = 'partials/annotations.editor.html';
    return AnnotationsQueryCtrl;
}());



/***/ }),

/***/ 1454:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
  __webpack_require__(12),
  __webpack_require__(7),
  __webpack_require__(467),
  __webpack_require__(1),
], __WEBPACK_AMD_DEFINE_RESULT__ = function (angular, _, dateMath) {
  'use strict';

  /** @ngInject */
  OpenTsDatasource.$inject = ["instanceSettings", "$q", "backendSrv", "templateSrv"];
  function OpenTsDatasource(instanceSettings, $q, backendSrv, templateSrv) {
    this.type = 'opentsdb';
    this.url = instanceSettings.url;
    this.name = instanceSettings.name;
    this.withCredentials = instanceSettings.withCredentials;
    this.basicAuth = instanceSettings.basicAuth;
    instanceSettings.jsonData = instanceSettings.jsonData || {};
    this.tsdbVersion = instanceSettings.jsonData.tsdbVersion || 1;
    this.tsdbResolution = instanceSettings.jsonData.tsdbResolution || 1;
    this.supportMetrics = true;
    this.tagKeys = {};

    //console.info(res);
    this.cnMap={
      'env':'',
      'env.air':'',
      'env.water':'',
      'env.gas':'',
      'public':'',
      'private':'',
      'env.device':'',
      'etc':'',
      'evn':'evn',
      'swm':'swm',
      'swm.flowmeter':'',
      'swm.pressuremeter':'',
      'swm.watermeter':'',
      'site':'',
      'city':'',
      'DT':'',
      'PRESSURE':'',
      'FLOW':'',
      'TOTAL_FLOW_L':'',
      'TOTAL_FLOW_S':'',
      'TEMPERATURE':'',
      'HUMIDITY':''
    };
    this.air=['AQI','PM25','PM10','O3','SO2','NO2','CO','TEMPERATURE','HUMIDITY'];
    this.water=['PH','DO','COD','FTV','CT','TEM','TOTAL_P','NH3_N'];
    this.gas=['CL2','ETO','HCL','NH3','C6H6','H2S','C7H8','TEMPERATURE','HUMIDITY'];

    // Called once per panel (graph)
    this.query = function(options) {
      var start = convertToTSDBTime(options.rangeRaw.from, false);
      var end = convertToTSDBTime(options.rangeRaw.to, true);
      var qs = [];

      _.each(options.targets, function(target) {
        if (!target.metric) { return; }
        qs.push(convertTargetToQuery(target, options, this.tsdbVersion));
      }.bind(this));

      var queries = _.compact(qs);

      // No valid targets, return the empty result to save a round trip.
      if (_.isEmpty(queries)) {
        var d = $q.defer();
        d.resolve({ data: [] });
        return d.promise;
      }

      var groupByTags = {};
      _.each(queries, function(query) {
        if (query.filters && query.filters.length > 0) {
          _.each(query.filters, function(val) {
            groupByTags[val.tagk] = true;
          });
        } else {
          _.each(query.tags, function(val, key) {
            groupByTags[key] = true;
          });
        }
      });

      options.targets = _.filter(options.targets, function(query) {
        return query.hide !== true;
      });

      return this.performTimeSeriesQuery(queries, start, end).then(function(response) {
        var metricToTargetMapping = mapMetricsToTargets(response.data, options, this.tsdbVersion);
        var result = _.map(response.data, function(metricData, index) {
          index = metricToTargetMapping[index];
          if (index === -1) {
            index = 0;
          }
          this._saveTagKeys(metricData);

          return transformMetricData(metricData, groupByTags, options.targets[index], options, this.tsdbResolution);
        }.bind(this));
        return { data: result };
      }.bind(this));
    };

    this.annotationQuery = function(options) {
      var start = convertToTSDBTime(options.rangeRaw.from, false);
      var end = convertToTSDBTime(options.rangeRaw.to, true);
      var qs = [];
      var eventList = [];

      qs.push({ aggregator:"sum", metric:options.annotation.target });

      var queries = _.compact(qs);

      return this.performTimeSeriesQuery(queries, start, end).then(function(results) {
        if(results.data[0]) {
          var annotationObject = results.data[0].annotations;
          if(options.annotation.isGlobal){
            annotationObject = results.data[0].globalAnnotations;
          }
          if(annotationObject) {
            _.each(annotationObject, function(annotation) {
              var event = {
                text: annotation.description,
                time: Math.floor(annotation.startTime) * 1000,
                annotation: options.annotation
              };

              eventList.push(event);
            });
          }
        }
        return eventList;

      }.bind(this));
    };

    this.targetContainsTemplate = function(target) {
      if (target.filters && target.filters.length > 0) {
        for (var i = 0; i < target.filters.length; i++) {
          if (templateSrv.variableExists(target.filters[i].filter)) {
            return true;
          }
        }
      }

      if (target.tags && Object.keys(target.tags).length > 0) {
        for (var tagKey in target.tags) {
          if (templateSrv.variableExists(target.tags[tagKey])) {
            return true;
          }
        }
      }

      return false;
    };

    this.performTimeSeriesQuery = function(queries, start, end) {
      var msResolution = false;
      if (this.tsdbResolution === 2) {
        msResolution = true;
      }
      var reqBody = {
        start: start,
        queries: queries,
        msResolution: msResolution,
        globalAnnotations: true
      };
      if (this.tsdbVersion === 3) {
        reqBody.showQuery = true;
      }

      // Relative queries (e.g. last hour) don't include an end time
      if (end) {
        reqBody.end = end;
      }

      var options = {
        method: 'POST',
        url: this.url + '/api/query',
        data: reqBody
      };

      this._addCredentialOptions(options);
      return backendSrv.datasourceRequest(options);
    };

    this.suggestTagKeys = function(metric) {
      return $q.when(this.tagKeys[metric] || []);
    };

    this._saveTagKeys = function(metricData) {
      var tagKeys = Object.keys(metricData.tags);
      _.each(metricData.aggregateTags, function(tag) {
        tagKeys.push(tag);
      });

      this.tagKeys[metricData.metric] = tagKeys;
    };

    this._performSuggestQuery = function(query, type) {
      return this._get('/api/suggest', {type: type, q: query, max: 1000}).then(function(result) {
        return result.data;
      });
    };

    this._performMetricKeyValueLookup = function(metric, keys) {

      if(!metric || !keys) {
        return $q.when([]);
      }

      var keysArray = keys.split(",").map(function(key) {
        return key.trim();
      });
      var key = keysArray[0];
      var keysQuery = key + "=*";

      if (keysArray.length > 1) {
        keysQuery += "," + keysArray.splice(1).join(",");
      }

      var m = metric + "{" + keysQuery + "}";

      return this._get('/api/search/lookup', {m: m, limit: 3000}).then(function(result) {
        result = result.data.results;
        var tagvs = [];
        _.each(result, function(r) {
          if (tagvs.indexOf(r.tags[key]) === -1) {
            tagvs.push(r.tags[key]);
          }
        });
        return tagvs;
      });
    };

    this._performMetricKeyLookup = function(metric) {
      if(!metric) { return $q.when([]); }

      return this._get('/api/search/lookup', {m: metric, limit: 1000}).then(function(result) {
        result = result.data.results;
        var tagks = [];
        _.each(result, function(r) {
          _.each(r.tags, function(tagv, tagk) {
            if(tagks.indexOf(tagk) === -1) {
              tagks.push(tagk);
            }
          });
        });
        return tagks;
      });
    };

    this._get = function(relativeUrl, params) {
      var options = {
        method: 'GET',
        url: this.url + relativeUrl,
        params: params,
      };

      this._addCredentialOptions(options);

      return backendSrv.datasourceRequest(options);
    };

    this._addCredentialOptions = function(options) {
      if (this.basicAuth || this.withCredentials) {
        options.withCredentials = true;
      }
      if (this.basicAuth) {
        options.headers = {"Authorization": this.basicAuth};
      }
    };

    this.metricFindQuery = function(query,options) {
      if (!query) { return $q.when([]); }

      var interpolated;
      try {
        interpolated = templateSrv.replace(query, {}, 'distributed');
      }
      catch (err) {
        return $q.reject(err);
      }
      var ds=this;
      var responseTransform = function(result)
      {
        //
        if(tag_values_query)
        {
          var keysArray = tag_values_query[2].split(",").map(function(key) {
            return key.trim();
          });
          var key = keysArray[0];
          if(key==='index')
          {
            if(tag_values_query[1]==='env.air')
            {
              /*for(let i=0;i<result.length;i++)
              {
                let item=result[i];
                let index=ds.air.indexOf(item);

                result.splice(i,1);
                result.splice()
              }*/
              result=ds.air;

            }else if(tag_values_query[1]==='env.gas')
            {
              result=ds.gas;
            }else if(tag_values_query[1]==='env.water')
            {
              result=ds.water;
            }
          }
          if(key==='host')
          {
            if(options)
            {
              //console.info(options.variable.cnData);
              var hostMap={};
              _.map(options.variable.cnData,function (item) {
                hostMap[item.key]=item.name;
                return {item};
              });
              return _.map(result, function(value) {
                return {text: value,cn:hostMap[value]};
              });
            }

          }

        }

        return _.map(result, function(value) {
          return {text: value,cn:ds.cnMap[value]};
        });
      };

      var metrics_regex = /metrics\((.*)\)/;
      var tag_names_regex = /tag_names\((.*)\)/;
      var tag_values_regex = /tag_values\((.*?),\s?(.*)\)/;
      var tag_names_suggest_regex = /suggest_tagk\((.*)\)/;
      var tag_values_suggest_regex = /suggest_tagv\((.*)\)/;



      var metrics_query = interpolated.match(metrics_regex);
      //console.info(metrics_query);
      if (metrics_query) {
        return this._performSuggestQuery(metrics_query[1], 'metrics').then(responseTransform);
      }

      var tag_names_query = interpolated.match(tag_names_regex);
      if (tag_names_query) {
        return this._performMetricKeyLookup(tag_names_query[1]).then(responseTransform);
      }

      var tag_values_query = interpolated.match(tag_values_regex);
      //console.info(interpolated);
      //console.info(tag_values_query);
      if (tag_values_query) {
        return this._performMetricKeyValueLookup(tag_values_query[1], tag_values_query[2]).then(responseTransform);
      }

      var tag_names_suggest_query = interpolated.match(tag_names_suggest_regex);
      if (tag_names_suggest_query) {
        return this._performSuggestQuery(tag_names_suggest_query[1], 'tagk').then(responseTransform);
      }

      var tag_values_suggest_query = interpolated.match(tag_values_suggest_regex);
      if (tag_values_suggest_query) {
        return this._performSuggestQuery(tag_values_suggest_query[1], 'tagv').then(responseTransform);
      }

      return $q.when([]);
    };

    this.testDatasource = function() {
      return this._performSuggestQuery('cpu', 'metrics').then(function () {
        return { status: "success", message: "Data source is working" };
      });
    };

    var aggregatorsPromise = null;
    this.getAggregators = function() {
      if (aggregatorsPromise) { return aggregatorsPromise; }

      aggregatorsPromise = this._get('/api/aggregators').then(function(result) {
        if (result.data && _.isArray(result.data)) {
          return result.data.sort();
        }
        return [];
      });
      return aggregatorsPromise;
    };

    var filterTypesPromise = null;
    this.getFilterTypes = function() {
      if (filterTypesPromise) { return filterTypesPromise; }

      filterTypesPromise = this._get('/api/config/filters').then(function(result) {
        if (result.data) {
          return Object.keys(result.data).sort();
        }
        return [];
      });
      return filterTypesPromise;
    };

    function transformMetricData(md, groupByTags, target, options, tsdbResolution) {
      var metricLabel = createMetricLabel(md, target, groupByTags, options);
      var dps = [];

      // TSDB returns datapoints has a hash of ts => value.
      // Can't use _.pairs(invert()) because it stringifies keys/values
      _.each(md.dps, function (v, k) {
        if (tsdbResolution === 2) {
          dps.push([v, k * 1]);
        } else {
          dps.push([v, k * 1000]);
        }
      });

      return { target: metricLabel, datapoints: dps };
    }

    function createMetricLabel(md, target, groupByTags, options) {
      if (target.alias) {
        var scopedVars = _.clone(options.scopedVars || {});
        _.each(md.tags, function(value, key) {
          scopedVars['tag_' + key] = {value: value};
        });
        return templateSrv.replace(target.alias, scopedVars);
      }

      var label = md.metric;
      var tagData = [];

      if (!_.isEmpty(md.tags)) {
        _.each(_.toPairs(md.tags), function(tag) {
          if (_.has(groupByTags, tag[0])) {
            tagData.push(tag[0] + "=" + tag[1]);
          }
        });
      }

      if (!_.isEmpty(tagData)) {
        label += "{" + tagData.join(", ") + "}";
      }

      return label;
    }

    function convertTargetToQuery(target, options, tsdbVersion) {
      if (!target.metric || target.hide) {
        return null;
      }

      var query = {
        metric: templateSrv.replace(target.metric, options.scopedVars, 'pipe'),
        aggregator: "avg"
      };

      if (target.aggregator) {
        query.aggregator = templateSrv.replace(target.aggregator);
      }

      if (target.shouldComputeRate) {
        query.rate = true;
        query.rateOptions = {
          counter: !!target.isCounter
        };

        if (target.counterMax && target.counterMax.length) {
          query.rateOptions.counterMax = parseInt(target.counterMax);
        }

        if (target.counterResetValue && target.counterResetValue.length) {
          query.rateOptions.resetValue = parseInt(target.counterResetValue);
        }

        if(tsdbVersion >= 2) {
          query.rateOptions.dropResets = !query.rateOptions.counterMax &&
                (!query.rateOptions.ResetValue || query.rateOptions.ResetValue === 0);
        }
      }

      if (!target.disableDownsampling) {
        var interval =  templateSrv.replace(target.downsampleInterval || options.interval);

        if (interval.match(/\.[0-9]+s/)) {
          interval = parseFloat(interval)*1000 + "ms";
        }

        query.downsample = interval + "-" + target.downsampleAggregator;

        if (target.downsampleFillPolicy && target.downsampleFillPolicy !== "none") {
          query.downsample += "-" + target.downsampleFillPolicy;
        }
      }

      if (target.filters && target.filters.length > 0) {
        query.filters = angular.copy(target.filters);
        if (query.filters){
          for (var filter_key in query.filters) {
            query.filters[filter_key].filter = templateSrv.replace(query.filters[filter_key].filter, options.scopedVars, 'pipe');
          }
        }
      } else {
        query.tags = angular.copy(target.tags);
        if (query.tags){
          for (var tag_key in query.tags) {
            query.tags[tag_key] = templateSrv.replace(query.tags[tag_key], options.scopedVars, 'pipe');
          }
        }
      }

      if (target.explicitTags) {
        query.explicitTags = true;
      }

      return query;
    }

    function mapMetricsToTargets(metrics, options, tsdbVersion) {
      var interpolatedTagValue, arrTagV;
      return _.map(metrics, function(metricData) {
        if (tsdbVersion === 3) {
          return metricData.query.index;
        } else {
          return _.findIndex(options.targets, function(target) {
            if (target.filters && target.filters.length > 0) {
              return target.metric === metricData.metric;
            } else {
              return target.metric === metricData.metric &&
              _.every(target.tags, function(tagV, tagK) {
                interpolatedTagValue = templateSrv.replace(tagV, options.scopedVars, 'pipe');
                arrTagV = interpolatedTagValue.split('|');
                return _.includes(arrTagV, metricData.tags[tagK]) || interpolatedTagValue === "*";
              });
            }
          });
        }
      });
    }

    function convertToTSDBTime(date, roundUp) {
      if (date === 'now') {
        return null;
      }

      date = dateMath.parse(date, roundUp);
      return date.valueOf();
    }
  }

  return OpenTsDatasource;
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ 1455:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return OpenTsQueryCtrl; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_app_core_utils_kbn__ = __webpack_require__(464);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_app_plugins_sdk__ = __webpack_require__(1305);
///<reference path="../../../headers/common.d.ts" />
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();



var OpenTsQueryCtrl = /** @class */ (function (_super) {
    __extends(OpenTsQueryCtrl, _super);
    /** @ngInject **/
    OpenTsQueryCtrl.$inject = ["$scope", "$injector"];
    function OpenTsQueryCtrl($scope, $injector) {
        var _this = _super.call(this, $scope, $injector) || this;
        _this.errors = _this.validateTarget();
        _this.aggregators = ['avg', 'sum', 'min', 'max', 'dev', 'zimsum', 'mimmin', 'mimmax'];
        _this.fillPolicies = ['none', 'nan', 'null', 'zero'];
        _this.filterTypes = ['wildcard', 'iliteral_or', 'not_iliteral_or', 'not_literal_or', 'iwildcard', 'literal_or', 'regexp'];
        _this.tsdbVersion = _this.datasource.tsdbVersion;
        if (!_this.target.aggregator) {
            _this.target.aggregator = 'sum';
        }
        if (!_this.target.downsampleAggregator) {
            _this.target.downsampleAggregator = 'avg';
        }
        if (!_this.target.downsampleFillPolicy) {
            _this.target.downsampleFillPolicy = 'none';
        }
        _this.datasource.getAggregators().then(function (aggs) {
            if (aggs.length !== 0) {
                _this.aggregators = aggs;
            }
        });
        _this.datasource.getFilterTypes().then(function (filterTypes) {
            if (filterTypes.length !== 0) {
                _this.filterTypes = filterTypes;
            }
        });
        // needs to be defined here as it is called from typeahead
        _this.suggestMetrics = function (query, callback) {
            _this.datasource.metricFindQuery('metrics(' + query + ')')
                .then(_this.getTextValues)
                .then(callback);
        };
        _this.suggestTagKeys = function (query, callback) {
            _this.datasource.suggestTagKeys(_this.target.metric).then(callback);
        };
        _this.suggestTagValues = function (query, callback) {
            _this.datasource.metricFindQuery('suggest_tagv(' + query + ')')
                .then(_this.getTextValues)
                .then(callback);
        };
        return _this;
    }
    OpenTsQueryCtrl.prototype.targetBlur = function () {
        this.errors = this.validateTarget();
        this.refresh();
    };
    OpenTsQueryCtrl.prototype.getTextValues = function (metricFindResult) {
        return __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.map(metricFindResult, function (value) { return value.text; });
    };
    OpenTsQueryCtrl.prototype.addTag = function () {
        if (this.target.filters && this.target.filters.length > 0) {
            this.errors.tags = "Please remove filters to use tags, tags and filters are mutually exclusive.";
        }
        if (!this.addTagMode) {
            this.addTagMode = true;
            return;
        }
        if (!this.target.tags) {
            this.target.tags = {};
        }
        this.errors = this.validateTarget();
        if (!this.errors.tags) {
            this.target.tags[this.target.currentTagKey] = this.target.currentTagValue;
            this.target.currentTagKey = '';
            this.target.currentTagValue = '';
            this.targetBlur();
        }
        this.addTagMode = false;
    };
    OpenTsQueryCtrl.prototype.removeTag = function (key) {
        delete this.target.tags[key];
        this.targetBlur();
    };
    OpenTsQueryCtrl.prototype.editTag = function (key, value) {
        this.removeTag(key);
        this.target.currentTagKey = key;
        this.target.currentTagValue = value;
        this.addTag();
    };
    OpenTsQueryCtrl.prototype.closeAddTagMode = function () {
        this.addTagMode = false;
        return;
    };
    OpenTsQueryCtrl.prototype.addFilter = function () {
        if (this.target.tags && __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.size(this.target.tags) > 0) {
            this.errors.filters = "Please remove tags to use filters, tags and filters are mutually exclusive.";
        }
        if (!this.addFilterMode) {
            this.addFilterMode = true;
            return;
        }
        if (!this.target.filters) {
            this.target.filters = [];
        }
        if (!this.target.currentFilterType) {
            this.target.currentFilterType = 'iliteral_or';
        }
        if (!this.target.currentFilterGroupBy) {
            this.target.currentFilterGroupBy = false;
        }
        this.errors = this.validateTarget();
        if (!this.errors.filters) {
            var currentFilter = {
                type: this.target.currentFilterType,
                tagk: this.target.currentFilterKey,
                filter: this.target.currentFilterValue,
                groupBy: this.target.currentFilterGroupBy
            };
            this.target.filters.push(currentFilter);
            this.target.currentFilterType = 'literal_or';
            this.target.currentFilterKey = '';
            this.target.currentFilterValue = '';
            this.target.currentFilterGroupBy = false;
            this.targetBlur();
        }
        this.addFilterMode = false;
    };
    OpenTsQueryCtrl.prototype.removeFilter = function (index) {
        this.target.filters.splice(index, 1);
        this.targetBlur();
    };
    OpenTsQueryCtrl.prototype.editFilter = function (fil, index) {
        this.removeFilter(index);
        this.target.currentFilterKey = fil.tagk;
        this.target.currentFilterValue = fil.filter;
        this.target.currentFilterType = fil.type;
        this.target.currentFilterGroupBy = fil.groupBy;
        this.addFilter();
    };
    OpenTsQueryCtrl.prototype.closeAddFilterMode = function () {
        this.addFilterMode = false;
        return;
    };
    OpenTsQueryCtrl.prototype.validateTarget = function () {
        var errs = {};
        if (this.target.shouldDownsample) {
            try {
                if (this.target.downsampleInterval) {
                    __WEBPACK_IMPORTED_MODULE_1_app_core_utils_kbn__["default"].describe_interval(this.target.downsampleInterval);
                }
                else {
                    errs.downsampleInterval = "You must supply a downsample interval (e.g. '1m' or '1h').";
                }
            }
            catch (err) {
                errs.downsampleInterval = err.message;
            }
        }
        if (this.target.tags && __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.has(this.target.tags, this.target.currentTagKey)) {
            errs.tags = "Duplicate tag key '" + this.target.currentTagKey + "'.";
        }
        return errs;
    };
    OpenTsQueryCtrl.templateUrl = 'partials/query.editor.html';
    return OpenTsQueryCtrl;
}(__WEBPACK_IMPORTED_MODULE_2_app_plugins_sdk__["QueryCtrl"]));



/***/ }),

/***/ 1456:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return OpenTsConfigCtrl; });
///<reference path="../../../headers/common.d.ts" />
var OpenTsConfigCtrl = /** @class */ (function () {
    /** @ngInject */
    OpenTsConfigCtrl.$inject = ["$scope"];
    function OpenTsConfigCtrl($scope) {
        this.tsdbVersions = [
            { name: '<=2.1', value: 1 },
            { name: '==2.2', value: 2 },
            { name: '==2.3', value: 3 },
        ];
        this.tsdbResolutions = [
            { name: 'second', value: 1 },
            { name: 'millisecond', value: 2 },
        ];
        this.current.jsonData = this.current.jsonData || {};
        this.current.jsonData.tsdbVersion = this.current.jsonData.tsdbVersion || 1;
        this.current.jsonData.tsdbResolution = this.current.jsonData.tsdbResolution || 1;
    }
    OpenTsConfigCtrl.templateUrl = 'public/app/plugins/datasource/opentsdb/partials/config.html';
    return OpenTsConfigCtrl;
}());



/***/ }),

/***/ 1457:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "QueryCtrl", function() { return GrafanaQueryCtrl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AnnotationsQueryCtrl", function() { return GrafanaAnnotationsQueryCtrl; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__datasource__ = __webpack_require__(1458);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_app_plugins_sdk__ = __webpack_require__(1305);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "GrafanaDatasource", function() { return __WEBPACK_IMPORTED_MODULE_0__datasource__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "Datasource", function() { return __WEBPACK_IMPORTED_MODULE_0__datasource__["a"]; });
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();


var GrafanaQueryCtrl = /** @class */ (function (_super) {
    __extends(GrafanaQueryCtrl, _super);
    function GrafanaQueryCtrl() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    GrafanaQueryCtrl.templateUrl = 'partials/query.editor.html';
    return GrafanaQueryCtrl;
}(__WEBPACK_IMPORTED_MODULE_1_app_plugins_sdk__["QueryCtrl"]));
var GrafanaAnnotationsQueryCtrl = /** @class */ (function () {
    function GrafanaAnnotationsQueryCtrl() {
        this.types = [
            { text: 'Dashboard', value: 'dashboard' },
            { text: 'Tags', value: 'tags' }
        ];
        this.annotation.type = this.annotation.type || 'tags';
        this.annotation.limit = this.annotation.limit || 100;
    }
    GrafanaAnnotationsQueryCtrl.templateUrl = 'partials/annotations.editor.html';
    return GrafanaAnnotationsQueryCtrl;
}());



/***/ }),

/***/ 1458:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return GrafanaDatasource; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_lodash__);

var GrafanaDatasource = /** @class */ (function () {
    /** @ngInject */
    GrafanaDatasource.$inject = ["backendSrv", "$q"];
    function GrafanaDatasource(backendSrv, $q) {
        this.backendSrv = backendSrv;
        this.$q = $q;
    }
    GrafanaDatasource.prototype.query = function (options) {
        return this.backendSrv
            .get('/api/tsdb/testdata/random-walk', {
            from: options.range.from.valueOf(),
            to: options.range.to.valueOf(),
            intervalMs: options.intervalMs,
            maxDataPoints: options.maxDataPoints,
        })
            .then(function (res) {
            var data = [];
            if (res.results) {
                __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.forEach(res.results, function (queryRes) {
                    for (var _i = 0, _a = queryRes.series; _i < _a.length; _i++) {
                        var series = _a[_i];
                        data.push({
                            target: series.name,
                            datapoints: series.points,
                        });
                    }
                });
            }
            return { data: data };
        });
    };
    GrafanaDatasource.prototype.metricFindQuery = function (options) {
        return this.$q.when({ data: [] });
    };
    GrafanaDatasource.prototype.annotationQuery = function (options) {
        var params = {
            from: options.range.from.valueOf(),
            to: options.range.to.valueOf(),
            limit: options.annotation.limit,
            tags: options.annotation.tags,
        };
        if (options.annotation.type === 'dashboard') {
            // if no dashboard id yet return
            if (!options.dashboard.id) {
                return this.$q.when([]);
            }
            // filter by dashboard id
            params.dashboardId = options.dashboard.id;
            // remove tags filter if any
            delete params.tags;
        }
        else {
            // require at least one tag
            if (!__WEBPACK_IMPORTED_MODULE_0_lodash___default.a.isArray(options.annotation.tags) || options.annotation.tags.length === 0) {
                return this.$q.when([]);
            }
        }
        return this.backendSrv.get('/api/annotations', params);
    };
    return GrafanaDatasource;
}());



/***/ }),

/***/ 1459:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ConfigCtrl", function() { return InfluxConfigCtrl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AnnotationsQueryCtrl", function() { return InfluxAnnotationsQueryCtrl; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__datasource__ = __webpack_require__(1460);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__query_ctrl__ = __webpack_require__(1463);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "Datasource", function() { return __WEBPACK_IMPORTED_MODULE_0__datasource__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "QueryCtrl", function() { return __WEBPACK_IMPORTED_MODULE_1__query_ctrl__["a"]; });


var InfluxConfigCtrl = /** @class */ (function () {
    function InfluxConfigCtrl() {
    }
    InfluxConfigCtrl.templateUrl = 'partials/config.html';
    return InfluxConfigCtrl;
}());
var InfluxAnnotationsQueryCtrl = /** @class */ (function () {
    function InfluxAnnotationsQueryCtrl() {
    }
    InfluxAnnotationsQueryCtrl.templateUrl = 'partials/annotations.editor.html';
    return InfluxAnnotationsQueryCtrl;
}());



/***/ }),

/***/ 1460:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_app_core_utils_datemath__ = __webpack_require__(467);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__influx_series__ = __webpack_require__(1461);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__influx_series___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2__influx_series__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__influx_query__ = __webpack_require__(1331);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__response_parser__ = __webpack_require__(1462);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__query_builder__ = __webpack_require__(1333);






var InfluxDatasource = /** @class */ (function () {
    /** @ngInject */
    InfluxDatasource.$inject = ["instanceSettings", "$q", "backendSrv", "templateSrv"];
    function InfluxDatasource(instanceSettings, $q, backendSrv, templateSrv) {
        this.$q = $q;
        this.backendSrv = backendSrv;
        this.templateSrv = templateSrv;
        this.type = 'influxdb';
        this.urls = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.map(instanceSettings.url.split(','), function (url) {
            return url.trim();
        });
        this.username = instanceSettings.username;
        this.password = instanceSettings.password;
        this.name = instanceSettings.name;
        this.database = instanceSettings.database;
        this.basicAuth = instanceSettings.basicAuth;
        this.withCredentials = instanceSettings.withCredentials;
        this.interval = (instanceSettings.jsonData || {}).timeInterval;
        this.supportAnnotations = true;
        this.supportMetrics = true;
        this.responseParser = new __WEBPACK_IMPORTED_MODULE_4__response_parser__["a" /* default */]();
    }
    InfluxDatasource.prototype.query = function (options) {
        var _this = this;
        var timeFilter = this.getTimeFilter(options);
        var scopedVars = options.scopedVars;
        var targets = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.cloneDeep(options.targets);
        var queryTargets = [];
        var queryModel;
        var i, y;
        var allQueries = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.map(targets, function (target) {
            if (target.hide) {
                return "";
            }
            queryTargets.push(target);
            // backward compatability
            scopedVars.interval = scopedVars.__interval;
            queryModel = new __WEBPACK_IMPORTED_MODULE_3__influx_query__["a" /* default */](target, _this.templateSrv, scopedVars);
            return queryModel.render(true);
        }).reduce(function (acc, current) {
            if (current !== "") {
                acc += ";" + current;
            }
            return acc;
        });
        if (allQueries === '') {
            return this.$q.when({ data: [] });
        }
        // add global adhoc filters to timeFilter
        var adhocFilters = this.templateSrv.getAdhocFilters(this.name);
        if (adhocFilters.length > 0) {
            timeFilter += ' AND ' + queryModel.renderAdhocFilters(adhocFilters);
        }
        // replace grafana variables
        scopedVars.timeFilter = { value: timeFilter };
        // replace templated variables
        allQueries = this.templateSrv.replace(allQueries, scopedVars);
        return this._seriesQuery(allQueries).then(function (data) {
            if (!data || !data.results) {
                return [];
            }
            var seriesList = [];
            for (i = 0; i < data.results.length; i++) {
                var result = data.results[i];
                if (!result || !result.series) {
                    continue;
                }
                var target = queryTargets[i];
                var alias = target.alias;
                if (alias) {
                    alias = _this.templateSrv.replace(target.alias, options.scopedVars);
                }
                var influxSeries = new __WEBPACK_IMPORTED_MODULE_2__influx_series___default.a({ series: data.results[i].series, alias: alias });
                switch (target.resultFormat) {
                    case 'table': {
                        seriesList.push(influxSeries.getTable());
                        break;
                    }
                    default: {
                        var timeSeries = influxSeries.getTimeSeries();
                        for (y = 0; y < timeSeries.length; y++) {
                            seriesList.push(timeSeries[y]);
                        }
                        break;
                    }
                }
            }
            return { data: seriesList };
        });
    };
    InfluxDatasource.prototype.annotationQuery = function (options) {
        if (!options.annotation.query) {
            return this.$q.reject({ message: 'Query missing in annotation definition' });
        }
        var timeFilter = this.getTimeFilter({ rangeRaw: options.rangeRaw });
        var query = options.annotation.query.replace('$timeFilter', timeFilter);
        query = this.templateSrv.replace(query, null, 'regex');
        return this._seriesQuery(query).then(function (data) {
            if (!data || !data.results || !data.results[0]) {
                throw { message: 'No results in response from InfluxDB' };
            }
            return new __WEBPACK_IMPORTED_MODULE_2__influx_series___default.a({ series: data.results[0].series, annotation: options.annotation }).getAnnotations();
        });
    };
    InfluxDatasource.prototype.targetContainsTemplate = function (target) {
        for (var _i = 0, _a = target.groupBy; _i < _a.length; _i++) {
            var group = _a[_i];
            for (var _b = 0, _c = group.params; _b < _c.length; _b++) {
                var param = _c[_b];
                if (this.templateSrv.variableExists(param)) {
                    return true;
                }
            }
        }
        for (var i in target.tags) {
            if (this.templateSrv.variableExists(target.tags[i].value)) {
                return true;
            }
        }
        return false;
    };
    InfluxDatasource.prototype.metricFindQuery = function (query) {
        var interpolated = this.templateSrv.replace(query, null, 'regex');
        return this._seriesQuery(interpolated)
            .then(__WEBPACK_IMPORTED_MODULE_0_lodash___default.a.curry(this.responseParser.parse)(query));
    };
    InfluxDatasource.prototype.getTagKeys = function (options) {
        var queryBuilder = new __WEBPACK_IMPORTED_MODULE_5__query_builder__["a" /* InfluxQueryBuilder */]({ measurement: '', tags: [] }, this.database);
        var query = queryBuilder.buildExploreQuery('TAG_KEYS');
        return this.metricFindQuery(query);
    };
    InfluxDatasource.prototype.getTagValues = function (options) {
        var queryBuilder = new __WEBPACK_IMPORTED_MODULE_5__query_builder__["a" /* InfluxQueryBuilder */]({ measurement: '', tags: [] }, this.database);
        var query = queryBuilder.buildExploreQuery('TAG_VALUES', options.key);
        return this.metricFindQuery(query);
    };
    InfluxDatasource.prototype._seriesQuery = function (query) {
        if (!query) {
            return this.$q.when({ results: [] });
        }
        return this._influxRequest('GET', '/query', { q: query, epoch: 'ms' });
    };
    InfluxDatasource.prototype.serializeParams = function (params) {
        if (!params) {
            return '';
        }
        return __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.reduce(params, function (memo, value, key) {
            if (value === null || value === undefined) {
                return memo;
            }
            memo.push(encodeURIComponent(key) + '=' + encodeURIComponent(value));
            return memo;
        }, []).join("&");
    };
    InfluxDatasource.prototype.testDatasource = function () {
        var _this = this;
        return this.metricFindQuery('SHOW DATABASES').then(function (res) {
            var found = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.find(res, { text: _this.database });
            if (!found) {
                return { status: "error", message: "Could not find the specified database name." };
            }
            return { status: "success", message: "Data source is working" };
        }).catch(function (err) {
            return { status: "error", message: err.message };
        });
    };
    InfluxDatasource.prototype._influxRequest = function (method, url, data) {
        var self = this;
        var currentUrl = self.urls.shift();
        self.urls.push(currentUrl);
        var params = {};
        if (self.username) {
            params.u = self.username;
            params.p = self.password;
        }
        if (self.database) {
            params.db = self.database;
        }
        if (method === 'GET') {
            __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.extend(params, data);
            data = null;
        }
        var options = {
            method: method,
            url: currentUrl + url,
            params: params,
            data: data,
            precision: "ms",
            inspect: { type: 'influxdb' },
            paramSerializer: this.serializeParams,
        };
        options.headers = options.headers || {};
        if (this.basicAuth || this.withCredentials) {
            options.withCredentials = true;
        }
        if (self.basicAuth) {
            options.headers.Authorization = self.basicAuth;
        }
        return this.backendSrv.datasourceRequest(options).then(function (result) {
            return result.data;
        }, function (err) {
            if (err.status !== 0 || err.status >= 300) {
                if (err.data && err.data.error) {
                    throw { message: 'InfluxDB Error: ' + err.data.error, data: err.data, config: err.config };
                }
                else {
                    throw { message: 'Network Error: ' + err.statusText + '(' + err.status + ')', data: err.data, config: err.config };
                }
            }
        });
    };
    InfluxDatasource.prototype.getTimeFilter = function (options) {
        var from = this.getInfluxTime(options.rangeRaw.from, false);
        var until = this.getInfluxTime(options.rangeRaw.to, true);
        var fromIsAbsolute = from[from.length - 1] === 'ms';
        if (until === 'now()' && !fromIsAbsolute) {
            return 'time >= ' + from;
        }
        return 'time >= ' + from + ' and time <= ' + until;
    };
    InfluxDatasource.prototype.getInfluxTime = function (date, roundUp) {
        if (__WEBPACK_IMPORTED_MODULE_0_lodash___default.a.isString(date)) {
            if (date === 'now') {
                return 'now()';
            }
            var parts = /^now-(\d+)([d|h|m|s])$/.exec(date);
            if (parts) {
                var amount = parseInt(parts[1]);
                var unit = parts[2];
                return 'now() - ' + amount + unit;
            }
            date = __WEBPACK_IMPORTED_MODULE_1_app_core_utils_datemath__["parse"](date, roundUp);
        }
        return date.valueOf() + 'ms';
    };
    return InfluxDatasource;
}());
/* harmony default export */ __webpack_exports__["a"] = (InfluxDatasource);


/***/ }),

/***/ 1461:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
  __webpack_require__(7),
  __webpack_require__(1310),
], __WEBPACK_AMD_DEFINE_RESULT__ = function (_, TableModel) {
  'use strict';

  function InfluxSeries(options) {
    this.series = options.series;
    this.alias = options.alias;
    this.annotation = options.annotation;
  }

  var p = InfluxSeries.prototype;

  p.getTimeSeries = function() {
    var output = [];
    var self = this;
    var i, j;

    if (self.series.length === 0) {
      return output;
    }

    _.each(self.series, function(series) {
      var columns = series.columns.length;
      var tags = _.map(series.tags, function(value, key) {
        return key + ': ' + value;
      });

      for (j = 1; j < columns; j++) {
        var seriesName = series.name;
        var columnName = series.columns[j];
        if (columnName !== 'value') {
          seriesName = seriesName + '.' + columnName;
        }

        if (self.alias) {
          seriesName = self._getSeriesName(series, j);
        } else if (series.tags) {
          seriesName = seriesName + ' {' + tags.join(', ') + '}';
        }

        var datapoints = [];
        if (series.values) {
          for (i = 0; i < series.values.length; i++) {
            datapoints[i] = [series.values[i][j], series.values[i][0]];
          }
        }

        output.push({ target: seriesName, datapoints: datapoints});
      }
    });

    return output;
  };

  p._getSeriesName = function(series, index) {
    var regex = /\$(\w+)|\[\[([\s\S]+?)\]\]/g;
    var segments = series.name.split('.');

    return this.alias.replace(regex, function(match, g1, g2) {
      var group = g1 || g2;
      var segIndex = parseInt(group, 10);

      if (group === 'm' || group === 'measurement') { return series.name; }
      if (group === 'col') { return series.columns[index]; }
      if (!isNaN(segIndex)) { return segments[segIndex]; }
      if (group.indexOf('tag_') !== 0) { return match; }

      var tag = group.replace('tag_', '');
      if (!series.tags) { return match; }
      return series.tags[tag];
    });
  };

  p.getAnnotations = function () {
    var list = [];
    var self = this;

    _.each(this.series, function (series) {
      var titleCol = null;
      var timeCol = null;
      var tagsCol = [];
      var textCol = null;

      _.each(series.columns, function(column, index) {
        if (column === 'time') { timeCol = index; return; }
        if (column === 'sequence_number') { return; }
        if (!titleCol) { titleCol = index; }
        if (column === self.annotation.titleColumn) { titleCol = index; return; }
        if (_.includes((self.annotation.tagsColumn || '').replace(' ', '').split(","), column)) { tagsCol.push(index); return; }
        if (column === self.annotation.textColumn) { textCol = index; return; }
      });

      _.each(series.values, function (value) {
        var data = {
          annotation: self.annotation,
          time: + new Date(value[timeCol]),
          title: value[titleCol],
          // Remove empty values, then split in different tags for comma separated values
          tags: _.flatten(tagsCol.filter(function (t) { return value[t]; }).map(function(t) { return value[t].split(","); })),
          text: value[textCol]
        };

        list.push(data);
      });
    });

    return list;
  };

  p.getTable = function() {
    var table = new TableModel.default();
    var self = this;
    var i, j;

    if (self.series.length === 0) {
      return table;
    }

    _.each(self.series, function(series, seriesIndex) {

      if (seriesIndex === 0) {
        table.columns.push({text: 'Time', type: 'time'});
        _.each(_.keys(series.tags), function(key) {
          table.columns.push({text: key});
        });
        for (j = 1; j < series.columns.length; j++) {
          table.columns.push({text: series.columns[j]});
        }
      }

      if (series.values) {
        for (i = 0; i < series.values.length; i++) {
          var values = series.values[i];
          var reordered = [values[0]];
          if (series.tags) {
            for (var key in series.tags) {
              if (series.tags.hasOwnProperty(key)) {
                reordered.push(series.tags[key]);
              }
            }
          }
          for (j = 1; j < values.length; j++) {
            reordered.push(values[j]);
          }
          table.rows.push(reordered);
        }
      }
    });

    return table;
  };

  return InfluxSeries;
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ 1462:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_lodash__);
///<reference path="../../../headers/common.d.ts" />

var ResponseParser = /** @class */ (function () {
    function ResponseParser() {
    }
    ResponseParser.prototype.parse = function (query, results) {
        if (!results || results.results.length === 0) {
            return [];
        }
        var influxResults = results.results[0];
        if (!influxResults.series) {
            return [];
        }
        var influxdb11format = query.toLowerCase().indexOf('show tag values') >= 0;
        var res = {};
        __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.each(influxResults.series, function (serie) {
            __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.each(serie.values, function (value) {
                if (__WEBPACK_IMPORTED_MODULE_0_lodash___default.a.isArray(value)) {
                    if (influxdb11format) {
                        addUnique(res, value[1] || value[0]);
                    }
                    else {
                        addUnique(res, value[0]);
                    }
                }
                else {
                    addUnique(res, value);
                }
            });
        });
        return __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.map(res, function (value) {
            return { text: value };
        });
    };
    return ResponseParser;
}());
/* harmony default export */ __webpack_exports__["a"] = (ResponseParser);
function addUnique(arr, value) {
    arr[value] = value;
}


/***/ }),

/***/ 1463:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return InfluxQueryCtrl; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_angular__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_angular___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_angular__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_lodash__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__query_builder__ = __webpack_require__(1333);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__influx_query__ = __webpack_require__(1331);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__query_part__ = __webpack_require__(1332);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_app_plugins_sdk__ = __webpack_require__(1305);
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();






var InfluxQueryCtrl = /** @class */ (function (_super) {
    __extends(InfluxQueryCtrl, _super);
    /** @ngInject **/
    InfluxQueryCtrl.$inject = ["$scope", "$injector", "templateSrv", "$q", "uiSegmentSrv"];
    function InfluxQueryCtrl($scope, $injector, templateSrv, $q, uiSegmentSrv) {
        var _this = _super.call(this, $scope, $injector) || this;
        _this.templateSrv = templateSrv;
        _this.$q = $q;
        _this.uiSegmentSrv = uiSegmentSrv;
        _this.target = _this.target;
        _this.queryModel = new __WEBPACK_IMPORTED_MODULE_3__influx_query__["a" /* default */](_this.target, templateSrv, _this.panel.scopedVars);
        _this.queryBuilder = new __WEBPACK_IMPORTED_MODULE_2__query_builder__["a" /* InfluxQueryBuilder */](_this.target, _this.datasource.database);
        _this.groupBySegment = _this.uiSegmentSrv.newPlusButton();
        _this.resultFormats = [
            { text: 'Time series', value: 'time_series' },
            { text: 'Table', value: 'table' },
        ];
        _this.policySegment = uiSegmentSrv.newSegment(_this.target.policy);
        if (!_this.target.measurement) {
            _this.measurementSegment = uiSegmentSrv.newSelectMeasurement();
        }
        else {
            _this.measurementSegment = uiSegmentSrv.newSegment(_this.target.measurement);
        }
        _this.tagSegments = [];
        for (var _i = 0, _a = _this.target.tags; _i < _a.length; _i++) {
            var tag = _a[_i];
            if (!tag.operator) {
                if (/^\/.*\/$/.test(tag.value)) {
                    tag.operator = "=~";
                }
                else {
                    tag.operator = '=';
                }
            }
            if (tag.condition) {
                _this.tagSegments.push(uiSegmentSrv.newCondition(tag.condition));
            }
            _this.tagSegments.push(uiSegmentSrv.newKey(tag.key));
            _this.tagSegments.push(uiSegmentSrv.newOperator(tag.operator));
            _this.tagSegments.push(uiSegmentSrv.newKeyValue(tag.value));
        }
        _this.fixTagSegments();
        _this.buildSelectMenu();
        _this.removeTagFilterSegment = uiSegmentSrv.newSegment({ fake: true, value: '-- remove tag filter --' });
        return _this;
    }
    InfluxQueryCtrl.prototype.removeOrderByTime = function () {
        this.target.orderByTime = 'ASC';
    };
    InfluxQueryCtrl.prototype.buildSelectMenu = function () {
        var categories = __WEBPACK_IMPORTED_MODULE_4__query_part__["a" /* default */].getCategories();
        this.selectMenu = __WEBPACK_IMPORTED_MODULE_1_lodash___default.a.reduce(categories, function (memo, cat, key) {
            var menu = {
                text: key,
                submenu: cat.map(function (item) {
                    return { text: item.type, value: item.type };
                }),
            };
            memo.push(menu);
            return memo;
        }, []);
    };
    InfluxQueryCtrl.prototype.getGroupByOptions = function () {
        var _this = this;
        var query = this.queryBuilder.buildExploreQuery('TAG_KEYS');
        return this.datasource.metricFindQuery(query).then(function (tags) {
            var options = [];
            if (!_this.queryModel.hasFill()) {
                options.push(_this.uiSegmentSrv.newSegment({ value: 'fill(null)' }));
            }
            if (!_this.target.limit) {
                options.push(_this.uiSegmentSrv.newSegment({ value: 'LIMIT' }));
            }
            if (!_this.target.slimit) {
                options.push(_this.uiSegmentSrv.newSegment({ value: 'SLIMIT' }));
            }
            if (_this.target.orderByTime === 'ASC') {
                options.push(_this.uiSegmentSrv.newSegment({ value: 'ORDER BY time DESC' }));
            }
            if (!_this.queryModel.hasGroupByTime()) {
                options.push(_this.uiSegmentSrv.newSegment({ value: 'time($interval)' }));
            }
            for (var _i = 0, tags_1 = tags; _i < tags_1.length; _i++) {
                var tag = tags_1[_i];
                options.push(_this.uiSegmentSrv.newSegment({ value: 'tag(' + tag.text + ')' }));
            }
            return options;
        }).catch(this.handleQueryError.bind(this));
    };
    InfluxQueryCtrl.prototype.groupByAction = function () {
        switch (this.groupBySegment.value) {
            case 'LIMIT': {
                this.target.limit = 10;
                break;
            }
            case 'SLIMIT': {
                this.target.slimit = 10;
                break;
            }
            case 'ORDER BY time DESC': {
                this.target.orderByTime = 'DESC';
                break;
            }
            default: {
                this.queryModel.addGroupBy(this.groupBySegment.value);
            }
        }
        var plusButton = this.uiSegmentSrv.newPlusButton();
        this.groupBySegment.value = plusButton.value;
        this.groupBySegment.html = plusButton.html;
        this.panelCtrl.refresh();
    };
    InfluxQueryCtrl.prototype.addSelectPart = function (selectParts, cat, subitem) {
        this.queryModel.addSelectPart(selectParts, subitem.value);
        this.panelCtrl.refresh();
    };
    InfluxQueryCtrl.prototype.handleSelectPartEvent = function (selectParts, part, evt) {
        switch (evt.name) {
            case "get-param-options": {
                var fieldsQuery = this.queryBuilder.buildExploreQuery('FIELDS');
                return this.datasource.metricFindQuery(fieldsQuery)
                    .then(this.transformToSegments(true))
                    .catch(this.handleQueryError.bind(this));
            }
            case "part-param-changed": {
                this.panelCtrl.refresh();
                break;
            }
            case "action": {
                this.queryModel.removeSelectPart(selectParts, part);
                this.panelCtrl.refresh();
                break;
            }
            case "get-part-actions": {
                return this.$q.when([{ text: 'Remove', value: 'remove-part' }]);
            }
        }
    };
    InfluxQueryCtrl.prototype.handleGroupByPartEvent = function (part, index, evt) {
        switch (evt.name) {
            case "get-param-options": {
                var tagsQuery = this.queryBuilder.buildExploreQuery('TAG_KEYS');
                return this.datasource.metricFindQuery(tagsQuery)
                    .then(this.transformToSegments(true))
                    .catch(this.handleQueryError.bind(this));
            }
            case "part-param-changed": {
                this.panelCtrl.refresh();
                break;
            }
            case "action": {
                this.queryModel.removeGroupByPart(part, index);
                this.panelCtrl.refresh();
                break;
            }
            case "get-part-actions": {
                return this.$q.when([{ text: 'Remove', value: 'remove-part' }]);
            }
        }
    };
    InfluxQueryCtrl.prototype.fixTagSegments = function () {
        var count = this.tagSegments.length;
        var lastSegment = this.tagSegments[Math.max(count - 1, 0)];
        if (!lastSegment || lastSegment.type !== 'plus-button') {
            this.tagSegments.push(this.uiSegmentSrv.newPlusButton());
        }
    };
    InfluxQueryCtrl.prototype.measurementChanged = function () {
        this.target.measurement = this.measurementSegment.value;
        this.panelCtrl.refresh();
    };
    InfluxQueryCtrl.prototype.getPolicySegments = function () {
        var policiesQuery = this.queryBuilder.buildExploreQuery('RETENTION POLICIES');
        return this.datasource.metricFindQuery(policiesQuery)
            .then(this.transformToSegments(false))
            .catch(this.handleQueryError.bind(this));
    };
    InfluxQueryCtrl.prototype.policyChanged = function () {
        this.target.policy = this.policySegment.value;
        this.panelCtrl.refresh();
    };
    InfluxQueryCtrl.prototype.toggleEditorMode = function () {
        try {
            this.target.query = this.queryModel.render(false);
        }
        catch (err) {
            console.log('query render error');
        }
        this.target.rawQuery = !this.target.rawQuery;
    };
    InfluxQueryCtrl.prototype.getMeasurements = function (measurementFilter) {
        var query = this.queryBuilder.buildExploreQuery('MEASUREMENTS', undefined, measurementFilter);
        return this.datasource.metricFindQuery(query)
            .then(this.transformToSegments(true))
            .catch(this.handleQueryError.bind(this));
    };
    InfluxQueryCtrl.prototype.handleQueryError = function (err) {
        this.error = err.message || 'Failed to issue metric query';
        return [];
    };
    InfluxQueryCtrl.prototype.transformToSegments = function (addTemplateVars) {
        var _this = this;
        return function (results) {
            var segments = __WEBPACK_IMPORTED_MODULE_1_lodash___default.a.map(results, function (segment) {
                return _this.uiSegmentSrv.newSegment({ value: segment.text, expandable: segment.expandable });
            });
            if (addTemplateVars) {
                for (var _i = 0, _a = _this.templateSrv.variables; _i < _a.length; _i++) {
                    var variable = _a[_i];
                    segments.unshift(_this.uiSegmentSrv.newSegment({ type: 'template', value: '/^$' + variable.name + '$/', expandable: true }));
                }
            }
            return segments;
        };
    };
    InfluxQueryCtrl.prototype.getTagsOrValues = function (segment, index) {
        var _this = this;
        if (segment.type === 'condition') {
            return this.$q.when([this.uiSegmentSrv.newSegment('AND'), this.uiSegmentSrv.newSegment('OR')]);
        }
        if (segment.type === 'operator') {
            var nextValue = this.tagSegments[index + 1].value;
            if (/^\/.*\/$/.test(nextValue)) {
                return this.$q.when(this.uiSegmentSrv.newOperators(['=~', '!~']));
            }
            else {
                return this.$q.when(this.uiSegmentSrv.newOperators(['=', '!=', '<>', '<', '>']));
            }
        }
        var query, addTemplateVars;
        if (segment.type === 'key' || segment.type === 'plus-button') {
            query = this.queryBuilder.buildExploreQuery('TAG_KEYS');
            addTemplateVars = false;
        }
        else if (segment.type === 'value') {
            query = this.queryBuilder.buildExploreQuery('TAG_VALUES', this.tagSegments[index - 2].value);
            addTemplateVars = true;
        }
        return this.datasource.metricFindQuery(query)
            .then(this.transformToSegments(addTemplateVars))
            .then(function (results) {
            if (segment.type === 'key') {
                results.splice(0, 0, __WEBPACK_IMPORTED_MODULE_0_angular___default.a.copy(_this.removeTagFilterSegment));
            }
            return results;
        })
            .catch(this.handleQueryError.bind(this));
    };
    InfluxQueryCtrl.prototype.getFieldSegments = function () {
        var fieldsQuery = this.queryBuilder.buildExploreQuery('FIELDS');
        return this.datasource.metricFindQuery(fieldsQuery)
            .then(this.transformToSegments(false))
            .catch(this.handleQueryError);
    };
    InfluxQueryCtrl.prototype.tagSegmentUpdated = function (segment, index) {
        this.tagSegments[index] = segment;
        // handle remove tag condition
        if (segment.value === this.removeTagFilterSegment.value) {
            this.tagSegments.splice(index, 3);
            if (this.tagSegments.length === 0) {
                this.tagSegments.push(this.uiSegmentSrv.newPlusButton());
            }
            else if (this.tagSegments.length > 2) {
                this.tagSegments.splice(Math.max(index - 1, 0), 1);
                if (this.tagSegments[this.tagSegments.length - 1].type !== 'plus-button') {
                    this.tagSegments.push(this.uiSegmentSrv.newPlusButton());
                }
            }
        }
        else {
            if (segment.type === 'plus-button') {
                if (index > 2) {
                    this.tagSegments.splice(index, 0, this.uiSegmentSrv.newCondition('AND'));
                }
                this.tagSegments.push(this.uiSegmentSrv.newOperator('='));
                this.tagSegments.push(this.uiSegmentSrv.newFake('select tag value', 'value', 'query-segment-value'));
                segment.type = 'key';
                segment.cssClass = 'query-segment-key';
            }
            if ((index + 1) === this.tagSegments.length) {
                this.tagSegments.push(this.uiSegmentSrv.newPlusButton());
            }
        }
        this.rebuildTargetTagConditions();
    };
    InfluxQueryCtrl.prototype.rebuildTargetTagConditions = function () {
        var _this = this;
        var tags = [];
        var tagIndex = 0;
        var tagOperator = "";
        __WEBPACK_IMPORTED_MODULE_1_lodash___default.a.each(this.tagSegments, function (segment2, index) {
            if (segment2.type === 'key') {
                if (tags.length === 0) {
                    tags.push({});
                }
                tags[tagIndex].key = segment2.value;
            }
            else if (segment2.type === 'value') {
                tagOperator = _this.getTagValueOperator(segment2.value, tags[tagIndex].operator);
                if (tagOperator) {
                    _this.tagSegments[index - 1] = _this.uiSegmentSrv.newOperator(tagOperator);
                    tags[tagIndex].operator = tagOperator;
                }
                tags[tagIndex].value = segment2.value;
            }
            else if (segment2.type === 'condition') {
                tags.push({ condition: segment2.value });
                tagIndex += 1;
            }
            else if (segment2.type === 'operator') {
                tags[tagIndex].operator = segment2.value;
            }
        });
        this.target.tags = tags;
        this.panelCtrl.refresh();
    };
    InfluxQueryCtrl.prototype.getTagValueOperator = function (tagValue, tagOperator) {
        if (tagOperator !== '=~' && tagOperator !== '!~' && /^\/.*\/$/.test(tagValue)) {
            return '=~';
        }
        else if ((tagOperator === '=~' || tagOperator === '!~') && /^(?!\/.*\/$)/.test(tagValue)) {
            return '=';
        }
        return null;
    };
    InfluxQueryCtrl.prototype.getCollapsedText = function () {
        return this.queryModel.render(false);
    };
    InfluxQueryCtrl.templateUrl = 'partials/query.editor.html';
    return InfluxQueryCtrl;
}(__WEBPACK_IMPORTED_MODULE_5_app_plugins_sdk__["QueryCtrl"]));



/***/ }),

/***/ 1464:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__datasource__ = __webpack_require__(1465);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "MixedDatasource", function() { return __WEBPACK_IMPORTED_MODULE_0__datasource__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "Datasource", function() { return __WEBPACK_IMPORTED_MODULE_0__datasource__["a"]; });
///<reference path="../../../headers/common.d.ts" />




/***/ }),

/***/ 1465:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return MixedDatasource; });
/* unused harmony export Datasource */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_angular__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_angular___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_angular__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_lodash__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_lodash__);
///<reference path="../../../headers/common.d.ts" />


var MixedDatasource = /** @class */ (function () {
    /** @ngInject */
    MixedDatasource.$inject = ["$q", "datasourceSrv"];
    function MixedDatasource($q, datasourceSrv) {
        this.$q = $q;
        this.datasourceSrv = datasourceSrv;
    }
    MixedDatasource.prototype.query = function (options) {
        var _this = this;
        var sets = __WEBPACK_IMPORTED_MODULE_1_lodash___default.a.groupBy(options.targets, 'datasource');
        var promises = __WEBPACK_IMPORTED_MODULE_1_lodash___default.a.map(sets, function (targets) {
            var dsName = targets[0].datasource;
            if (dsName === '-- Mixed --') {
                return _this.$q([]);
            }
            return _this.datasourceSrv.get(dsName).then(function (ds) {
                var opt = __WEBPACK_IMPORTED_MODULE_0_angular___default.a.copy(options);
                opt.targets = targets;
                return ds.query(opt);
            });
        });
        return this.$q.all(promises).then(function (results) {
            return { data: __WEBPACK_IMPORTED_MODULE_1_lodash___default.a.flatten(__WEBPACK_IMPORTED_MODULE_1_lodash___default.a.map(results, 'data')) };
        });
    };
    return MixedDatasource;
}());



/***/ }),

/***/ 1466:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ConfigCtrl", function() { return MysqlConfigCtrl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AnnotationsQueryCtrl", function() { return MysqlAnnotationsQueryCtrl; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__datasource__ = __webpack_require__(1467);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__query_ctrl__ = __webpack_require__(1469);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "MysqlDatasource", function() { return __WEBPACK_IMPORTED_MODULE_0__datasource__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "Datasource", function() { return __WEBPACK_IMPORTED_MODULE_0__datasource__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "QueryCtrl", function() { return __WEBPACK_IMPORTED_MODULE_1__query_ctrl__["a"]; });
///<reference path="../../../headers/common.d.ts" />


var MysqlConfigCtrl = /** @class */ (function () {
    function MysqlConfigCtrl() {
    }
    MysqlConfigCtrl.templateUrl = 'partials/config.html';
    return MysqlConfigCtrl;
}());
var defaultQuery = "SELECT\n    UNIX_TIMESTAMP(<time_column>) as time_sec,\n    <text_column> as text,\n    <tags_column> as tags\n  FROM <table name>\n  WHERE $__timeFilter(time_column)\n  ORDER BY <time_column> ASC\n  LIMIT 100\n  ";
var MysqlAnnotationsQueryCtrl = /** @class */ (function () {
    /** @ngInject **/
    function MysqlAnnotationsQueryCtrl() {
        this.annotation.rawQuery = this.annotation.rawQuery || defaultQuery;
    }
    MysqlAnnotationsQueryCtrl.templateUrl = 'partials/annotations.editor.html';
    return MysqlAnnotationsQueryCtrl;
}());



/***/ }),

/***/ 1467:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return MysqlDatasource; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__response_parser__ = __webpack_require__(1468);
///<reference path="../../../headers/common.d.ts" />


var MysqlDatasource = /** @class */ (function () {
    /** @ngInject **/
    MysqlDatasource.$inject = ["instanceSettings", "backendSrv", "$q", "templateSrv"];
    function MysqlDatasource(instanceSettings, backendSrv, $q, templateSrv) {
        this.backendSrv = backendSrv;
        this.$q = $q;
        this.templateSrv = templateSrv;
        this.name = instanceSettings.name;
        this.id = instanceSettings.id;
        this.responseParser = new __WEBPACK_IMPORTED_MODULE_1__response_parser__["a" /* default */](this.$q);
    }
    MysqlDatasource.prototype.interpolateVariable = function (value, variable) {
        if (typeof value === 'string') {
            if (variable.multi || variable.includeAll) {
                return '\'' + value + '\'';
            }
            else {
                return value;
            }
        }
        if (typeof value === 'number') {
            return value;
        }
        var quotedValues = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.map(value, function (val) {
            if (typeof value === 'number') {
                return value;
            }
            return '\'' + val + '\'';
        });
        return quotedValues.join(',');
    };
    MysqlDatasource.prototype.query = function (options) {
        var _this = this;
        var queries = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.filter(options.targets, function (item) {
            return item.hide !== true;
        }).map(function (item) {
            return {
                refId: item.refId,
                intervalMs: options.intervalMs,
                maxDataPoints: options.maxDataPoints,
                datasourceId: _this.id,
                rawSql: _this.templateSrv.replace(item.rawSql, options.scopedVars, _this.interpolateVariable),
                format: item.format,
            };
        });
        if (queries.length === 0) {
            return this.$q.when({ data: [] });
        }
        return this.backendSrv.datasourceRequest({
            url: '/api/tsdb/query',
            method: 'POST',
            data: {
                from: options.range.from.valueOf().toString(),
                to: options.range.to.valueOf().toString(),
                queries: queries,
            }
        }).then(this.responseParser.processQueryResult);
    };
    MysqlDatasource.prototype.annotationQuery = function (options) {
        var _this = this;
        if (!options.annotation.rawQuery) {
            return this.$q.reject({ message: 'Query missing in annotation definition' });
        }
        var query = {
            refId: options.annotation.name,
            datasourceId: this.id,
            rawSql: this.templateSrv.replace(options.annotation.rawQuery, options.scopedVars, this.interpolateVariable),
            format: 'table',
        };
        return this.backendSrv.datasourceRequest({
            url: '/api/tsdb/query',
            method: 'POST',
            data: {
                from: options.range.from.valueOf().toString(),
                to: options.range.to.valueOf().toString(),
                queries: [query],
            }
        }).then(function (data) { return _this.responseParser.transformAnnotationResponse(options, data); });
    };
    MysqlDatasource.prototype.metricFindQuery = function (query, optionalOptions) {
        var _this = this;
        var refId = 'tempvar';
        if (optionalOptions && optionalOptions.variable && optionalOptions.variable.name) {
            refId = optionalOptions.variable.name;
        }
        var interpolatedQuery = {
            refId: refId,
            datasourceId: this.id,
            rawSql: this.templateSrv.replace(query, {}, this.interpolateVariable),
            format: 'table',
        };
        return this.backendSrv.datasourceRequest({
            url: '/api/tsdb/query',
            method: 'POST',
            data: {
                queries: [interpolatedQuery],
            }
        })
            .then(function (data) { return _this.responseParser.parseMetricFindQueryResult(refId, data); });
    };
    MysqlDatasource.prototype.testDatasource = function () {
        return this.backendSrv.datasourceRequest({
            url: '/api/tsdb/query',
            method: 'POST',
            data: {
                from: '5m',
                to: 'now',
                queries: [{
                        refId: 'A',
                        intervalMs: 1,
                        maxDataPoints: 1,
                        datasourceId: this.id,
                        rawSql: "SELECT 1",
                        format: 'table',
                    }],
            }
        }).then(function (res) {
            return { status: "success", message: "Database Connection OK" };
        }).catch(function (err) {
            console.log(err);
            if (err.data && err.data.message) {
                return { status: "error", message: err.data.message };
            }
            else {
                return { status: "error", message: err.status };
            }
        });
    };
    return MysqlDatasource;
}());



/***/ }),

/***/ 1468:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_lodash__);
///<reference path="../../../headers/common.d.ts" />

var ResponseParser = /** @class */ (function () {
    function ResponseParser($q) {
        this.$q = $q;
    }
    ResponseParser.prototype.processQueryResult = function (res) {
        var data = [];
        if (!res.data.results) {
            return { data: data };
        }
        for (var key in res.data.results) {
            var queryRes = res.data.results[key];
            if (queryRes.series) {
                for (var _i = 0, _a = queryRes.series; _i < _a.length; _i++) {
                    var series = _a[_i];
                    data.push({
                        target: series.name,
                        datapoints: series.points,
                        refId: queryRes.refId,
                        meta: queryRes.meta,
                    });
                }
            }
            if (queryRes.tables) {
                for (var _b = 0, _c = queryRes.tables; _b < _c.length; _b++) {
                    var table = _c[_b];
                    table.type = 'table';
                    table.refId = queryRes.refId;
                    table.meta = queryRes.meta;
                    data.push(table);
                }
            }
        }
        return { data: data };
    };
    ResponseParser.prototype.parseMetricFindQueryResult = function (refId, results) {
        if (!results || results.data.length === 0 || results.data.results[refId].meta.rowCount === 0) {
            return [];
        }
        var columns = results.data.results[refId].tables[0].columns;
        var rows = results.data.results[refId].tables[0].rows;
        var textColIndex = this.findColIndex(columns, '__text');
        var valueColIndex = this.findColIndex(columns, '__value');
        if (columns.length === 2 && textColIndex !== -1 && valueColIndex !== -1) {
            return this.transformToKeyValueList(rows, textColIndex, valueColIndex);
        }
        return this.transformToSimpleList(rows);
    };
    ResponseParser.prototype.transformToKeyValueList = function (rows, textColIndex, valueColIndex) {
        var res = [];
        for (var i = 0; i < rows.length; i++) {
            if (!this.containsKey(res, rows[i][textColIndex])) {
                res.push({ text: rows[i][textColIndex], value: rows[i][valueColIndex] });
            }
        }
        return res;
    };
    ResponseParser.prototype.transformToSimpleList = function (rows) {
        var res = [];
        for (var i = 0; i < rows.length; i++) {
            for (var j = 0; j < rows[i].length; j++) {
                var value = rows[i][j];
                if (res.indexOf(value) === -1) {
                    res.push(value);
                }
            }
        }
        return __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.map(res, function (value) {
            return { text: value };
        });
    };
    ResponseParser.prototype.findColIndex = function (columns, colName) {
        for (var i = 0; i < columns.length; i++) {
            if (columns[i].text === colName) {
                return i;
            }
        }
        return -1;
    };
    ResponseParser.prototype.containsKey = function (res, key) {
        for (var i = 0; i < res.length; i++) {
            if (res[i].text === key) {
                return true;
            }
        }
        return false;
    };
    ResponseParser.prototype.transformAnnotationResponse = function (options, data) {
        var table = data.data.results[options.annotation.name].tables[0];
        var timeColumnIndex = -1;
        var textColumnIndex = -1;
        var tagsColumnIndex = -1;
        for (var i = 0; i < table.columns.length; i++) {
            if (table.columns[i].text === 'time_sec') {
                timeColumnIndex = i;
            }
            else if (table.columns[i].text === 'title') {
                return this.$q.reject({ message: 'The title column for annotations is deprecated, now only a column named text is returned' });
            }
            else if (table.columns[i].text === 'text') {
                textColumnIndex = i;
            }
            else if (table.columns[i].text === 'tags') {
                tagsColumnIndex = i;
            }
        }
        if (timeColumnIndex === -1) {
            return this.$q.reject({ message: 'Missing mandatory time column (with time_sec column alias) in annotation query.' });
        }
        var list = [];
        for (var i = 0; i < table.rows.length; i++) {
            var row = table.rows[i];
            list.push({
                annotation: options.annotation,
                time: Math.floor(row[timeColumnIndex]) * 1000,
                text: row[textColumnIndex],
                tags: row[tagsColumnIndex] ? row[tagsColumnIndex].trim().split(/\s*,\s*/) : []
            });
        }
        return list;
    };
    return ResponseParser;
}());
/* harmony default export */ __webpack_exports__["a"] = (ResponseParser);


/***/ }),

/***/ 1469:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return MysqlQueryCtrl; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_app_plugins_sdk__ = __webpack_require__(1305);
///<reference path="../../../headers/common.d.ts" />
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();


var defaultQuery = "SELECT\n  UNIX_TIMESTAMP(<time_column>) as time_sec,\n  <value column> as value,\n  <series name column> as metric\nFROM <table name>\nWHERE $__timeFilter(time_column)\nORDER BY <time_column> ASC\n";
var MysqlQueryCtrl = /** @class */ (function (_super) {
    __extends(MysqlQueryCtrl, _super);
    /** @ngInject **/
    MysqlQueryCtrl.$inject = ["$scope", "$injector"];
    function MysqlQueryCtrl($scope, $injector) {
        var _this = _super.call(this, $scope, $injector) || this;
        _this.target.format = _this.target.format || 'time_series';
        _this.target.alias = "";
        _this.formats = [
            { text: 'Time series', value: 'time_series' },
            { text: 'Table', value: 'table' },
        ];
        if (!_this.target.rawSql) {
            // special handling when in table panel
            if (_this.panelCtrl.panel.type === 'table') {
                _this.target.format = 'table';
                _this.target.rawSql = "SELECT 1";
            }
            else {
                _this.target.rawSql = defaultQuery;
            }
        }
        _this.panelCtrl.events.on('data-received', _this.onDataReceived.bind(_this), $scope);
        _this.panelCtrl.events.on('data-error', _this.onDataError.bind(_this), $scope);
        return _this;
    }
    MysqlQueryCtrl.prototype.onDataReceived = function (dataList) {
        this.lastQueryMeta = null;
        this.lastQueryError = null;
        var anySeriesFromQuery = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.find(dataList, { refId: this.target.refId });
        if (anySeriesFromQuery) {
            this.lastQueryMeta = anySeriesFromQuery.meta;
        }
    };
    MysqlQueryCtrl.prototype.onDataError = function (err) {
        if (err.data && err.data.results) {
            var queryRes = err.data.results[this.target.refId];
            if (queryRes) {
                this.lastQueryMeta = queryRes.meta;
                this.lastQueryError = queryRes.error;
            }
        }
    };
    MysqlQueryCtrl.templateUrl = 'partials/query.editor.html';
    return MysqlQueryCtrl;
}(__WEBPACK_IMPORTED_MODULE_1_app_plugins_sdk__["QueryCtrl"]));



/***/ }),

/***/ 1470:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ConfigCtrl", function() { return PostgresConfigCtrl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AnnotationsQueryCtrl", function() { return PostgresAnnotationsQueryCtrl; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__datasource__ = __webpack_require__(1471);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__query_ctrl__ = __webpack_require__(1473);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "PostgresDatasource", function() { return __WEBPACK_IMPORTED_MODULE_0__datasource__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "Datasource", function() { return __WEBPACK_IMPORTED_MODULE_0__datasource__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "QueryCtrl", function() { return __WEBPACK_IMPORTED_MODULE_1__query_ctrl__["a"]; });
///<reference path="../../../headers/common.d.ts" />


var PostgresConfigCtrl = /** @class */ (function () {
    /** @ngInject **/
    PostgresConfigCtrl.$inject = ["$scope"];
    function PostgresConfigCtrl($scope) {
        this.current.jsonData.sslmode = this.current.jsonData.sslmode || 'require';
    }
    PostgresConfigCtrl.templateUrl = 'partials/config.html';
    return PostgresConfigCtrl;
}());
var defaultQuery = "SELECT\n  extract(epoch from time_column) AS time,\n  text_column as text,\n  tags_column as tags\nFROM\n  metric_table\nWHERE\n  $__timeFilter(time_column)\n";
var PostgresAnnotationsQueryCtrl = /** @class */ (function () {
    /** @ngInject **/
    function PostgresAnnotationsQueryCtrl() {
        this.annotation.rawQuery = this.annotation.rawQuery || defaultQuery;
    }
    PostgresAnnotationsQueryCtrl.templateUrl = 'partials/annotations.editor.html';
    return PostgresAnnotationsQueryCtrl;
}());



/***/ }),

/***/ 1471:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return PostgresDatasource; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__response_parser__ = __webpack_require__(1472);
///<reference path="../../../headers/common.d.ts" />


var PostgresDatasource = /** @class */ (function () {
    /** @ngInject **/
    PostgresDatasource.$inject = ["instanceSettings", "backendSrv", "$q", "templateSrv"];
    function PostgresDatasource(instanceSettings, backendSrv, $q, templateSrv) {
        this.backendSrv = backendSrv;
        this.$q = $q;
        this.templateSrv = templateSrv;
        this.name = instanceSettings.name;
        this.id = instanceSettings.id;
        this.responseParser = new __WEBPACK_IMPORTED_MODULE_1__response_parser__["a" /* default */](this.$q);
    }
    PostgresDatasource.prototype.interpolateVariable = function (value, variable) {
        if (typeof value === 'string') {
            if (variable.multi || variable.includeAll) {
                return '\'' + value + '\'';
            }
            else {
                return value;
            }
        }
        if (typeof value === 'number') {
            return value;
        }
        var quotedValues = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.map(value, function (val) {
            return '\'' + val + '\'';
        });
        return quotedValues.join(',');
    };
    PostgresDatasource.prototype.query = function (options) {
        var _this = this;
        var queries = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.filter(options.targets, function (item) {
            return item.hide !== true;
        }).map(function (item) {
            return {
                refId: item.refId,
                intervalMs: options.intervalMs,
                maxDataPoints: options.maxDataPoints,
                datasourceId: _this.id,
                rawSql: _this.templateSrv.replace(item.rawSql, options.scopedVars, _this.interpolateVariable),
                format: item.format,
            };
        });
        if (queries.length === 0) {
            return this.$q.when({ data: [] });
        }
        return this.backendSrv.datasourceRequest({
            url: '/api/tsdb/query',
            method: 'POST',
            data: {
                from: options.range.from.valueOf().toString(),
                to: options.range.to.valueOf().toString(),
                queries: queries,
            }
        }).then(this.responseParser.processQueryResult);
    };
    PostgresDatasource.prototype.annotationQuery = function (options) {
        var _this = this;
        if (!options.annotation.rawQuery) {
            return this.$q.reject({ message: 'Query missing in annotation definition' });
        }
        var query = {
            refId: options.annotation.name,
            datasourceId: this.id,
            rawSql: this.templateSrv.replace(options.annotation.rawQuery, options.scopedVars, this.interpolateVariable),
            format: 'table',
        };
        return this.backendSrv.datasourceRequest({
            url: '/api/tsdb/query',
            method: 'POST',
            data: {
                from: options.range.from.valueOf().toString(),
                to: options.range.to.valueOf().toString(),
                queries: [query],
            }
        }).then(function (data) { return _this.responseParser.transformAnnotationResponse(options, data); });
    };
    PostgresDatasource.prototype.metricFindQuery = function (query, optionalOptions) {
        var _this = this;
        var refId = 'tempvar';
        if (optionalOptions && optionalOptions.variable && optionalOptions.variable.name) {
            refId = optionalOptions.variable.name;
        }
        var interpolatedQuery = {
            refId: refId,
            datasourceId: this.id,
            rawSql: this.templateSrv.replace(query, {}, this.interpolateVariable),
            format: 'table',
        };
        return this.backendSrv.datasourceRequest({
            url: '/api/tsdb/query',
            method: 'POST',
            data: {
                queries: [interpolatedQuery],
            }
        })
            .then(function (data) { return _this.responseParser.parseMetricFindQueryResult(refId, data); });
    };
    PostgresDatasource.prototype.testDatasource = function () {
        return this.backendSrv.datasourceRequest({
            url: '/api/tsdb/query',
            method: 'POST',
            data: {
                from: '5m',
                to: 'now',
                queries: [{
                        refId: 'A',
                        intervalMs: 1,
                        maxDataPoints: 1,
                        datasourceId: this.id,
                        rawSql: "SELECT 1",
                        format: 'table',
                    }],
            }
        }).then(function (res) {
            return { status: "success", message: "Database Connection OK" };
        }).catch(function (err) {
            console.log(err);
            if (err.data && err.data.message) {
                return { status: "error", message: err.data.message };
            }
            else {
                return { status: "error", message: err.status };
            }
        });
    };
    return PostgresDatasource;
}());



/***/ }),

/***/ 1472:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_lodash__);
///<reference path="../../../headers/common.d.ts" />

var ResponseParser = /** @class */ (function () {
    function ResponseParser($q) {
        this.$q = $q;
    }
    ResponseParser.prototype.processQueryResult = function (res) {
        var data = [];
        if (!res.data.results) {
            return { data: data };
        }
        for (var key in res.data.results) {
            var queryRes = res.data.results[key];
            if (queryRes.series) {
                for (var _i = 0, _a = queryRes.series; _i < _a.length; _i++) {
                    var series = _a[_i];
                    data.push({
                        target: series.name,
                        datapoints: series.points,
                        refId: queryRes.refId,
                        meta: queryRes.meta,
                    });
                }
            }
            if (queryRes.tables) {
                for (var _b = 0, _c = queryRes.tables; _b < _c.length; _b++) {
                    var table = _c[_b];
                    table.type = 'table';
                    table.refId = queryRes.refId;
                    table.meta = queryRes.meta;
                    data.push(table);
                }
            }
        }
        return { data: data };
    };
    ResponseParser.prototype.parseMetricFindQueryResult = function (refId, results) {
        if (!results || results.data.length === 0 || results.data.results[refId].meta.rowCount === 0) {
            return [];
        }
        var columns = results.data.results[refId].tables[0].columns;
        var rows = results.data.results[refId].tables[0].rows;
        var textColIndex = this.findColIndex(columns, '__text');
        var valueColIndex = this.findColIndex(columns, '__value');
        if (columns.length === 2 && textColIndex !== -1 && valueColIndex !== -1) {
            return this.transformToKeyValueList(rows, textColIndex, valueColIndex);
        }
        return this.transformToSimpleList(rows);
    };
    ResponseParser.prototype.transformToKeyValueList = function (rows, textColIndex, valueColIndex) {
        var res = [];
        for (var i = 0; i < rows.length; i++) {
            if (!this.containsKey(res, rows[i][textColIndex])) {
                res.push({ text: rows[i][textColIndex], value: rows[i][valueColIndex] });
            }
        }
        return res;
    };
    ResponseParser.prototype.transformToSimpleList = function (rows) {
        var res = [];
        for (var i = 0; i < rows.length; i++) {
            for (var j = 0; j < rows[i].length; j++) {
                var value = rows[i][j];
                if (res.indexOf(value) === -1) {
                    res.push(value);
                }
            }
        }
        return __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.map(res, function (value) {
            return { text: value };
        });
    };
    ResponseParser.prototype.findColIndex = function (columns, colName) {
        for (var i = 0; i < columns.length; i++) {
            if (columns[i].text === colName) {
                return i;
            }
        }
        return -1;
    };
    ResponseParser.prototype.containsKey = function (res, key) {
        for (var i = 0; i < res.length; i++) {
            if (res[i].text === key) {
                return true;
            }
        }
        return false;
    };
    ResponseParser.prototype.transformAnnotationResponse = function (options, data) {
        var table = data.data.results[options.annotation.name].tables[0];
        var timeColumnIndex = -1;
        var titleColumnIndex = -1;
        var textColumnIndex = -1;
        var tagsColumnIndex = -1;
        for (var i = 0; i < table.columns.length; i++) {
            if (table.columns[i].text === 'time') {
                timeColumnIndex = i;
            }
            else if (table.columns[i].text === 'text') {
                textColumnIndex = i;
            }
            else if (table.columns[i].text === 'tags') {
                tagsColumnIndex = i;
            }
        }
        if (timeColumnIndex === -1) {
            return this.$q.reject({ message: 'Missing mandatory time column in annotation query.' });
        }
        var list = [];
        for (var i = 0; i < table.rows.length; i++) {
            var row = table.rows[i];
            list.push({
                annotation: options.annotation,
                time: Math.floor(row[timeColumnIndex]) * 1000,
                title: row[titleColumnIndex],
                text: row[textColumnIndex],
                tags: row[tagsColumnIndex] ? row[tagsColumnIndex].trim().split(/\s*,\s*/) : []
            });
        }
        return list;
    };
    return ResponseParser;
}());
/* harmony default export */ __webpack_exports__["a"] = (ResponseParser);


/***/ }),

/***/ 1473:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return PostgresQueryCtrl; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_app_plugins_sdk__ = __webpack_require__(1305);
///<reference path="../../../headers/common.d.ts" />
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();


var defaultQuery = "SELECT\n  $__time(time_column),\n  value1\nFROM\n  metric_table\nWHERE\n  $__timeFilter(time_column)\n";
var PostgresQueryCtrl = /** @class */ (function (_super) {
    __extends(PostgresQueryCtrl, _super);
    /** @ngInject **/
    PostgresQueryCtrl.$inject = ["$scope", "$injector"];
    function PostgresQueryCtrl($scope, $injector) {
        var _this = _super.call(this, $scope, $injector) || this;
        _this.target.format = _this.target.format || 'time_series';
        _this.target.alias = "";
        _this.formats = [
            { text: 'Time series', value: 'time_series' },
            { text: 'Table', value: 'table' },
        ];
        if (!_this.target.rawSql) {
            // special handling when in table panel
            if (_this.panelCtrl.panel.type === 'table') {
                _this.target.format = 'table';
                _this.target.rawSql = "SELECT 1";
            }
            else {
                _this.target.rawSql = defaultQuery;
            }
        }
        _this.panelCtrl.events.on('data-received', _this.onDataReceived.bind(_this), $scope);
        _this.panelCtrl.events.on('data-error', _this.onDataError.bind(_this), $scope);
        return _this;
    }
    PostgresQueryCtrl.prototype.onDataReceived = function (dataList) {
        this.lastQueryMeta = null;
        this.lastQueryError = null;
        var anySeriesFromQuery = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.find(dataList, { refId: this.target.refId });
        if (anySeriesFromQuery) {
            this.lastQueryMeta = anySeriesFromQuery.meta;
        }
    };
    PostgresQueryCtrl.prototype.onDataError = function (err) {
        if (err.data && err.data.results) {
            var queryRes = err.data.results[this.target.refId];
            if (queryRes) {
                this.lastQueryMeta = queryRes.meta;
                this.lastQueryError = queryRes.error;
            }
        }
    };
    PostgresQueryCtrl.templateUrl = 'partials/query.editor.html';
    return PostgresQueryCtrl;
}(__WEBPACK_IMPORTED_MODULE_1_app_plugins_sdk__["QueryCtrl"]));



/***/ }),

/***/ 1474:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ConfigCtrl", function() { return PrometheusConfigCtrl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AnnotationsQueryCtrl", function() { return PrometheusAnnotationsQueryCtrl; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__datasource__ = __webpack_require__(1475);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__query_ctrl__ = __webpack_require__(1477);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "Datasource", function() { return __WEBPACK_IMPORTED_MODULE_0__datasource__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "QueryCtrl", function() { return __WEBPACK_IMPORTED_MODULE_1__query_ctrl__["a"]; });


var PrometheusConfigCtrl = /** @class */ (function () {
    function PrometheusConfigCtrl() {
    }
    PrometheusConfigCtrl.templateUrl = 'partials/config.html';
    return PrometheusConfigCtrl;
}());
var PrometheusAnnotationsQueryCtrl = /** @class */ (function () {
    function PrometheusAnnotationsQueryCtrl() {
    }
    PrometheusAnnotationsQueryCtrl.templateUrl = 'partials/annotations.editor.html';
    return PrometheusAnnotationsQueryCtrl;
}());



/***/ }),

/***/ 1475:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return PrometheusDatasource; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_app_core_utils_kbn__ = __webpack_require__(464);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_app_core_utils_datemath__ = __webpack_require__(467);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__metric_find_query__ = __webpack_require__(1476);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__metric_find_query___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3__metric_find_query__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_app_core_table_model__ = __webpack_require__(1310);





function prometheusSpecialRegexEscape(value) {
    return value.replace(/[\\^$*+?.()|[\]{}]/g, '\\\\$&');
}
var PrometheusDatasource = /** @class */ (function () {
    /** @ngInject */
    PrometheusDatasource.$inject = ["instanceSettings", "$q", "backendSrv", "templateSrv", "timeSrv"];
    function PrometheusDatasource(instanceSettings, $q, backendSrv, templateSrv, timeSrv) {
        this.$q = $q;
        this.backendSrv = backendSrv;
        this.templateSrv = templateSrv;
        this.timeSrv = timeSrv;
        this.type = 'prometheus';
        this.editorSrc = 'app/features/prometheus/partials/query.editor.html';
        this.name = instanceSettings.name;
        this.supportMetrics = true;
        this.url = instanceSettings.url;
        this.directUrl = instanceSettings.directUrl;
        this.basicAuth = instanceSettings.basicAuth;
        this.withCredentials = instanceSettings.withCredentials;
        this.interval = instanceSettings.jsonData.timeInterval || '15s';
    }
    PrometheusDatasource.prototype._request = function (method, url, requestId) {
        var options = {
            url: this.url + url,
            method: method,
            requestId: requestId,
        };
        if (this.basicAuth || this.withCredentials) {
            options.withCredentials = true;
        }
        if (this.basicAuth) {
            options.headers = {
                "Authorization": this.basicAuth
            };
        }
        return this.backendSrv.datasourceRequest(options);
    };
    PrometheusDatasource.prototype.interpolateQueryExpr = function (value, variable, defaultFormatFn) {
        // if no multi or include all do not regexEscape
        if (!variable.multi && !variable.includeAll) {
            return value;
        }
        if (typeof value === 'string') {
            return prometheusSpecialRegexEscape(value);
        }
        var escapedValues = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.map(value, prometheusSpecialRegexEscape);
        return escapedValues.join('|');
    };
    PrometheusDatasource.prototype.targetContainsTemplate = function (target) {
        return this.templateSrv.variableExists(target.expr);
    };
    PrometheusDatasource.prototype.query = function (options) {
        var _this = this;
        var self = this;
        var start = this.getPrometheusTime(options.range.from, false);
        var end = this.getPrometheusTime(options.range.to, true);
        var range = Math.ceil(end - start);
        var queries = [];
        var activeTargets = [];
        options = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.clone(options);
        for (var _i = 0, _a = options.targets; _i < _a.length; _i++) {
            var target = _a[_i];
            if (!target.expr || target.hide) {
                continue;
            }
            activeTargets.push(target);
            queries.push(this.createQuery(target, options, range));
        }
        // No valid targets, return the empty result to save a round trip.
        if (__WEBPACK_IMPORTED_MODULE_0_lodash___default.a.isEmpty(queries)) {
            return this.$q.when({ data: [] });
        }
        var allQueryPromise = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.map(queries, function (query) {
            if (!query.instant) {
                return _this.performTimeSeriesQuery(query, start, end);
            }
            else {
                return _this.performInstantQuery(query, end);
            }
        });
        return this.$q.all(allQueryPromise).then(function (responseList) {
            var result = [];
            __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.each(responseList, function (response, index) {
                if (response.status === 'error') {
                    throw response.error;
                }
                if (activeTargets[index].format === "table") {
                    result.push(self.transformMetricDataToTable(response.data.data.result));
                }
                else {
                    for (var _i = 0, _a = response.data.data.result; _i < _a.length; _i++) {
                        var metricData = _a[_i];
                        if (response.data.data.resultType === 'matrix') {
                            result.push(self.transformMetricData(metricData, activeTargets[index], start, end, queries[index].step));
                        }
                        else if (response.data.data.resultType === 'vector') {
                            result.push(self.transformInstantMetricData(metricData, activeTargets[index]));
                        }
                    }
                }
            });
            return { data: result };
        });
    };
    PrometheusDatasource.prototype.createQuery = function (target, options, range) {
        var query = {};
        query.instant = target.instant;
        var interval = __WEBPACK_IMPORTED_MODULE_1_app_core_utils_kbn__["default"].interval_to_seconds(options.interval);
        // Minimum interval ("Min step"), if specified for the query. or same as interval otherwise
        var minInterval = __WEBPACK_IMPORTED_MODULE_1_app_core_utils_kbn__["default"].interval_to_seconds(this.templateSrv.replace(target.interval, options.scopedVars) || options.interval);
        var intervalFactor = target.intervalFactor || 1;
        // Adjust the interval to take into account any specified minimum and interval factor plus Prometheus limits
        var adjustedInterval = this.adjustInterval(interval, minInterval, range, intervalFactor);
        var scopedVars = options.scopedVars;
        // If the interval was adjusted, make a shallow copy of scopedVars with updated interval vars
        if (interval !== adjustedInterval) {
            interval = adjustedInterval;
            scopedVars = Object.assign({}, options.scopedVars, {
                "__interval": { text: interval + "s", value: interval + "s" },
                "__interval_ms": { text: interval * 1000, value: interval * 1000 },
            });
        }
        query.step = interval;
        // Only replace vars in expression after having (possibly) updated interval vars
        query.expr = this.templateSrv.replace(target.expr, scopedVars, this.interpolateQueryExpr);
        query.requestId = options.panelId + target.refId;
        return query;
    };
    PrometheusDatasource.prototype.adjustInterval = function (interval, minInterval, range, intervalFactor) {
        // Prometheus will drop queries that might return more than 11000 data points.
        // Calibrate interval if it is too small.
        if (interval !== 0 && range / intervalFactor / interval > 11000) {
            interval = Math.ceil(range / intervalFactor / 11000);
        }
        return Math.max(interval * intervalFactor, minInterval, 1);
    };
    PrometheusDatasource.prototype.performTimeSeriesQuery = function (query, start, end) {
        if (start > end) {
            throw { message: 'Invalid time range' };
        }
        var url = '/api/v1/query_range?query=' + encodeURIComponent(query.expr) + '&start=' + start + '&end=' + end + '&step=' + query.step;
        return this._request('GET', url, query.requestId);
    };
    PrometheusDatasource.prototype.performInstantQuery = function (query, time) {
        var url = '/api/v1/query?query=' + encodeURIComponent(query.expr) + '&time=' + time;
        return this._request('GET', url, query.requestId);
    };
    PrometheusDatasource.prototype.performSuggestQuery = function (query, cache) {
        var _this = this;
        if (cache === void 0) { cache = false; }
        var url = '/api/v1/label/__name__/values';
        if (cache && this.metricsNameCache && this.metricsNameCache.expire > Date.now()) {
            return this.$q.when(__WEBPACK_IMPORTED_MODULE_0_lodash___default.a.filter(this.metricsNameCache.data, function (metricName) {
                return metricName.indexOf(query) !== 1;
            }));
        }
        return this._request('GET', url).then(function (result) {
            _this.metricsNameCache = {
                data: result.data.data,
                expire: Date.now() + (60 * 1000)
            };
            return __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.filter(result.data.data, function (metricName) {
                return metricName.indexOf(query) !== 1;
            });
        });
    };
    PrometheusDatasource.prototype.metricFindQuery = function (query) {
        if (!query) {
            return this.$q.when([]);
        }
        var interpolated = this.templateSrv.replace(query, {}, this.interpolateQueryExpr);
        var metricFindQuery = new __WEBPACK_IMPORTED_MODULE_3__metric_find_query___default.a(this, interpolated, this.timeSrv);
        return metricFindQuery.process();
    };
    PrometheusDatasource.prototype.annotationQuery = function (options) {
        var annotation = options.annotation;
        var expr = annotation.expr || '';
        var tagKeys = annotation.tagKeys || '';
        var titleFormat = annotation.titleFormat || '';
        var textFormat = annotation.textFormat || '';
        if (!expr) {
            return this.$q.when([]);
        }
        var interpolated = this.templateSrv.replace(expr, {}, this.interpolateQueryExpr);
        var step = '60s';
        if (annotation.step) {
            step = this.templateSrv.replace(annotation.step);
        }
        var start = this.getPrometheusTime(options.range.from, false);
        var end = this.getPrometheusTime(options.range.to, true);
        var query = {
            expr: interpolated,
            step: this.adjustInterval(__WEBPACK_IMPORTED_MODULE_1_app_core_utils_kbn__["default"].interval_to_seconds(step), 0, Math.ceil(end - start), 1) + 's'
        };
        var self = this;
        return this.performTimeSeriesQuery(query, start, end).then(function (results) {
            var eventList = [];
            tagKeys = tagKeys.split(',');
            __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.each(results.data.data.result, function (series) {
                var tags = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.chain(series.metric)
                    .filter(function (v, k) {
                    return __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.includes(tagKeys, k);
                }).value();
                for (var _i = 0, _a = series.values; _i < _a.length; _i++) {
                    var value = _a[_i];
                    if (value[1] === '1') {
                        var event = {
                            annotation: annotation,
                            time: Math.floor(parseFloat(value[0])) * 1000,
                            title: self.renderTemplate(titleFormat, series.metric),
                            tags: tags,
                            text: self.renderTemplate(textFormat, series.metric)
                        };
                        eventList.push(event);
                    }
                }
            });
            return eventList;
        });
    };
    PrometheusDatasource.prototype.testDatasource = function () {
        return this.metricFindQuery('metrics(.*)').then(function () {
            return { status: 'success', message: 'Data source is working' };
        });
    };
    PrometheusDatasource.prototype.transformMetricData = function (md, options, start, end, step) {
        var dps = [], metricLabel = null;
        metricLabel = this.createMetricLabel(md.metric, options);
        var stepMs = step * 1000;
        var baseTimestamp = start * 1000;
        for (var _i = 0, _a = md.values; _i < _a.length; _i++) {
            var value = _a[_i];
            var dp_value = parseFloat(value[1]);
            if (__WEBPACK_IMPORTED_MODULE_0_lodash___default.a.isNaN(dp_value)) {
                dp_value = null;
            }
            var timestamp = parseFloat(value[0]) * 1000;
            for (var t = baseTimestamp; t < timestamp; t += stepMs) {
                dps.push([null, t]);
            }
            baseTimestamp = timestamp + stepMs;
            dps.push([dp_value, timestamp]);
        }
        var endTimestamp = end * 1000;
        for (var t = baseTimestamp; t <= endTimestamp; t += stepMs) {
            dps.push([null, t]);
        }
        return { target: metricLabel, datapoints: dps };
    };
    PrometheusDatasource.prototype.transformMetricDataToTable = function (md) {
        var table = new __WEBPACK_IMPORTED_MODULE_4_app_core_table_model__["default"]();
        var i, j;
        var metricLabels = {};
        if (md.length === 0) {
            return table;
        }
        // Collect all labels across all metrics
        __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.each(md, function (series) {
            for (var label in series.metric) {
                if (!metricLabels.hasOwnProperty(label)) {
                    metricLabels[label] = 1;
                }
            }
        });
        // Sort metric labels, create columns for them and record their index
        var sortedLabels = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.keys(metricLabels).sort();
        table.columns.push({ text: 'Time', type: 'time' });
        __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.each(sortedLabels, function (label, labelIndex) {
            metricLabels[label] = labelIndex + 1;
            table.columns.push({ text: label });
        });
        table.columns.push({ text: 'Value' });
        // Populate rows, set value to empty string when label not present.
        __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.each(md, function (series) {
            if (series.value) {
                series.values = [series.value];
            }
            if (series.values) {
                for (i = 0; i < series.values.length; i++) {
                    var values = series.values[i];
                    var reordered = [values[0] * 1000];
                    if (series.metric) {
                        for (j = 0; j < sortedLabels.length; j++) {
                            var label = sortedLabels[j];
                            if (series.metric.hasOwnProperty(label)) {
                                reordered.push(series.metric[label]);
                            }
                            else {
                                reordered.push('');
                            }
                        }
                    }
                    reordered.push(parseFloat(values[1]));
                    table.rows.push(reordered);
                }
            }
        });
        return table;
    };
    PrometheusDatasource.prototype.transformInstantMetricData = function (md, options) {
        var dps = [], metricLabel = null;
        metricLabel = this.createMetricLabel(md.metric, options);
        dps.push([parseFloat(md.value[1]), md.value[0] * 1000]);
        return { target: metricLabel, datapoints: dps };
    };
    PrometheusDatasource.prototype.createMetricLabel = function (labelData, options) {
        if (__WEBPACK_IMPORTED_MODULE_0_lodash___default.a.isUndefined(options) || __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.isEmpty(options.legendFormat)) {
            return this.getOriginalMetricName(labelData);
        }
        return this.renderTemplate(this.templateSrv.replace(options.legendFormat), labelData) || '{}';
    };
    PrometheusDatasource.prototype.renderTemplate = function (aliasPattern, aliasData) {
        var aliasRegex = /\{\{\s*(.+?)\s*\}\}/g;
        return aliasPattern.replace(aliasRegex, function (match, g1) {
            if (aliasData[g1]) {
                return aliasData[g1];
            }
            return g1;
        });
    };
    PrometheusDatasource.prototype.getOriginalMetricName = function (labelData) {
        var metricName = labelData.__name__ || '';
        delete labelData.__name__;
        var labelPart = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.map(__WEBPACK_IMPORTED_MODULE_0_lodash___default.a.toPairs(labelData), function (label) {
            return label[0] + '="' + label[1] + '"';
        }).join(',');
        return metricName + '{' + labelPart + '}';
    };
    PrometheusDatasource.prototype.getPrometheusTime = function (date, roundUp) {
        if (__WEBPACK_IMPORTED_MODULE_0_lodash___default.a.isString(date)) {
            date = __WEBPACK_IMPORTED_MODULE_2_app_core_utils_datemath__["parse"](date, roundUp);
        }
        return Math.ceil(date.valueOf() / 1000);
    };
    return PrometheusDatasource;
}());



/***/ }),

/***/ 1476:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
  __webpack_require__(7)
], __WEBPACK_AMD_DEFINE_RESULT__ = function (_) {
  'use strict';

  function PrometheusMetricFindQuery(datasource, query, timeSrv) {
    this.datasource = datasource;
    this.query = query;
    this.range = timeSrv.timeRange();
  }

  PrometheusMetricFindQuery.prototype.process = function() {
    var label_values_regex = /^label_values\((?:(.+),\s*)?([a-zA-Z_][a-zA-Z0-9_]+)\)$/;
    var metric_names_regex = /^metrics\((.+)\)$/;
    var query_result_regex = /^query_result\((.+)\)$/;

    var label_values_query = this.query.match(label_values_regex);
    if (label_values_query) {
      if (label_values_query[1]) {
        return this.labelValuesQuery(label_values_query[2], label_values_query[1]);
      } else {
        return this.labelValuesQuery(label_values_query[2], null);
      }
    }

    var metric_names_query = this.query.match(metric_names_regex);
    if (metric_names_query) {
      return this.metricNameQuery(metric_names_query[1]);
    }

    var query_result_query = this.query.match(query_result_regex);
    if (query_result_query) {
      return this.queryResultQuery(query_result_query[1]);
    }

    // if query contains full metric name, return metric name and label list
    return this.metricNameAndLabelsQuery(this.query);
  };

  PrometheusMetricFindQuery.prototype.labelValuesQuery = function(label, metric) {
    var url;

    if (!metric) {
      // return label values globally
      url = '/api/v1/label/' + label + '/values';

      return this.datasource._request('GET', url).then(function(result) {
        return _.map(result.data.data, function(value) {
          return {text: value};
        });
      });
    } else {
      var start = this.datasource.getPrometheusTime(this.range.from, false);
      var end = this.datasource.getPrometheusTime(this.range.to, true);
      url = '/api/v1/series?match[]=' + encodeURIComponent(metric)
        + '&start=' + start
        + '&end=' + end;

      return this.datasource._request('GET', url)
      .then(function(result) {
        var _labels = _.map(result.data.data, function(metric) {
          return metric[label];
        });

        return _.uniq(_labels).map(function(metric) {
          return {
            text: metric,
            expandable: true
          };
        });
      });
    }
  };

  PrometheusMetricFindQuery.prototype.metricNameQuery = function(metricFilterPattern) {
    var url = '/api/v1/label/__name__/values';

    return this.datasource._request('GET', url)
    .then(function(result) {
      return _.chain(result.data.data)
      .filter(function(metricName) {
        var r = new RegExp(metricFilterPattern);
        return r.test(metricName);
      })
      .map(function(matchedMetricName) {
        return {
          text: matchedMetricName,
          expandable: true
        };
      })
      .value();
    });
  };

  PrometheusMetricFindQuery.prototype.queryResultQuery = function(query) {
    var end = this.datasource.getPrometheusTime(this.range.to, true);
    return this.datasource.performInstantQuery({ expr: query }, end)
    .then(function(result) {
      return _.map(result.data.data.result, function(metricData) {
        var text = metricData.metric.__name__ || '';
        delete metricData.metric.__name__;
        text += '{' +
                _.map(metricData.metric, function(v, k) { return k + '="' + v + '"'; }).join(',') +
                '}';
        text += ' ' + metricData.value[1] + ' ' + metricData.value[0] * 1000;

        return {
          text: text,
          expandable: true
        };
      });
    });
  };

  PrometheusMetricFindQuery.prototype.metricNameAndLabelsQuery = function(query) {
    var start = this.datasource.getPrometheusTime(this.range.from, false);
    var end = this.datasource.getPrometheusTime(this.range.to, true);
    var url = '/api/v1/series?match[]=' + encodeURIComponent(query)
      + '&start=' + start
      + '&end=' + end;

    var self = this;
    return this.datasource._request('GET', url)
    .then(function(result) {
      return _.map(result.data.data, function(metric) {
        return {
          text: self.datasource.getOriginalMetricName(metric),
          expandable: true
        };
      });
    });
  };

  return PrometheusMetricFindQuery;
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ 1477:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return PrometheusQueryCtrl; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_angular__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_angular___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_angular__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_lodash__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_app_plugins_sdk__ = __webpack_require__(1305);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__completer__ = __webpack_require__(1478);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__mode_prometheus__ = __webpack_require__(1479);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__mode_prometheus___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4__mode_prometheus__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__snippets_prometheus__ = __webpack_require__(1480);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__snippets_prometheus___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5__snippets_prometheus__);
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();






var PrometheusQueryCtrl = /** @class */ (function (_super) {
    __extends(PrometheusQueryCtrl, _super);
    /** @ngInject */
    PrometheusQueryCtrl.$inject = ["$scope", "$injector", "templateSrv"];
    function PrometheusQueryCtrl($scope, $injector, templateSrv) {
        var _this = _super.call(this, $scope, $injector) || this;
        _this.templateSrv = templateSrv;
        var target = _this.target;
        target.expr = target.expr || '';
        target.intervalFactor = target.intervalFactor || 2;
        target.format = target.format || _this.getDefaultFormat();
        _this.metric = '';
        _this.resolutions = __WEBPACK_IMPORTED_MODULE_1_lodash___default.a.map([1, 2, 3, 4, 5, 10], function (f) {
            return { factor: f, label: '1/' + f };
        });
        _this.formats = [
            { text: 'Time series', value: 'time_series' },
            { text: 'Table', value: 'table' },
        ];
        _this.instant = false;
        _this.updateLink();
        return _this;
    }
    PrometheusQueryCtrl.prototype.getCompleter = function (query) {
        return new __WEBPACK_IMPORTED_MODULE_3__completer__["a" /* PromCompleter */](this.datasource);
    };
    PrometheusQueryCtrl.prototype.getDefaultFormat = function () {
        if (this.panelCtrl.panel.type === 'table') {
            return 'table';
        }
        return 'time_series';
    };
    PrometheusQueryCtrl.prototype.refreshMetricData = function () {
        if (!__WEBPACK_IMPORTED_MODULE_1_lodash___default.a.isEqual(this.oldTarget, this.target)) {
            this.oldTarget = __WEBPACK_IMPORTED_MODULE_0_angular___default.a.copy(this.target);
            this.panelCtrl.refresh();
            this.updateLink();
        }
    };
    PrometheusQueryCtrl.prototype.updateLink = function () {
        var range = this.panelCtrl.range;
        if (!range) {
            return;
        }
        var rangeDiff = Math.ceil((range.to.valueOf() - range.from.valueOf()) / 1000);
        var endTime = range.to.utc().format('YYYY-MM-DD HH:mm');
        var expr = {
            'g0.expr': this.templateSrv.replace(this.target.expr, this.panelCtrl.panel.scopedVars, this.datasource.interpolateQueryExpr),
            'g0.range_input': rangeDiff + 's',
            'g0.end_input': endTime,
            'g0.step_input': this.target.step,
            'g0.stacked': this.panelCtrl.panel.stack ? 1 : 0,
            'g0.tab': 0
        };
        var args = __WEBPACK_IMPORTED_MODULE_1_lodash___default.a.map(expr, function (v, k) { return k + '=' + encodeURIComponent(v); }).join('&');
        this.linkToPrometheus = this.datasource.directUrl + '/graph?' + args;
    };
    PrometheusQueryCtrl.prototype.getCollapsedText = function () {
        return this.target.expr;
    };
    PrometheusQueryCtrl.templateUrl = 'partials/query.editor.html';
    return PrometheusQueryCtrl;
}(__WEBPACK_IMPORTED_MODULE_2_app_plugins_sdk__["QueryCtrl"]));



/***/ }),

/***/ 1478:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return PromCompleter; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_lodash__);
///<reference path="../../../headers/common.d.ts" />

var PromCompleter = /** @class */ (function () {
    function PromCompleter(datasource) {
        this.datasource = datasource;
        this.identifierRegexps = [/\[/, /[a-zA-Z0-9_:]/];
        this.labelQueryCache = {};
        this.labelNameCache = {};
        this.labelValueCache = {};
    }
    PromCompleter.prototype.getCompletions = function (editor, session, pos, prefix, callback) {
        var _this = this;
        var token = session.getTokenAt(pos.row, pos.column);
        var metricName;
        switch (token.type) {
            case 'entity.name.tag':
                metricName = this.findMetricName(session, pos.row, pos.column);
                if (!metricName) {
                    callback(null, this.transformToCompletions(['__name__', 'instance', 'job'], 'label name'));
                    return;
                }
                if (this.labelNameCache[metricName]) {
                    callback(null, this.labelNameCache[metricName]);
                    return;
                }
                return this.getLabelNameAndValueForMetric(metricName).then(function (result) {
                    var labelNames = _this.transformToCompletions(__WEBPACK_IMPORTED_MODULE_0_lodash___default.a.uniq(__WEBPACK_IMPORTED_MODULE_0_lodash___default.a.flatten(result.map(function (r) {
                        return Object.keys(r.metric);
                    }))), 'label name');
                    _this.labelNameCache[metricName] = labelNames;
                    callback(null, labelNames);
                });
            case 'string.quoted':
                metricName = this.findMetricName(session, pos.row, pos.column);
                if (!metricName) {
                    callback(null, []);
                    return;
                }
                var labelNameToken = this.findToken(session, pos.row, pos.column, 'entity.name.tag', null, 'paren.lparen');
                if (!labelNameToken) {
                    callback(null, []);
                    return;
                }
                var labelName = labelNameToken.value;
                if (this.labelValueCache[metricName] && this.labelValueCache[metricName][labelName]) {
                    callback(null, this.labelValueCache[metricName][labelName]);
                    return;
                }
                return this.getLabelNameAndValueForMetric(metricName).then(function (result) {
                    var labelValues = _this.transformToCompletions(__WEBPACK_IMPORTED_MODULE_0_lodash___default.a.uniq(result.map(function (r) {
                        return r.metric[labelName];
                    })), 'label value');
                    _this.labelValueCache[metricName] = _this.labelValueCache[metricName] || {};
                    _this.labelValueCache[metricName][labelName] = labelValues;
                    callback(null, labelValues);
                });
        }
        if (token.type === 'paren.lparen' && token.value === '[') {
            var vectors = [];
            for (var _i = 0, _a = ['s', 'm', 'h']; _i < _a.length; _i++) {
                var unit = _a[_i];
                for (var _b = 0, _c = [1, 5, 10, 30]; _b < _c.length; _b++) {
                    var value = _c[_b];
                    vectors.push({ caption: value + unit, value: '[' + value + unit, meta: 'range vector' });
                }
            }
            vectors.push({ caption: '$__interval', value: '[$__interval', meta: 'range vector' });
            vectors.push({ caption: '$__interval_ms', value: '[$__interval_ms', meta: 'range vector' });
            callback(null, vectors);
            return;
        }
        var query = prefix;
        return this.datasource.performSuggestQuery(query, true).then(function (metricNames) {
            callback(null, metricNames.map(function (name) {
                var value = name;
                if (prefix === '(') {
                    value = '(' + name;
                }
                return {
                    caption: name,
                    value: value,
                    meta: 'metric',
                };
            }));
        });
    };
    PromCompleter.prototype.getLabelNameAndValueForMetric = function (metricName) {
        var _this = this;
        if (this.labelQueryCache[metricName]) {
            return Promise.resolve(this.labelQueryCache[metricName]);
        }
        var op = '=~';
        if (/[a-zA-Z_:][a-zA-Z0-9_:]*/.test(metricName)) {
            op = '=';
        }
        var expr = '{__name__' + op + '"' + metricName + '"}';
        return this.datasource.performInstantQuery({ expr: expr }, new Date().getTime() / 1000).then(function (response) {
            _this.labelQueryCache[metricName] = response.data.data.result;
            return response.data.data.result;
        });
    };
    PromCompleter.prototype.transformToCompletions = function (words, meta) {
        return words.map(function (name) {
            return {
                caption: name,
                value: name,
                meta: meta,
                score: Number.MAX_VALUE
            };
        });
    };
    PromCompleter.prototype.findMetricName = function (session, row, column) {
        var metricName = '';
        var tokens;
        var nameLabelNameToken = this.findToken(session, row, column, 'entity.name.tag', '__name__', 'paren.lparen');
        if (nameLabelNameToken) {
            tokens = session.getTokens(nameLabelNameToken.row);
            var nameLabelValueToken = tokens[nameLabelNameToken.index + 2];
            if (nameLabelValueToken && nameLabelValueToken.type === 'string.quoted') {
                metricName = nameLabelValueToken.value.slice(1, -1); // cut begin/end quotation
            }
        }
        else {
            var metricNameToken = this.findToken(session, row, column, 'identifier', null, null);
            if (metricNameToken) {
                tokens = session.getTokens(metricNameToken.row);
                if (tokens[metricNameToken.index + 1].type === 'paren.lparen') {
                    metricName = metricNameToken.value;
                }
            }
        }
        return metricName;
    };
    PromCompleter.prototype.findToken = function (session, row, column, target, value, guard) {
        var tokens, idx;
        for (var r = row; r >= 0; r--) {
            tokens = session.getTokens(r);
            if (r === row) {
                var c = 0;
                for (idx = 0; idx < tokens.length; idx++) {
                    c += tokens[idx].value.length;
                    if (c >= column) {
                        break;
                    }
                }
            }
            else {
                idx = tokens.length - 1;
            }
            for (; idx >= 0; idx--) {
                if (tokens[idx].type === guard) {
                    return null;
                }
                if (tokens[idx].type === target
                    && (!value || tokens[idx].value === value)) {
                    tokens[idx].row = r;
                    tokens[idx].index = idx;
                    return tokens[idx];
                }
            }
        }
        return null;
    };
    return PromCompleter;
}());



/***/ }),

/***/ 1479:
/***/ (function(module, exports) {

// jshint ignore: start
// jscs: disable
ace.define("ace/mode/prometheus_highlight_rules",["require","exports","module","ace/lib/oop","ace/mode/text_highlight_rules"], function(require, exports, module) {
"use strict";

var oop = require("../lib/oop");
var TextHighlightRules = require("./text_highlight_rules").TextHighlightRules;

var PrometheusHighlightRules = function() {
  var keywords = (
    "by|without|keep_common|offset|bool|and|or|unless|ignoring|on|group_left|group_right|" +
    "count|count_values|min|max|avg|sum|stddev|stdvar|bottomk|topk|quantile"
  );

  var builtinConstants = (
    "true|false|null|__name__|job"
  );

  var builtinFunctions = (
    "abs|absent|ceil|changes|clamp_max|clamp_min|count_scalar|day_of_month|day_of_week|days_in_month|delta|deriv|" + "drop_common_labels|exp|floor|histogram_quantile|holt_winters|hour|idelta|increase|irate|label_replace|ln|log2|" +
    "log10|minute|month|predict_linear|rate|resets|round|scalar|sort|sort_desc|sqrt|time|vector|year|avg_over_time|" +
    "min_over_time|max_over_time|sum_over_time|count_over_time|quantile_over_time|stddev_over_time|stdvar_over_time"
  );

  var keywordMapper = this.createKeywordMapper({
    "support.function": builtinFunctions,
    "keyword": keywords,
    "constant.language": builtinConstants
  }, "identifier", true);

  this.$rules = {
    "start" : [ {
      token : "string", // single line
      regex : /"(?:[^"\\]|\\.)*?"/
    }, {
      token : "string", // string
      regex : "'.*?'"
    }, {
      token : "constant.numeric", // float
      regex : "[-]?\\d+(?:(?:\\.\\d*)?(?:[eE][+-]?\\d+)?)?\\b"
    }, {
      token : "constant.language", // time
      regex : "\\d+[smhdwy]"
    }, {
      token : keywordMapper,
      regex : "[a-zA-Z_:][a-zA-Z0-9_:]*"
    }, {
      token : "keyword.operator",
      regex : "\\+|\\-|\\*|\\/|%|\\^|==|!=|<=|>=|<|>"
    }, {
      token : "paren.lparen",
      regex : "[[(]"
    }, {
      token : "paren.lparen",
      regex : "{",
      next  : "start-label-matcher"
    }, {
      token : "paren.rparen",
      regex : "[\\])]"
    }, {
      token : "paren.rparen",
      regex : "}"
    }, {
      token : "text",
      regex : "\\s+"
    } ],
    "start-label-matcher" : [ {
      token : "entity.name.tag",
      regex : '[a-zA-Z_][a-zA-Z0-9_]*'
    }, {
      token : "keyword.operator",
      regex : '=~|=|!~|!='
    }, {
      token : "string.quoted",
      regex : '"[^"]*"|\'[^\']*\''
    }, {
      token : "punctuation.operator",
      regex : ","
    }, {
      token : "paren.rparen",
      regex : "}",
      next  : "start"
    } ]
  };

  this.normalizeRules();
};

oop.inherits(PrometheusHighlightRules, TextHighlightRules);

exports.PrometheusHighlightRules = PrometheusHighlightRules;
});

ace.define("ace/mode/prometheus_completions",["require","exports","module","ace/token_iterator", "ace/lib/lang"], function(require, exports, module) {
"use strict";

var lang = require("../lib/lang");

var prometheusKeyWords = [
  "by", "without", "keep_common", "offset", "bool", "and", "or", "unless", "ignoring", "on", "group_left",
  "group_right", "count", "count_values", "min", "max", "avg", "sum", "stddev", "stdvar", "bottomk", "topk", "quantile"
];

var keyWordsCompletions = prometheusKeyWords.map(function(word) {
  return {
    caption: word,
    value: word,
    meta: "keyword",
    score: Number.MAX_VALUE
  }
});

var prometheusFunctions = [
  {
    name: 'abs()', value: 'abs',
    def: 'abs(v instant-vector)',
    docText: 'Returns the input vector with all sample values converted to their absolute value.'
  },
  {
    name: 'absent()', value: 'absent',
    def: 'absent(v instant-vector)',
    docText: 'Returns an empty vector if the vector passed to it has any elements and a 1-element vector with the value 1 if the vector passed to it has no elements. This is useful for alerting on when no time series exist for a given metric name and label combination.'
  },
  {
    name: 'ceil()', value: 'ceil',
    def: 'ceil(v instant-vector)',
    docText: 'Rounds the sample values of all elements in `v` up to the nearest integer.'
  },
  {
    name: 'changes()', value: 'changes',
    def: 'changes(v range-vector)',
    docText: 'For each input time series, `changes(v range-vector)` returns the number of times its value has changed within the provided time range as an instant vector.'
  },
  {
    name: 'clamp_max()', value: 'clamp_max',
    def: 'clamp_max(v instant-vector, max scalar)',
    docText: 'Clamps the sample values of all elements in `v` to have an upper limit of `max`.'
  },
  {
    name: 'clamp_min()', value: 'clamp_min',
    def: 'clamp_min(v instant-vector, min scalar)',
    docText: 'Clamps the sample values of all elements in `v` to have a lower limit of `min`.'
  },
  {
    name: 'count_scalar()', value: 'count_scalar',
    def: 'count_scalar(v instant-vector)',
    docText: 'Returns the number of elements in a time series vector as a scalar. This is in contrast to the `count()` aggregation operator, which always returns a vector (an empty one if the input vector is empty) and allows grouping by labels via a `by` clause.'
  },
  {
    name: 'day_of_month()', value: 'day_of_month',
    def: 'day_of_month(v=vector(time()) instant-vector)',
    docText: 'Returns the day of the month for each of the given times in UTC. Returned values are from 1 to 31.'
  },
  {
    name: 'day_of_week()', value: 'day_of_week',
    def: 'day_of_week(v=vector(time()) instant-vector)',
    docText: 'Returns the day of the week for each of the given times in UTC. Returned values are from 0 to 6, where 0 means Sunday etc.'
  },
  {
    name: 'days_in_month()', value: 'days_in_month',
    def: 'days_in_month(v=vector(time()) instant-vector)',
    docText: 'Returns number of days in the month for each of the given times in UTC. Returned values are from 28 to 31.'
  },
  {
    name: 'delta()', value: 'delta',
    def: 'delta(v range-vector)',
    docText: 'Calculates the difference between the first and last value of each time series element in a range vector `v`, returning an instant vector with the given deltas and equivalent labels. The delta is extrapolated to cover the full time range as specified in the range vector selector, so that it is possible to get a non-integer result even if the sample values are all integers.'
  },
  {
    name: 'deriv()', value: 'deriv',
    def: 'deriv(v range-vector)',
    docText: 'Calculates the per-second derivative of the time series in a range vector `v`, using simple linear regression.'
  },
  {
    name: 'drop_common_labels()', value: 'drop_common_labels',
    def: 'drop_common_labels(instant-vector)',
    docText: 'Drops all labels that have the same name and value across all series in the input vector.'
  },
  {
    name: 'exp()', value: 'exp',
    def: 'exp(v instant-vector)',
    docText: 'Calculates the exponential function for all elements in `v`.\nSpecial cases are:\n* `Exp(+Inf) = +Inf` \n* `Exp(NaN) = NaN`'
  },
  {
    name: 'floor()', value: 'floor',
    def: 'floor(v instant-vector)',
    docText: 'Rounds the sample values of all elements in `v` down to the nearest integer.'
  },
  {
    name: 'histogram_quantile()', value: 'histogram_quantile',
    def: 'histogram_quantile( float, b instant-vector)',
    docText: 'Calculates the -quantile (0    1) from the buckets `b` of a histogram. The samples in `b` are the counts of observations in each bucket. Each sample must have a label `le` where the label value denotes the inclusive upper bound of the bucket. (Samples without such a label are silently ignored.) The histogram metric type automatically provides time series with the `_bucket` suffix and the appropriate labels.'
  },
  {
    name: 'holt_winters()', value: 'holt_winters',
    def: 'holt_winters(v range-vector, sf scalar, tf scalar)',
    docText: 'Produces a smoothed value for time series based on the range in `v`. The lower the smoothing factor `sf`, the more importance is given to old data. The higher the trend factor `tf`, the more trends in the data is considered. Both `sf` and `tf` must be between 0 and 1.'
  },
  {
    name: 'hour()', value: 'hour',
    def: 'hour(v=vector(time()) instant-vector)',
    docText: 'Returns the hour of the day for each of the given times in UTC. Returned values are from 0 to 23.'
  },
  {
    name: 'idelta()', value: 'idelta',
    def: 'idelta(v range-vector)',
    docText: 'Calculates the difference between the last two samples in the range vector `v`, returning an instant vector with the given deltas and equivalent labels.'
  },
  {
    name: 'increase()', value: 'increase',
    def: 'increase(v range-vector)',
    docText: 'Calculates the increase in the time series in the range vector. Breaks in monotonicity (such as counter resets due to target restarts) are automatically adjusted for. The increase is extrapolated to cover the full time range as specified in the range vector selector, so that it is possible to get a non-integer result even if a counter increases only by integer increments.'
  },
  {
    name: 'irate()', value: 'irate',
    def: 'irate(v range-vector)',
    docText: 'Calculates the per-second instant rate of increase of the time series in the range vector. This is based on the last two data points. Breaks in monotonicity (such as counter resets due to target restarts) are automatically adjusted for.'
  },
  {
    name: 'label_replace()', value: 'label_replace',
    def: 'label_replace(v instant-vector, dst_label string, replacement string, src_label string, regex string)',
    docText: 'For each timeseries in `v`, `label_replace(v instant-vector, dst_label string, replacement string, src_label string, regex string)`  matches the regular expression `regex` against the label `src_label`.  If it matches, then the timeseries is returned with the label `dst_label` replaced by the expansion of `replacement`. `$1` is replaced with the first matching subgroup, `$2` with the second etc. If the regular expression doesn\'t match then the timeseries is returned unchanged.'
  },
  {
    name: 'ln()', value: 'ln',
    def: 'ln(v instant-vector)',
    docText: 'calculates the natural logarithm for all elements in `v`.\nSpecial cases are:\n * `ln(+Inf) = +Inf`\n * `ln(0) = -Inf`\n * `ln(x < 0) = NaN`\n * `ln(NaN) = NaN`'
  },
  {
    name: 'log2()', value: 'log2',
    def: 'log2(v instant-vector)',
    docText: 'Calculates the binary logarithm for all elements in `v`. The special cases are equivalent to those in `ln`.'
  },
  {
    name: 'log10()', value: 'log10',
    def: 'log10(v instant-vector)',
    docText: 'Calculates the decimal logarithm for all elements in `v`. The special cases are equivalent to those in `ln`.'
  },
  {
    name: 'minute()', value: 'minute',
    def: 'minute(v=vector(time()) instant-vector)',
    docText: 'Returns the minute of the hour for each of the given times in UTC. Returned values are from 0 to 59.'
  },
  {
    name: 'month()', value: 'month',
    def: 'month(v=vector(time()) instant-vector)',
    docText: 'Returns the month of the year for each of the given times in UTC. Returned values are from 1 to 12, where 1 means January etc.'
  },
  {
    name: 'predict_linear()', value: 'predict_linear',
    def: 'predict_linear(v range-vector, t scalar)',
    docText: 'Predicts the value of time series `t` seconds from now, based on the range vector `v`, using simple linear regression.'
  },
  {
    name: 'rate()', value: 'rate',
    def: 'rate(v range-vector)',
    docText: "Calculates the per-second average rate of increase of the time series in the range vector. Breaks in monotonicity (such as counter resets due to target restarts) are automatically adjusted for. Also, the calculation extrapolates to the ends of the time range, allowing for missed scrapes or imperfect alignment of scrape cycles with the range's time period."
  },
  {
    name: 'resets()', value: 'resets',
    def: 'resets(v range-vector)',
    docText: 'For each input time series, `resets(v range-vector)` returns the number of counter resets within the provided time range as an instant vector. Any decrease in the value between two consecutive samples is interpreted as a counter reset.'
  },
  {
    name: 'round()', value: 'round',
    def: 'round(v instant-vector, to_nearest=1 scalar)',
    docText: 'Rounds the sample values of all elements in `v` to the nearest integer. Ties are resolved by rounding up. The optional `to_nearest` argument allows specifying the nearest multiple to which the sample values should be rounded. This multiple may also be a fraction.'
  },
  {
    name: 'scalar()', value: 'scalar',
    def: 'scalar(v instant-vector)',
    docText: 'Given a single-element input vector, `scalar(v instant-vector)` returns the sample value of that single element as a scalar. If the input vector does not have exactly one element, `scalar` will return `NaN`.'
  },
  {
    name: 'sort()', value: 'sort',
    def: 'sort(v instant-vector)',
    docText: 'Returns vector elements sorted by their sample values, in ascending order.'
  },
  {
    name: 'sort_desc()', value: 'sort_desc',
    def: 'sort_desc(v instant-vector)',
    docText: 'Returns vector elements sorted by their sample values, in descending order.'
  },
  {
    name: 'sqrt()', value: 'sqrt',
    def: 'sqrt(v instant-vector)',
    docText: 'Calculates the square root of all elements in `v`.'
  },
  {
    name: 'time()', value: 'time',
    def: 'time()',
    docText: 'Returns the number of seconds since January 1, 1970 UTC. Note that this does not actually return the current time, but the time at which the expression is to be evaluated.'
  },
  {
    name: 'vector()', value: 'vector',
    def: 'vector(s scalar)',
    docText: 'Returns the scalar `s` as a vector with no labels.'
  },
  {
    name: 'year()', value: 'year',
    def: 'year(v=vector(time()) instant-vector)',
    docText: 'Returns the year for each of the given times in UTC.'
  },
  {
    name: 'avg_over_time()', value: 'avg_over_time',
    def: 'avg_over_time(range-vector)',
    docText: 'The average value of all points in the specified interval.'
  },
  {
    name: 'min_over_time()', value: 'min_over_time',
    def: 'min_over_time(range-vector)',
    docText: 'The minimum value of all points in the specified interval.'
  },
  {
    name: 'max_over_time()', value: 'max_over_time',
    def: 'max_over_time(range-vector)',
    docText: 'The maximum value of all points in the specified interval.'
  },
  {
    name: 'sum_over_time()', value: 'sum_over_time',
    def: 'sum_over_time(range-vector)',
    docText: 'The sum of all values in the specified interval.'
  },
  {
    name: 'count_over_time()', value: 'count_over_time',
    def: 'count_over_time(range-vector)',
    docText: 'The count of all values in the specified interval.'
  },
  {
    name: 'quantile_over_time()', value: 'quantile_over_time',
    def: 'quantile_over_time(scalar, range-vector)',
    docText: 'The -quantile (0    1) of the values in the specified interval.'
  },
  {
    name: 'stddev_over_time()', value: 'stddev_over_time',
    def: 'stddev_over_time(range-vector)',
    docText: 'The population standard deviation of the values in the specified interval.'
  },
  {
    name: 'stdvar_over_time()', value: 'stdvar_over_time',
    def: 'stdvar_over_time(range-vector)',
    docText: 'The population standard variance of the values in the specified interval.'
  },
];

function wrapText(str, len) {
  len = len || 60;
  var lines = [];
  var space_index = 0;
  var line_start = 0;
  var next_line_end = len;
  var line = "";
  for (var i = 0; i < str.length; i++) {
    if (str[i] === ' ') {
      space_index = i;
    } else if (i >= next_line_end  && space_index != 0) {
      line = str.slice(line_start, space_index);
      lines.push(line);
      line_start = space_index + 1;
      next_line_end = i + len;
      space_index = 0;
    }
  }
  line = str.slice(line_start);
  lines.push(line);
  return lines.join("&nbsp<br>");
}

function convertMarkDownTags(text) {
  text = text.replace(/```(.+)```/, "<pre>$1</pre>");
  text = text.replace(/`([^`]+)`/, "<code>$1</code>");
  return text;
}

function convertToHTML(item) {
  var docText = lang.escapeHTML(item.docText);
  docText = convertMarkDownTags(wrapText(docText, 40));
  return [
    "<b>", lang.escapeHTML(item.def), "</b>", "<hr></hr>", docText, "<br>&nbsp"
  ].join("");
}

var functionsCompletions = prometheusFunctions.map(function(item) {
  return {
    caption: item.name,
    value: item.value,
    docHTML: convertToHTML(item),
    meta: "function",
    score: Number.MAX_VALUE
  };
});

var PrometheusCompletions = function() {};

(function() {
  this.getCompletions = function(state, session, pos, prefix, callback) {
    var token = session.getTokenAt(pos.row, pos.column);
    if (token.type === 'entity.name.tag' || token.type === 'string.quoted') {
      return callback(null, []);
    }

    var completions = keyWordsCompletions.concat(functionsCompletions);
    callback(null, completions);
  };

}).call(PrometheusCompletions.prototype);

exports.PrometheusCompletions = PrometheusCompletions;
});

ace.define("ace/mode/behaviour/prometheus",["require","exports","module","ace/lib/oop","ace/mode/behaviour","ace/mode/behaviour/cstyle","ace/token_iterator"], function(require, exports, module) {
"use strict";

var oop = require("../../lib/oop");
var Behaviour = require("../behaviour").Behaviour;
var CstyleBehaviour = require("./cstyle").CstyleBehaviour;
var TokenIterator = require("../../token_iterator").TokenIterator;

function getWrapped(selection, selected, opening, closing) {
  var rowDiff = selection.end.row - selection.start.row;
  return {
    text: opening + selected + closing,
    selection: [
      0,
      selection.start.column + 1,
      rowDiff,
      selection.end.column + (rowDiff ? 0 : 1)
    ]
  };
};

var PrometheusBehaviour = function () {
  this.inherit(CstyleBehaviour);

  // Rewrite default CstyleBehaviour for {} braces
  this.add("braces", "insertion", function(state, action, editor, session, text) {
    if (text == '{') {
      var selection = editor.getSelectionRange();
      var selected = session.doc.getTextRange(selection);
      if (selected !== "" && editor.getWrapBehavioursEnabled()) {
        return getWrapped(selection, selected, '{', '}');
      } else if (CstyleBehaviour.isSaneInsertion(editor, session)) {
        return {
          text: '{}',
          selection: [1, 1]
        };
      }
    } else if (text == '}') {
      var cursor = editor.getCursorPosition();
      var line = session.doc.getLine(cursor.row);
      var rightChar = line.substring(cursor.column, cursor.column + 1);
      if (rightChar == '}') {
        var matching = session.$findOpeningBracket('}', {column: cursor.column + 1, row: cursor.row});
        if (matching !== null && CstyleBehaviour.isAutoInsertedClosing(cursor, line, text)) {
          return {
            text: '',
            selection: [1, 1]
          };
        }
      }
    }
  });

  this.add("braces", "deletion", function(state, action, editor, session, range) {
    var selected = session.doc.getTextRange(range);
    if (!range.isMultiLine() && selected == '{') {
      var line = session.doc.getLine(range.start.row);
      var rightChar = line.substring(range.start.column + 1, range.start.column + 2);
      if (rightChar == '}') {
        range.end.column++;
        return range;
      }
    }
  });

}
oop.inherits(PrometheusBehaviour, CstyleBehaviour);

exports.PrometheusBehaviour = PrometheusBehaviour;
});

ace.define("ace/mode/prometheus",["require","exports","module","ace/lib/oop","ace/mode/text","ace/mode/prometheus_highlight_rules"], function(require, exports, module) {
"use strict";

var oop = require("../lib/oop");
var TextMode = require("./text").Mode;
var PrometheusHighlightRules = require("./prometheus_highlight_rules").PrometheusHighlightRules;
var PrometheusCompletions = require("./prometheus_completions").PrometheusCompletions;
var PrometheusBehaviour = require("./behaviour/prometheus").PrometheusBehaviour;

var Mode = function() {
  this.HighlightRules = PrometheusHighlightRules;
  this.$behaviour = new PrometheusBehaviour();
  this.$completer = new PrometheusCompletions();
  // replace keyWordCompleter
  this.completer = this.$completer;
};
oop.inherits(Mode, TextMode);

(function() {

  this.$id = "ace/mode/prometheus";
}).call(Mode.prototype);

exports.Mode = Mode;

});


/***/ }),

/***/ 1480:
/***/ (function(module, exports) {

// jshint ignore: start
// jscs: disable
ace.define("ace/snippets/prometheus",["require","exports","module"], function(require, exports, module) {
"use strict";

// exports.snippetText = "# rate\n\
// snippet r\n\
//   rate(${1:metric}[${2:range}])\n\
// ";

exports.snippets = [
  {
    "content": "rate(${1:metric}[${2:range}])",
    "name": "rate()",
    "scope": "prometheus",
    "tabTrigger": "r"
  }
];

exports.scope = "prometheus";
});


/***/ }),

/***/ 1481:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TextPanelCtrl", function() { return TextPanelCtrl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PanelCtrl", function() { return TextPanelCtrl; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_app_plugins_sdk__ = __webpack_require__(1305);
///<reference path="../../../headers/common.d.ts" />
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();


var TextPanelCtrl = /** @class */ (function (_super) {
    __extends(TextPanelCtrl, _super);
    /** @ngInject **/
    TextPanelCtrl.$inject = ["$scope", "$injector", "templateSrv", "$sce"];
    function TextPanelCtrl($scope, $injector, templateSrv, $sce) {
        var _this = _super.call(this, $scope, $injector) || this;
        _this.templateSrv = templateSrv;
        _this.$sce = $sce;
        // Set and populate defaults
        _this.panelDefaults = {
            mode: "markdown",
            content: "# title",
        };
        __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.defaults(_this.panel, _this.panelDefaults);
        _this.events.on('init-edit-mode', _this.onInitEditMode.bind(_this));
        _this.events.on('refresh', _this.onRefresh.bind(_this));
        _this.events.on('render', _this.onRender.bind(_this));
        $scope.$watch('ctrl.panel.content', __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.throttle(function () {
            _this.render();
        }, 1000));
        return _this;
    }
    TextPanelCtrl.prototype.onInitEditMode = function () {
        this.addEditorTab('Options', 'public/app/plugins/panel/text/editor.html');
        this.editorTabIndex = 1;
        if (this.panel.mode === 'text') {
            this.panel.mode = 'markdown';
        }
    };
    TextPanelCtrl.prototype.onRefresh = function () {
        this.render();
    };
    TextPanelCtrl.prototype.onRender = function () {
        if (this.panel.mode === 'markdown') {
            this.renderMarkdown(this.panel.content);
        }
        else if (this.panel.mode === 'html') {
            this.updateContent(this.panel.content);
        }
        this.renderingCompleted();
    };
    TextPanelCtrl.prototype.renderText = function (content) {
        content = content
            .replace(/&/g, '&amp;')
            .replace(/>/g, '&gt;')
            .replace(/</g, '&lt;')
            .replace(/\n/g, '<br/>');
        this.updateContent(content);
    };
    TextPanelCtrl.prototype.renderMarkdown = function (content) {
        var _this = this;
        if (!this.remarkable) {
            return new Promise(function(resolve) { resolve(); }).then(__webpack_require__.bind(null, 469)).then(function (Remarkable) {
                _this.remarkable = new Remarkable();
                _this.$scope.$apply(function () {
                    _this.updateContent(_this.remarkable.render(content));
                });
            });
        }
        this.$scope.$applyAsync(function () {
            _this.updateContent(_this.remarkable.render(content));
        });
    };
    TextPanelCtrl.prototype.updateContent = function (html) {
        try {
            this.content = this.$sce.trustAsHtml(this.templateSrv.replace(html, this.panel.scopedVars));
        }
        catch (e) {
            console.log('Text panel error: ', e);
            this.content = this.$sce.trustAsHtml(html);
        }
    };
    TextPanelCtrl.templateUrl = "public/app/plugins/panel/text/module.html";
    return TextPanelCtrl;
}(__WEBPACK_IMPORTED_MODULE_1_app_plugins_sdk__["PanelCtrl"]));




/***/ }),

/***/ 1482:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GraphCtrl", function() { return GraphCtrl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PanelCtrl", function() { return GraphCtrl; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__graph__ = __webpack_require__(1483);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__legend__ = __webpack_require__(1488);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__legend___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__legend__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__series_overrides_ctrl__ = __webpack_require__(1489);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__series_overrides_ctrl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2__series_overrides_ctrl__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__thresholds_form__ = __webpack_require__(1490);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__template__ = __webpack_require__(1491);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_lodash__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_app_core_config__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_app_plugins_sdk__ = __webpack_require__(1305);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__data_processor__ = __webpack_require__(1492);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__axes_editor__ = __webpack_require__(1493);
///<reference path="../../../headers/common.d.ts" />
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();










var GraphCtrl = /** @class */ (function (_super) {
    __extends(GraphCtrl, _super);
    /** @ngInject */
    GraphCtrl.$inject = ["$scope", "$injector", "annotationsSrv"];
    function GraphCtrl($scope, $injector, annotationsSrv) {
        var _this = _super.call(this, $scope, $injector) || this;
        _this.annotationsSrv = annotationsSrv;
        _this.hiddenSeries = {};
        _this.seriesList = [];
        _this.dataList = [];
        _this.annotations = [];
        _this.colors = [];
        _this.panelDefaults = {
            // datasource name, null = default datasource
            datasource: null,
            // sets client side (flot) or native graphite png renderer (png)
            renderer: 'flot',
            yaxes: [
                {
                    label: null,
                    show: true,
                    logBase: 1,
                    min: null,
                    max: null,
                    format: 'short'
                },
                {
                    label: null,
                    show: true,
                    logBase: 1,
                    min: null,
                    max: null,
                    format: 'short'
                }
            ],
            xaxis: {
                show: true,
                mode: 'time',
                name: null,
                values: [],
                buckets: null
            },
            // show/hide lines
            lines: true,
            // fill factor
            fill: 1,
            // line width in pixels
            linewidth: 1,
            // show/hide dashed line
            dashes: false,
            // length of a dash
            dashLength: 10,
            // length of space between two dashes
            spaceLength: 10,
            // show hide points
            points: false,
            // point radius in pixels
            pointradius: 5,
            // show hide bars
            bars: false,
            // enable/disable stacking
            stack: false,
            // stack percentage mode
            percentage: false,
            // legend options
            legend: {
                show: true,
                values: false,
                min: false,
                max: false,
                current: false,
                total: false,
                avg: false
            },
            // how null points should be handled
            nullPointMode: 'null',
            // staircase line mode
            steppedLine: false,
            // tooltip options
            tooltip: {
                value_type: 'individual',
                shared: true,
                sort: 0,
            },
            // time overrides
            timeFrom: null,
            timeShift: null,
            // metric queries
            targets: [{}],
            // series color overrides
            aliasColors: {},
            // other style overrides
            seriesOverrides: [],
            thresholds: [],
        };
        __WEBPACK_IMPORTED_MODULE_5_lodash___default.a.defaults(_this.panel, _this.panelDefaults);
        __WEBPACK_IMPORTED_MODULE_5_lodash___default.a.defaults(_this.panel.tooltip, _this.panelDefaults.tooltip);
        __WEBPACK_IMPORTED_MODULE_5_lodash___default.a.defaults(_this.panel.legend, _this.panelDefaults.legend);
        __WEBPACK_IMPORTED_MODULE_5_lodash___default.a.defaults(_this.panel.xaxis, _this.panelDefaults.xaxis);
        _this.processor = new __WEBPACK_IMPORTED_MODULE_8__data_processor__["a" /* DataProcessor */](_this.panel);
        _this.events.on('render', _this.onRender.bind(_this));
        _this.events.on('data-received', _this.onDataReceived.bind(_this));
        _this.events.on('data-error', _this.onDataError.bind(_this));
        _this.events.on('data-snapshot-load', _this.onDataSnapshotLoad.bind(_this));
        _this.events.on('init-edit-mode', _this.onInitEditMode.bind(_this));
        _this.events.on('init-panel-actions', _this.onInitPanelActions.bind(_this));
        return _this;
    }
    GraphCtrl.prototype.onInitEditMode = function () {
        this.addEditorTab('Axes', __WEBPACK_IMPORTED_MODULE_9__axes_editor__["a" /* axesEditorComponent */], 2);
        this.addEditorTab('Legend', 'public/app/plugins/panel/graph/tab_legend.html', 3);
        this.addEditorTab('Display', 'public/app/plugins/panel/graph/tab_display.html', 4);
        if (__WEBPACK_IMPORTED_MODULE_6_app_core_config__["default"].alertingEnabled) {
            this.addEditorTab('Alert', __WEBPACK_IMPORTED_MODULE_7_app_plugins_sdk__["alertTab"], 5);
        }
        this.subTabIndex = 0;
    };
    GraphCtrl.prototype.onInitPanelActions = function (actions) {
        actions.push({ text: 'Export CSV', click: 'ctrl.exportCsv()' });
        actions.push({ text: 'Toggle legend', click: 'ctrl.toggleLegend()' });
    };
    GraphCtrl.prototype.issueQueries = function (datasource) {
        this.annotationsPromise = this.annotationsSrv.getAnnotations({
            dashboard: this.dashboard,
            panel: this.panel,
            range: this.range,
        });
        return _super.prototype.issueQueries.call(this, datasource);
    };
    GraphCtrl.prototype.zoomOut = function (evt) {
        this.publishAppEvent('zoom-out', 2);
    };
    GraphCtrl.prototype.onDataSnapshotLoad = function (snapshotData) {
        this.annotationsPromise = this.annotationsSrv.getAnnotations({
            dashboard: this.dashboard,
            panel: this.panel,
            range: this.range,
        });
        this.onDataReceived(snapshotData);
    };
    GraphCtrl.prototype.onDataError = function (err) {
        this.seriesList = [];
        this.annotations = [];
        this.render([]);
    };
    GraphCtrl.prototype.onDataReceived = function (dataList) {
        var _this = this;
        this.dataList = dataList;
        this.seriesList = this.processor.getSeriesList({ dataList: dataList, range: this.range });
        this.dataWarning = null;
        var datapointsCount = this.seriesList.reduce(function (prev, series) {
            return prev + series.datapoints.length;
        }, 0);
        if (datapointsCount === 0) {
            this.dataWarning = {
                title: 'No data points',
                tip: 'No datapoints returned from data query'
            };
        }
        else {
            for (var _i = 0, _a = this.seriesList; _i < _a.length; _i++) {
                var series = _a[_i];
                if (series.isOutsideRange) {
                    this.dataWarning = {
                        title: 'Data points outside time range',
                        tip: 'Can be caused by timezone mismatch or missing time filter in query',
                    };
                    break;
                }
            }
        }
        this.annotationsPromise.then(function (result) {
            _this.loading = false;
            _this.alertState = result.alertState;
            _this.annotations = result.annotations;
            _this.render(_this.seriesList);
        }, function () {
            _this.loading = false;
            _this.render(_this.seriesList);
        });
    };
    GraphCtrl.prototype.onRender = function () {
        if (!this.seriesList) {
            return;
        }
        for (var _i = 0, _a = this.seriesList; _i < _a.length; _i++) {
            var series = _a[_i];
            series.applySeriesOverrides(this.panel.seriesOverrides);
            if (series.unit) {
                this.panel.yaxes[series.yaxis - 1].format = series.unit;
            }
        }
    };
    GraphCtrl.prototype.changeSeriesColor = function (series, color) {
        series.color = color;
        this.panel.aliasColors[series.alias] = series.color;
        this.render();
    };
    GraphCtrl.prototype.toggleSeries = function (serie, event) {
        if (event.ctrlKey || event.metaKey || event.shiftKey) {
            if (this.hiddenSeries[serie.alias]) {
                delete this.hiddenSeries[serie.alias];
            }
            else {
                this.hiddenSeries[serie.alias] = true;
            }
        }
        else {
            this.toggleSeriesExclusiveMode(serie);
        }
        this.render();
    };
    GraphCtrl.prototype.toggleSeriesExclusiveMode = function (serie) {
        var _this = this;
        var hidden = this.hiddenSeries;
        if (hidden[serie.alias]) {
            delete hidden[serie.alias];
        }
        // check if every other series is hidden
        var alreadyExclusive = __WEBPACK_IMPORTED_MODULE_5_lodash___default.a.every(this.seriesList, function (value) {
            if (value.alias === serie.alias) {
                return true;
            }
            return hidden[value.alias];
        });
        if (alreadyExclusive) {
            // remove all hidden series
            __WEBPACK_IMPORTED_MODULE_5_lodash___default.a.each(this.seriesList, function (value) {
                delete _this.hiddenSeries[value.alias];
            });
        }
        else {
            // hide all but this serie
            __WEBPACK_IMPORTED_MODULE_5_lodash___default.a.each(this.seriesList, function (value) {
                if (value.alias === serie.alias) {
                    return;
                }
                _this.hiddenSeries[value.alias] = true;
            });
        }
    };
    GraphCtrl.prototype.toggleAxis = function (info) {
        var override = __WEBPACK_IMPORTED_MODULE_5_lodash___default.a.find(this.panel.seriesOverrides, { alias: info.alias });
        if (!override) {
            override = { alias: info.alias };
            this.panel.seriesOverrides.push(override);
        }
        info.yaxis = override.yaxis = info.yaxis === 2 ? 1 : 2;
        this.render();
    };
    GraphCtrl.prototype.addSeriesOverride = function (override) {
        this.panel.seriesOverrides.push(override || {});
    };
    GraphCtrl.prototype.removeSeriesOverride = function (override) {
        this.panel.seriesOverrides = __WEBPACK_IMPORTED_MODULE_5_lodash___default.a.without(this.panel.seriesOverrides, override);
        this.render();
    };
    GraphCtrl.prototype.toggleLegend = function () {
        this.panel.legend.show = !this.panel.legend.show;
        this.refresh();
    };
    GraphCtrl.prototype.legendValuesOptionChanged = function () {
        var legend = this.panel.legend;
        legend.values = legend.min || legend.max || legend.avg || legend.current || legend.total;
        this.render();
    };
    GraphCtrl.prototype.exportCsv = function () {
        var scope = this.$scope.$new(true);
        scope.seriesList = this.seriesList;
        this.publishAppEvent('show-modal', {
            templateHtml: '<export-data-modal data="seriesList"></export-data-modal>',
            scope: scope,
            modalClass: 'modal--narrow'
        });
    };
    GraphCtrl.template = __WEBPACK_IMPORTED_MODULE_4__template__["a" /* default */];
    return GraphCtrl;
}(__WEBPACK_IMPORTED_MODULE_7_app_plugins_sdk__["MetricsPanelCtrl"]));



/***/ }),

/***/ 1483:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ 
graphDirective.$inject = ["$rootScope", "timeSrv", "popoverSrv", "contextSrv"];var __WEBPACK_IMPORTED_MODULE_0_vendor_flot_jquery_flot__ = __webpack_require__(1315);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_vendor_flot_jquery_flot___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_vendor_flot_jquery_flot__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_vendor_flot_jquery_flot_selection__ = __webpack_require__(1334);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_vendor_flot_jquery_flot_selection___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_vendor_flot_jquery_flot_selection__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_vendor_flot_jquery_flot_time__ = __webpack_require__(1335);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_vendor_flot_jquery_flot_time___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_vendor_flot_jquery_flot_time__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_vendor_flot_jquery_flot_stack__ = __webpack_require__(1336);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_vendor_flot_jquery_flot_stack___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_vendor_flot_jquery_flot_stack__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_vendor_flot_jquery_flot_stackpercent__ = __webpack_require__(1337);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_vendor_flot_jquery_flot_stackpercent___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_vendor_flot_jquery_flot_stackpercent__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_vendor_flot_jquery_flot_fillbelow__ = __webpack_require__(1338);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_vendor_flot_jquery_flot_fillbelow___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_vendor_flot_jquery_flot_fillbelow__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_vendor_flot_jquery_flot_crosshair__ = __webpack_require__(1339);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_vendor_flot_jquery_flot_crosshair___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6_vendor_flot_jquery_flot_crosshair__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_vendor_flot_jquery_flot_dashes__ = __webpack_require__(1340);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_vendor_flot_jquery_flot_dashes___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_7_vendor_flot_jquery_flot_dashes__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__jquery_flot_events__ = __webpack_require__(1484);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__jquery_flot_events___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_8__jquery_flot_events__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9_jquery__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9_jquery___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_9_jquery__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10_lodash__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_10_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11_moment__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11_moment___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_11_moment__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12_app_core_utils_kbn__ = __webpack_require__(464);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13_app_core_utils_ticks__ = __webpack_require__(1314);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14_app_core_core__ = __webpack_require__(465);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__graph_tooltip__ = __webpack_require__(1485);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__graph_tooltip___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_15__graph_tooltip__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__threshold_manager__ = __webpack_require__(1486);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17_app_features_annotations_all__ = __webpack_require__(1325);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18__histogram__ = __webpack_require__(1487);
///<reference path="../../../headers/common.d.ts" />



















/** @ngInject **/
function graphDirective($rootScope, timeSrv, popoverSrv, contextSrv) {
    return {
        restrict: 'A',
        template: '',
        link: function (scope, elem) {
            var ctrl = scope.ctrl;
            var dashboard = ctrl.dashboard;
            var panel = ctrl.panel;
            var annotations = [];
            var data;
            var plot;
            var sortedSeries;
            var legendSideLastValue = null;
            var rootScope = scope.$root;
            var panelWidth = 0;
            var eventManager = new __WEBPACK_IMPORTED_MODULE_17_app_features_annotations_all__["EventManager"](ctrl);
            var thresholdManager = new __WEBPACK_IMPORTED_MODULE_16__threshold_manager__["a" /* ThresholdManager */](ctrl);
            var tooltip = new __WEBPACK_IMPORTED_MODULE_15__graph_tooltip___default.a(elem, dashboard, scope, function () {
                return sortedSeries;
            });
            // panel events
            ctrl.events.on('panel-teardown', function () {
                thresholdManager = null;
                if (plot) {
                    plot.destroy();
                    plot = null;
                }
            });
            ctrl.events.on('render', function (renderData) {
                data = renderData || data;
                if (!data) {
                    return;
                }
                annotations = ctrl.annotations || [];
                render_panel();
            });
            // global events
            __WEBPACK_IMPORTED_MODULE_14_app_core_core__["appEvents"].on('graph-hover', function (evt) {
                // ignore other graph hover events if shared tooltip is disabled
                if (!dashboard.sharedTooltipModeEnabled()) {
                    return;
                }
                // ignore if we are the emitter
                if (!plot || evt.panel.id === panel.id || ctrl.otherPanelInFullscreenMode()) {
                    return;
                }
                tooltip.show(evt.pos);
            }, scope);
            __WEBPACK_IMPORTED_MODULE_14_app_core_core__["appEvents"].on('graph-hover-clear', function (event, info) {
                if (plot) {
                    tooltip.clear(plot);
                }
            }, scope);
            function getLegendHeight(panelHeight) {
                if (!panel.legend.show || panel.legend.rightSide) {
                    return 0;
                }
                if (panel.legend.alignAsTable) {
                    var legendSeries = __WEBPACK_IMPORTED_MODULE_10_lodash___default.a.filter(data, function (series) {
                        return series.hideFromLegend(panel.legend) === false;
                    });
                    var total = 23 + (21 * legendSeries.length);
                    return Math.min(total, Math.floor(panelHeight / 2));
                }
                else {
                    return 26;
                }
            }
            function setElementHeight() {
                try {
                    var height = ctrl.height - getLegendHeight(ctrl.height);
                    elem.css('height', height + 'px');
                    return true;
                }
                catch (e) {
                    console.log(e);
                    return false;
                }
            }
            function shouldAbortRender() {
                if (!data) {
                    return true;
                }
                if (!setElementHeight()) {
                    return true;
                }
                if (panelWidth === 0) {
                    return true;
                }
                return false;
            }
            function drawHook(plot) {
                // Update legend values
                var yaxis = plot.getYAxes();
                for (var i = 0; i < data.length; i++) {
                    var series = data[i];
                    var axis = yaxis[series.yaxis - 1];
                    var formater = __WEBPACK_IMPORTED_MODULE_12_app_core_utils_kbn__["default"].valueFormats[panel.yaxes[series.yaxis - 1].format];
                    // decimal override
                    if (__WEBPACK_IMPORTED_MODULE_10_lodash___default.a.isNumber(panel.decimals)) {
                        series.updateLegendValues(formater, panel.decimals, null);
                    }
                    else {
                        // auto decimals
                        // legend and tooltip gets one more decimal precision
                        // than graph legend ticks
                        var tickDecimals = (axis.tickDecimals || -1) + 1;
                        series.updateLegendValues(formater, tickDecimals, axis.scaledDecimals + 2);
                    }
                    if (!rootScope.$$phase) {
                        scope.$digest();
                    }
                }
                // add left axis labels
                if (panel.yaxes[0].label && panel.yaxes[0].show) {
                    __WEBPACK_IMPORTED_MODULE_9_jquery___default()("<div class='axisLabel left-yaxis-label flot-temp-elem'></div>").text(panel.yaxes[0].label).appendTo(elem);
                }
                // add right axis labels
                if (panel.yaxes[1].label && panel.yaxes[1].show) {
                    __WEBPACK_IMPORTED_MODULE_9_jquery___default()("<div class='axisLabel right-yaxis-label flot-temp-elem'></div>").text(panel.yaxes[1].label).appendTo(elem);
                }
                thresholdManager.draw(plot);
            }
            function processOffsetHook(plot, gridMargin) {
                var left = panel.yaxes[0];
                var right = panel.yaxes[1];
                if (left.show && left.label) {
                    gridMargin.left = 20;
                }
                if (right.show && right.label) {
                    gridMargin.right = 20;
                }
                // apply y-axis min/max options
                var yaxis = plot.getYAxes();
                for (var i = 0; i < yaxis.length; i++) {
                    var axis = yaxis[i];
                    var panelOptions = panel.yaxes[i];
                    axis.options.max = axis.options.max !== null ? axis.options.max : panelOptions.max;
                    axis.options.min = axis.options.min !== null ? axis.options.min : panelOptions.min;
                }
            }
            // Series could have different timeSteps,
            // let's find the smallest one so that bars are correctly rendered.
            // In addition, only take series which are rendered as bars for this.
            function getMinTimeStepOfSeries(data) {
                var min = Number.MAX_VALUE;
                for (var i = 0; i < data.length; i++) {
                    if (!data[i].stats.timeStep) {
                        continue;
                    }
                    if (panel.bars) {
                        if (data[i].bars && data[i].bars.show === false) {
                            continue;
                        }
                    }
                    else {
                        if (typeof data[i].bars === 'undefined' || typeof data[i].bars.show === 'undefined' || !data[i].bars.show) {
                            continue;
                        }
                    }
                    if (data[i].stats.timeStep < min) {
                        min = data[i].stats.timeStep;
                    }
                }
                return min;
            }
            // Function for rendering panel
            function render_panel() {
                panelWidth = elem.width();
                if (shouldAbortRender()) {
                    return;
                }
                // give space to alert editing
                thresholdManager.prepare(elem, data);
                // un-check dashes if lines are unchecked
                panel.dashes = panel.lines ? panel.dashes : false;
                var stack = panel.stack ? true : null;
                // Populate element
                var options = {
                    hooks: {
                        draw: [drawHook],
                        processOffset: [processOffsetHook],
                    },
                    legend: { show: false },
                    series: {
                        stackpercent: panel.stack ? panel.percentage : false,
                        stack: panel.percentage ? null : stack,
                        lines: {
                            show: panel.lines,
                            zero: false,
                            fill: translateFillOption(panel.fill),
                            lineWidth: panel.dashes ? 0 : panel.linewidth,
                            steps: panel.steppedLine
                        },
                        dashes: {
                            show: panel.dashes,
                            lineWidth: panel.linewidth,
                            dashLength: [panel.dashLength, panel.spaceLength]
                        },
                        bars: {
                            show: panel.bars,
                            fill: 1,
                            barWidth: 1,
                            zero: false,
                            lineWidth: 0
                        },
                        points: {
                            show: panel.points,
                            fill: 1,
                            fillColor: false,
                            radius: panel.points ? panel.pointradius : 2
                        },
                        shadowSize: 0
                    },
                    yaxes: [],
                    xaxis: {},
                    grid: {
                        minBorderMargin: 0,
                        markings: [],
                        backgroundColor: null,
                        borderWidth: 0,
                        hoverable: true,
                        clickable: true,
                        color: '#c8c8c8',
                        margin: { left: 0, right: 0 },
                        labelMarginX: 0,
                    },
                    selection: {
                        mode: "x",
                        color: '#666'
                    },
                    crosshair: {
                        mode: 'x'
                    }
                };
                for (var i = 0; i < data.length; i++) {
                    var series = data[i];
                    series.data = series.getFlotPairs(series.nullPointMode || panel.nullPointMode);
                    // if hidden remove points and disable stack
                    if (ctrl.hiddenSeries[series.alias]) {
                        series.data = [];
                        series.stack = false;
                    }
                }
                switch (panel.xaxis.mode) {
                    case 'series': {
                        options.series.bars.barWidth = 0.7;
                        options.series.bars.align = 'center';
                        for (var i = 0; i < data.length; i++) {
                            var series = data[i];
                            series.data = [[i + 1, series.stats[panel.xaxis.values[0]]]];
                        }
                        addXSeriesAxis(options);
                        break;
                    }
                    case 'histogram': {
                        var bucketSize = void 0;
                        var values = Object(__WEBPACK_IMPORTED_MODULE_18__histogram__["b" /* getSeriesValues */])(data);
                        if (data.length && values.length) {
                            var histMin = __WEBPACK_IMPORTED_MODULE_10_lodash___default.a.min(__WEBPACK_IMPORTED_MODULE_10_lodash___default.a.map(data, function (s) { return s.stats.min; }));
                            var histMax = __WEBPACK_IMPORTED_MODULE_10_lodash___default.a.max(__WEBPACK_IMPORTED_MODULE_10_lodash___default.a.map(data, function (s) { return s.stats.max; }));
                            var ticks = panel.xaxis.buckets || panelWidth / 50;
                            bucketSize = Object(__WEBPACK_IMPORTED_MODULE_13_app_core_utils_ticks__["tickStep"])(histMin, histMax, ticks);
                            var histogram = Object(__WEBPACK_IMPORTED_MODULE_18__histogram__["a" /* convertValuesToHistogram */])(values, bucketSize);
                            data[0].data = histogram;
                            options.series.bars.barWidth = bucketSize * 0.8;
                        }
                        else {
                            bucketSize = 0;
                        }
                        addXHistogramAxis(options, bucketSize);
                        break;
                    }
                    case 'table': {
                        options.series.bars.barWidth = 0.7;
                        options.series.bars.align = 'center';
                        addXTableAxis(options);
                        break;
                    }
                    default: {
                        options.series.bars.barWidth = getMinTimeStepOfSeries(data) / 1.5;
                        addTimeAxis(options);
                        break;
                    }
                }
                thresholdManager.addFlotOptions(options, panel);
                eventManager.addFlotEvents(annotations, options);
                configureAxisOptions(data, options);
                sortedSeries = sortSeries(data, ctrl.panel);
                function callPlot(incrementRenderCounter) {
                    try {
                        plot = __WEBPACK_IMPORTED_MODULE_9_jquery___default.a.plot(elem, sortedSeries, options);
                        if (ctrl.renderError) {
                            delete ctrl.error;
                            delete ctrl.inspector;
                        }
                    }
                    catch (e) {
                        console.log('flotcharts error', e);
                        ctrl.error = e.message || "Render Error";
                        ctrl.renderError = true;
                        ctrl.inspector = { error: e };
                    }
                    if (incrementRenderCounter) {
                        ctrl.renderingCompleted();
                    }
                }
                if (shouldDelayDraw(panel)) {
                    // temp fix for legends on the side, need to render twice to get dimensions right
                    callPlot(false);
                    setTimeout(function () { callPlot(true); }, 50);
                    legendSideLastValue = panel.legend.rightSide;
                }
                else {
                    callPlot(true);
                }
            }
            function sortSeries(series, panel) {
                var sortBy = panel.legend.sort;
                var sortOrder = panel.legend.sortDesc;
                var haveSortBy = sortBy !== null || sortBy !== undefined;
                var haveSortOrder = sortOrder !== null || sortOrder !== undefined;
                if (panel.stack && haveSortBy && haveSortOrder) {
                    var desc = desc = panel.legend.sortDesc === true ? -1 : 1;
                    series.sort(function (x, y) {
                        if (x.stats[sortBy] > y.stats[sortBy]) {
                            return 1 * desc;
                        }
                        if (x.stats[sortBy] < y.stats[sortBy]) {
                            return -1 * desc;
                        }
                        return 0;
                    });
                }
                series.sort(function (x, y) {
                    if (x.zindex > y.zindex) {
                        return 1;
                    }
                    if (x.zindex < y.zindex) {
                        return -1;
                    }
                    return 0;
                });
                return series;
            }
            function translateFillOption(fill) {
                if (panel.percentage && panel.stack) {
                    return fill === 0 ? 0.001 : fill / 10;
                }
                else {
                    return fill / 10;
                }
            }
            function shouldDelayDraw(panel) {
                if (panel.legend.rightSide) {
                    return true;
                }
                if (legendSideLastValue !== null && panel.legend.rightSide !== legendSideLastValue) {
                    return true;
                }
                return false;
            }
            function addTimeAxis(options) {
                var ticks = panelWidth / 100;
                var min = __WEBPACK_IMPORTED_MODULE_10_lodash___default.a.isUndefined(ctrl.range.from) ? null : ctrl.range.from.valueOf();
                var max = __WEBPACK_IMPORTED_MODULE_10_lodash___default.a.isUndefined(ctrl.range.to) ? null : ctrl.range.to.valueOf();
                options.xaxis = {
                    timezone: dashboard.getTimezone(),
                    show: panel.xaxis.show,
                    mode: "time",
                    min: min,
                    max: max,
                    label: "Datetime",
                    ticks: ticks,
                    timeformat: time_format(ticks, min, max),
                };
            }
            function addXSeriesAxis(options) {
                var ticks = __WEBPACK_IMPORTED_MODULE_10_lodash___default.a.map(data, function (series, index) {
                    return [index + 1, series.alias];
                });
                options.xaxis = {
                    timezone: dashboard.getTimezone(),
                    show: panel.xaxis.show,
                    mode: null,
                    min: 0,
                    max: ticks.length + 1,
                    label: "Datetime",
                    ticks: ticks
                };
            }
            function addXHistogramAxis(options, bucketSize) {
                var ticks, min, max;
                var defaultTicks = panelWidth / 50;
                if (data.length && bucketSize) {
                    ticks = __WEBPACK_IMPORTED_MODULE_10_lodash___default.a.map(data[0].data, function (point) { return point[0]; });
                    min = __WEBPACK_IMPORTED_MODULE_10_lodash___default.a.min(ticks);
                    max = __WEBPACK_IMPORTED_MODULE_10_lodash___default.a.max(ticks);
                    // Adjust tick step
                    var tickStep_1 = bucketSize;
                    var ticks_num = Math.floor((max - min) / tickStep_1);
                    while (ticks_num > defaultTicks) {
                        tickStep_1 = tickStep_1 * 2;
                        ticks_num = Math.ceil((max - min) / tickStep_1);
                    }
                    // Expand ticks for pretty view
                    min = Math.floor(min / tickStep_1) * tickStep_1;
                    max = Math.ceil(max / tickStep_1) * tickStep_1;
                    ticks = [];
                    for (var i = min; i <= max; i += tickStep_1) {
                        ticks.push(i);
                    }
                }
                else {
                    // Set defaults if no data
                    ticks = defaultTicks / 2;
                    min = 0;
                    max = 1;
                }
                options.xaxis = {
                    timezone: dashboard.getTimezone(),
                    show: panel.xaxis.show,
                    mode: null,
                    min: min,
                    max: max,
                    label: "Histogram",
                    ticks: ticks
                };
                // Use 'short' format for histogram values
                configureAxisMode(options.xaxis, 'short');
            }
            function addXTableAxis(options) {
                var ticks = __WEBPACK_IMPORTED_MODULE_10_lodash___default.a.map(data, function (series, seriesIndex) {
                    return __WEBPACK_IMPORTED_MODULE_10_lodash___default.a.map(series.datapoints, function (point, pointIndex) {
                        var tickIndex = seriesIndex * series.datapoints.length + pointIndex;
                        return [tickIndex + 1, point[1]];
                    });
                });
                ticks = __WEBPACK_IMPORTED_MODULE_10_lodash___default.a.flatten(ticks, true);
                options.xaxis = {
                    timezone: dashboard.getTimezone(),
                    show: panel.xaxis.show,
                    mode: null,
                    min: 0,
                    max: ticks.length + 1,
                    label: "Datetime",
                    ticks: ticks
                };
            }
            function configureAxisOptions(data, options) {
                var defaults = {
                    position: 'left',
                    show: panel.yaxes[0].show,
                    index: 1,
                    logBase: panel.yaxes[0].logBase || 1,
                    min: parseNumber(panel.yaxes[0].min),
                    max: parseNumber(panel.yaxes[0].max),
                    tickDecimals: panel.yaxes[0].decimals
                };
                options.yaxes.push(defaults);
                if (__WEBPACK_IMPORTED_MODULE_10_lodash___default.a.find(data, { yaxis: 2 })) {
                    var secondY = __WEBPACK_IMPORTED_MODULE_10_lodash___default.a.clone(defaults);
                    secondY.index = 2;
                    secondY.show = panel.yaxes[1].show;
                    secondY.logBase = panel.yaxes[1].logBase || 1;
                    secondY.position = 'right';
                    secondY.min = parseNumber(panel.yaxes[1].min);
                    secondY.max = parseNumber(panel.yaxes[1].max);
                    secondY.tickDecimals = panel.yaxes[1].decimals;
                    options.yaxes.push(secondY);
                    applyLogScale(options.yaxes[1], data);
                    configureAxisMode(options.yaxes[1], panel.percentage && panel.stack ? "percent" : panel.yaxes[1].format);
                }
                applyLogScale(options.yaxes[0], data);
                configureAxisMode(options.yaxes[0], panel.percentage && panel.stack ? "percent" : panel.yaxes[0].format);
            }
            function parseNumber(value) {
                if (value === null || typeof value === 'undefined') {
                    return null;
                }
                return __WEBPACK_IMPORTED_MODULE_10_lodash___default.a.toNumber(value);
            }
            function applyLogScale(axis, data) {
                if (axis.logBase === 1) {
                    return;
                }
                var minSetToZero = axis.min === 0;
                if (axis.min < Number.MIN_VALUE) {
                    axis.min = null;
                }
                if (axis.max < Number.MIN_VALUE) {
                    axis.max = null;
                }
                var series, i;
                var max = axis.max, min = axis.min;
                for (i = 0; i < data.length; i++) {
                    series = data[i];
                    if (series.yaxis === axis.index) {
                        if (!max || max < series.stats.max) {
                            max = series.stats.max;
                        }
                        if (!min || min > series.stats.logmin) {
                            min = series.stats.logmin;
                        }
                    }
                }
                axis.transform = function (v) { return (v < Number.MIN_VALUE) ? null : Math.log(v) / Math.log(axis.logBase); };
                axis.inverseTransform = function (v) { return Math.pow(axis.logBase, v); };
                if (!max && !min) {
                    max = axis.inverseTransform(+2);
                    min = axis.inverseTransform(-2);
                }
                else if (!max) {
                    max = min * axis.inverseTransform(+4);
                }
                else if (!min) {
                    min = max * axis.inverseTransform(-4);
                }
                if (axis.min) {
                    min = axis.inverseTransform(Math.ceil(axis.transform(axis.min)));
                }
                else {
                    min = axis.min = axis.inverseTransform(Math.floor(axis.transform(min)));
                }
                if (axis.max) {
                    max = axis.inverseTransform(Math.floor(axis.transform(axis.max)));
                }
                else {
                    max = axis.max = axis.inverseTransform(Math.ceil(axis.transform(max)));
                }
                if (!min || min < Number.MIN_VALUE || !max || max < Number.MIN_VALUE) {
                    return;
                }
                if (Number.isFinite(min) && Number.isFinite(max)) {
                    if (minSetToZero) {
                        axis.min = 0.1;
                        min = 1;
                    }
                    axis.ticks = generateTicksForLogScaleYAxis(min, max, axis.logBase);
                    if (minSetToZero) {
                        axis.ticks.unshift(0.1);
                    }
                    if (axis.ticks[axis.ticks.length - 1] > axis.max) {
                        axis.max = axis.ticks[axis.ticks.length - 1];
                    }
                }
                else {
                    axis.ticks = [1, 2];
                    delete axis.min;
                    delete axis.max;
                }
            }
            function generateTicksForLogScaleYAxis(min, max, logBase) {
                var ticks = [];
                var nextTick;
                for (nextTick = min; nextTick <= max; nextTick *= logBase) {
                    ticks.push(nextTick);
                }
                var maxNumTicks = Math.ceil(ctrl.height / 25);
                var numTicks = ticks.length;
                if (numTicks > maxNumTicks) {
                    var factor = Math.ceil(numTicks / maxNumTicks) * logBase;
                    ticks = [];
                    for (nextTick = min; nextTick <= (max * factor); nextTick *= factor) {
                        ticks.push(nextTick);
                    }
                }
                return ticks;
            }
            function configureAxisMode(axis, format) {
                axis.tickFormatter = function (val, axis) {
                    return __WEBPACK_IMPORTED_MODULE_12_app_core_utils_kbn__["default"].valueFormats[format](val, axis.tickDecimals, axis.scaledDecimals);
                };
            }
            function time_format(ticks, min, max) {
                if (min && max && ticks) {
                    var range = max - min;
                    var secPerTick = (range / ticks) / 1000;
                    var oneDay = 86400000;
                    var oneYear = 31536000000;
                    if (secPerTick <= 45) {
                        return "%H:%M:%S";
                    }
                    if (secPerTick <= 7200 || range <= oneDay) {
                        return "%H:%M";
                    }
                    if (secPerTick <= 80000) {
                        return "%m/%d %H:%M";
                    }
                    if (secPerTick <= 2419200 || range <= oneYear) {
                        return "%m/%d";
                    }
                    return "%Y-%m";
                }
                return "%H:%M";
            }
            elem.bind("plotselected", function (event, ranges) {
                if ((ranges.ctrlKey || ranges.metaKey) && contextSrv.isEditor) {
                    setTimeout(function () {
                        eventManager.updateTime(ranges.xaxis);
                    }, 100);
                }
                else {
                    scope.$apply(function () {
                        timeSrv.setTime({
                            from: __WEBPACK_IMPORTED_MODULE_11_moment___default.a.utc(ranges.xaxis.from),
                            to: __WEBPACK_IMPORTED_MODULE_11_moment___default.a.utc(ranges.xaxis.to),
                        });
                    });
                }
            });
            elem.bind("plotclick", function (event, pos, item) {
                if ((pos.ctrlKey || pos.metaKey) && contextSrv.isEditor) {
                    // Skip if range selected (added in "plotselected" event handler)
                    var isRangeSelection = pos.x !== pos.x1;
                    if (!isRangeSelection) {
                        setTimeout(function () {
                            eventManager.updateTime({ from: pos.x, to: null });
                        }, 100);
                    }
                }
            });
            scope.$on('$destroy', function () {
                tooltip.destroy();
                elem.off();
                elem.remove();
            });
        }
    };
}
__WEBPACK_IMPORTED_MODULE_14_app_core_core__["coreModule"].directive('grafanaGraph', graphDirective);


/***/ }),

/***/ 1484:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
  __webpack_require__(13),
  __webpack_require__(7),
  __webpack_require__(12),
  __webpack_require__(79),
], __WEBPACK_AMD_DEFINE_RESULT__ = function ($, _, angular, Drop) {
  'use strict';

  function createAnnotationToolip(element, event, plot) {
    var injector = angular.element(document).injector();
    var content = document.createElement('div');
    content.innerHTML = '<annotation-tooltip event="event" on-edit="onEdit()"></annotation-tooltip>';

    injector.invoke(["$compile", "$rootScope", function($compile, $rootScope) {
      var eventManager = plot.getOptions().events.manager;
      var tmpScope = $rootScope.$new(true);
      tmpScope.event = event;
      tmpScope.onEdit = function() {
        eventManager.editEvent(event);
      };

      $compile(content)(tmpScope);
      tmpScope.$digest();
      tmpScope.$destroy();

      var drop = new Drop({
        target: element[0],
        content: content,
        position: "bottom center",
        classes: 'drop-popover drop-popover--annotation',
        openOn: 'hover',
        hoverCloseDelay: 200,
        tetherOptions: {
          constraints: [{to: 'window', pin: true, attachment: "both"}]
        }
      });

      drop.open();

      drop.on('close', function() {
        setTimeout(function() {
          drop.destroy();
        });
      });
    }]);
  }

  var markerElementToAttachTo = null;

  function createEditPopover(element, event, plot) {
    var eventManager = plot.getOptions().events.manager;
    if (eventManager.editorOpen) {
      // update marker element to attach to (needed in case of legend on the right
      // when there is a double render pass and the inital marker element is removed)
      markerElementToAttachTo = element;
      return;
    }

    // mark as openend
    eventManager.editorOpened();
    // set marker elment to attache to
    markerElementToAttachTo = element;

    // wait for element to be attached and positioned
    setTimeout(function() {

      var injector = angular.element(document).injector();
      var content = document.createElement('div');
      content.innerHTML = '<event-editor panel-ctrl="panelCtrl" event="event" close="close()"></event-editor>';

      injector.invoke(["$compile", "$rootScope", function($compile, $rootScope) {
        var scope = $rootScope.$new(true);
        var drop;

        scope.event = event;
        scope.panelCtrl = eventManager.panelCtrl;
        scope.close = function() {
          drop.close();
        };

        $compile(content)(scope);
        scope.$digest();

        drop = new Drop({
          target: markerElementToAttachTo[0],
          content: content,
          position: "bottom center",
          classes: 'drop-popover drop-popover--form',
          openOn: 'click',
          tetherOptions: {
            constraints: [{to: 'window', pin: true, attachment: "both"}]
          }
        });

        drop.open();
        eventManager.editorOpened();

        drop.on('close', function() {
          // need timeout here in order call drop.destroy
          setTimeout(function() {
            eventManager.editorClosed();
            scope.$destroy();
            drop.destroy();
          });
        });
      }]);

    }, 100);
  }

  /*
   * jquery.flot.events
   *
   * description: Flot plugin for adding events/markers to the plot
   * version: 0.2.5
   * authors:
   *    Alexander Wunschik <alex@wunschik.net>
   *    Joel Oughton <joeloughton@gmail.com>
   *    Nicolas Joseph <www.nicolasjoseph.com>
   *
   * website: https://github.com/mojoaxel/flot-events
   *
   * released under MIT License and GPLv2+
   */

  /**
   * A class that allows for the drawing an remove of some object
   */
  var DrawableEvent = function(object, drawFunc, clearFunc, moveFunc, left, top, width, height) {
    var _object = object;
    var	_drawFunc = drawFunc;
    var	_clearFunc = clearFunc;
    var	_moveFunc = moveFunc;
    var	_position = { left: left, top: top };
    var	_width = width;
    var	_height = height;

    this.width = function() { return _width; };
    this.height = function() { return _height; };
    this.position = function() { return _position; };
    this.draw = function() { _drawFunc(_object); };
    this.clear = function() { _clearFunc(_object); };
    this.getObject = function() { return _object; };
    this.moveTo = function(position) {
      _position = position;
      _moveFunc(_object, _position);
    };
  };

  /**
   * Event class that stores options (eventType, min, max, title, description) and the object to draw.
   */
  var VisualEvent = function(options, drawableEvent) {
    var _parent;
    var _options = options;
    var _drawableEvent = drawableEvent;
    var _hidden = false;

    this.visual = function() { return _drawableEvent; };
    this.getOptions = function() { return _options; };
    this.getParent = function() { return _parent; };
    this.isHidden = function() { return _hidden; };
    this.hide = function() { _hidden = true; };
    this.unhide = function() { _hidden = false; };
  };

  /**
   * A Class that handles the event-markers inside the given plot
   */
  var EventMarkers = function(plot) {
    var _events = [];

    this._types = [];
    this._plot = plot;
    this.eventsEnabled = false;

    this.getEvents = function() {
      return _events;
    };

    this.setTypes = function(types) {
      return this._types = types;
    };

    /**
     * create internal objects for the given events
     */
    this.setupEvents = function(events) {
      var that = this;
      var parts = _.partition(events, 'isRegion');
      var regions = parts[0];
      events = parts[1];

      $.each(events, function(index, event) {
        var ve = new VisualEvent(event, that._buildDiv(event));
        _events.push(ve);
      });

      $.each(regions, function (index, event) {
        var vre = new VisualEvent(event, that._buildRegDiv(event));
        _events.push(vre);
      });

      _events.sort(function(a, b) {
        var ao = a.getOptions(), bo = b.getOptions();
        if (ao.min > bo.min) { return 1; }
        if (ao.min < bo.min) { return -1; }
        return 0;
      });
    };

    /**
     * draw the events to the plot
     */
    this.drawEvents = function() {
      var that = this;
      // var o = this._plot.getPlotOffset();

      $.each(_events, function(index, event) {
        // check event is inside the graph range
        if (that._insidePlot(event.getOptions().min) && !event.isHidden()) {
          event.visual().draw();
        }  else {
          event.visual().getObject().hide();
        }
      });
    };

    /**
     * update the position of the event-markers (e.g. after scrolling or zooming)
     */
    this.updateEvents = function() {
      var that = this;
      var o = this._plot.getPlotOffset(), left, top;
      var xaxis = this._plot.getXAxes()[this._plot.getOptions().events.xaxis - 1];

      $.each(_events, function(index, event) {
        top = o.top + that._plot.height() - event.visual().height();
        left = xaxis.p2c(event.getOptions().min) + o.left - event.visual().width() / 2;
        event.visual().moveTo({ top: top, left: left });
      });
    };

    /**
     * remove all events from the plot
     */
    this._clearEvents = function() {
      $.each(_events, function(index, val) {
        val.visual().clear();
      });
      _events = [];
    };

    /**
     * create a DOM element for the given event
     */
    this._buildDiv = function(event) {
      var that = this;

      var container = this._plot.getPlaceholder();
      var o = this._plot.getPlotOffset();
      var axes = this._plot.getAxes();
      var xaxis = this._plot.getXAxes()[this._plot.getOptions().events.xaxis - 1];
      var yaxis, top, left, color, markerSize, markerShow, lineStyle, lineWidth;
      var markerTooltip;

      // determine the y axis used
      if (axes.yaxis && axes.yaxis.used) { yaxis = axes.yaxis; }
      if (axes.yaxis2 && axes.yaxis2.used) { yaxis = axes.yaxis2; }

      // map the eventType to a types object
      var eventTypeId = event.eventType;

      if (this._types === null || !this._types[eventTypeId] || !this._types[eventTypeId].color) {
        color = '#666';
      } else {
        color = this._types[eventTypeId].color;
      }

      if (this._types === null || !this._types[eventTypeId] || !this._types[eventTypeId].markerSize) {
        markerSize = 8; //default marker size
      } else {
        markerSize = this._types[eventTypeId].markerSize;
      }

      if (this._types === null || !this._types[eventTypeId] || this._types[eventTypeId].markerShow === undefined) {
        markerShow = true;
      } else {
        markerShow = this._types[eventTypeId].markerShow;
      }

      if (this._types === null || !this._types[eventTypeId] || this._types[eventTypeId].markerTooltip === undefined) {
        markerTooltip = true;
      } else {
        markerTooltip = this._types[eventTypeId].markerTooltip;
      }

      if (this._types == null || !this._types[eventTypeId] || !this._types[eventTypeId].lineStyle) {
        lineStyle = 'dashed'; //default line style
      } else {
        lineStyle = this._types[eventTypeId].lineStyle.toLowerCase();
      }

      if (this._types == null || !this._types[eventTypeId] || this._types[eventTypeId].lineWidth === undefined) {
        lineWidth = 1; //default line width
      } else {
        lineWidth = this._types[eventTypeId].lineWidth;
      }

      var topOffset = xaxis.options.eventSectionHeight || 0;
      topOffset = topOffset / 3;

      top = o.top + this._plot.height() + topOffset;
      left = xaxis.p2c(event.min) + o.left;

      var line = $('<div class="events_line flot-temp-elem"></div>').css({
        "position": "absolute",
        "opacity": 0.8,
        "left": left + 'px',
        "top": 8,
        "width": lineWidth + "px",
        "height": this._plot.height() + topOffset * 0.8,
        "border-left-width": lineWidth + "px",
        "border-left-style": lineStyle,
        "border-left-color": color,
        "color": color
      })
      .appendTo(container);

      if (markerShow) {
        var marker = $('<div class="events_marker"></div>').css({
          "position": "absolute",
          "left": (-markerSize - Math.round(lineWidth / 2)) + "px",
          "font-size": 0,
          "line-height": 0,
          "width": 0,
          "height": 0,
          "border-left": markerSize+"px solid transparent",
          "border-right": markerSize+"px solid transparent"
        });

        marker.appendTo(line);

        if (this._types[eventTypeId] && this._types[eventTypeId].position && this._types[eventTypeId].position.toUpperCase() === 'BOTTOM') {
          marker.css({
            "top": top-markerSize-8 +"px",
            "border-top": "none",
            "border-bottom": markerSize+"px solid " + color
          });
        } else {
          marker.css({
            "top": "0px",
            "border-top": markerSize+"px solid " + color,
            "border-bottom": "none"
          });
        }

        marker.data({
          "event": event
        });

        var mouseenter = function() {
          createAnnotationToolip(marker, $(this).data("event"), that._plot);
        };

        if (event.editModel) {
          createEditPopover(marker, event.editModel, that._plot);
        }

        var mouseleave = function() {
          that._plot.clearSelection();
        };

        if (markerTooltip) {
          marker.css({ "cursor": "help" });
          marker.hover(mouseenter, mouseleave);
        }
      }

      var drawableEvent = new DrawableEvent(
        line,
        function drawFunc(obj) { obj.show(); },
        function(obj) { obj.remove(); },
        function(obj, position) {
          obj.css({
            top: position.top,
            left: position.left
          });
        },
        left,
        top,
        line.width(),
        line.height()
      );

      return drawableEvent;
    };

    /**
     * create a DOM element for the given region
     */
    this._buildRegDiv = function (event) {
      var that = this;

      var container = this._plot.getPlaceholder();
      var o = this._plot.getPlotOffset();
      var axes = this._plot.getAxes();
      var xaxis = this._plot.getXAxes()[this._plot.getOptions().events.xaxis - 1];
      var yaxis, top, left, lineWidth, regionWidth, lineStyle, color, markerTooltip;

      // determine the y axis used
      if (axes.yaxis && axes.yaxis.used) { yaxis = axes.yaxis; }
      if (axes.yaxis2 && axes.yaxis2.used) { yaxis = axes.yaxis2; }

      // map the eventType to a types object
      var eventTypeId = event.eventType;

      if (this._types === null || !this._types[eventTypeId] || !this._types[eventTypeId].color) {
        color = '#666';
      } else {
        color = this._types[eventTypeId].color;
      }

      if (this._types === null || !this._types[eventTypeId] || this._types[eventTypeId].markerTooltip === undefined) {
        markerTooltip = true;
      } else {
        markerTooltip = this._types[eventTypeId].markerTooltip;
      }

      if (this._types == null || !this._types[eventTypeId] || this._types[eventTypeId].lineWidth === undefined) {
        lineWidth = 1; //default line width
      } else {
        lineWidth = this._types[eventTypeId].lineWidth;
      }

      if (this._types == null || !this._types[eventTypeId] || !this._types[eventTypeId].lineStyle) {
        lineStyle = 'dashed'; //default line style
      } else {
        lineStyle = this._types[eventTypeId].lineStyle.toLowerCase();
      }

      var topOffset = 2;
      top = o.top + this._plot.height() + topOffset;

      var timeFrom = Math.min(event.min, event.timeEnd);
      var timeTo = Math.max(event.min, event.timeEnd);
      left = xaxis.p2c(timeFrom) + o.left;
      var right = xaxis.p2c(timeTo) + o.left;
      regionWidth = right - left;

      _.each([left, right], function(position) {
        var line = $('<div class="events_line flot-temp-elem"></div>').css({
          "position": "absolute",
          "opacity": 0.8,
          "left": position + 'px',
          "top": 8,
          "width": lineWidth + "px",
          "height": that._plot.height() + topOffset,
          "border-left-width": lineWidth + "px",
          "border-left-style": lineStyle,
          "border-left-color": color,
          "color": color
        });
        line.appendTo(container);
      });

      var region = $('<div class="events_marker region_marker flot-temp-elem"></div>').css({
        "position": "absolute",
        "opacity": 0.5,
        "left": left + 'px',
        "top": top,
        "width": Math.round(regionWidth + lineWidth) + "px",
        "height": "0.5rem",
        "border-left-color": color,
        "color": color,
        "background-color": color
      });
      region.appendTo(container);

      region.data({
        "event": event
      });

      var mouseenter = function () {
        createAnnotationToolip(region, $(this).data("event"), that._plot);
      };

      if (event.editModel) {
        createEditPopover(region, event.editModel, that._plot);
      }

      var mouseleave = function () {
        that._plot.clearSelection();
      };

      if (markerTooltip) {
        region.css({ "cursor": "help" });
        region.hover(mouseenter, mouseleave);
      }

      var drawableEvent = new DrawableEvent(
        region,
        function drawFunc(obj) { obj.show(); },
        function (obj) { obj.remove(); },
        function (obj, position) {
          obj.css({
            top: position.top,
            left: position.left
          });
        },
        left,
        top,
        region.width(),
        region.height()
      );

      return drawableEvent;
    };

    /**
     * check if the event is inside visible range
     */
    this._insidePlot = function(x) {
      var xaxis = this._plot.getXAxes()[this._plot.getOptions().events.xaxis - 1];
      var xc = xaxis.p2c(x);
      return xc > 0 && xc < xaxis.p2c(xaxis.max);
    };
  };

  /**
   * initialize the plugin for the given plot
   */
  function init(plot) {
    /*jshint validthis:true */
    var that = this;
    var eventMarkers = new EventMarkers(plot);

    plot.getEvents = function() {
      return eventMarkers._events;
    };

    plot.hideEvents = function() {
      $.each(eventMarkers._events, function(index, event) {
        event.visual().getObject().hide();
      });
    };

    plot.showEvents = function() {
      plot.hideEvents();
      $.each(eventMarkers._events, function(index, event) {
        event.hide();
      });

      that.eventMarkers.drawEvents();
    };

    // change events on an existing plot
    plot.setEvents = function(events) {
      if (eventMarkers.eventsEnabled) {
        eventMarkers.setupEvents(events);
      }
    };

    plot.hooks.processOptions.push(function(plot, options) {
      // enable the plugin
      if (options.events.data != null) {
        eventMarkers.eventsEnabled = true;
      }
    });

    plot.hooks.draw.push(function(plot) {
      var options = plot.getOptions();

      if (eventMarkers.eventsEnabled) {
        // check for first run
        if (eventMarkers.getEvents().length < 1) {
          eventMarkers.setTypes(options.events.types);
          eventMarkers.setupEvents(options.events.data);
        } else {
          eventMarkers.updateEvents();
        }
      }

      eventMarkers.drawEvents();
    });
  }

  var defaultOptions = {
    events: {
      data: null,
      types: null,
      xaxis: 1,
      position: 'BOTTOM'
    }
  };

  $.plot.plugins.push({
    init: init,
    options: defaultOptions,
    name: "events",
    version: "0.2.5"
  });
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ 1485:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
  __webpack_require__(13),
  __webpack_require__(465),
], __WEBPACK_AMD_DEFINE_RESULT__ = function ($, core) {
  'use strict';

  var appEvents = core.appEvents;

  function GraphTooltip(elem, dashboard, scope, getSeriesFn) {
    var self = this;
    var ctrl = scope.ctrl;
    var panel = ctrl.panel;

    var $tooltip = $('<div class="graph-tooltip">');

    this.destroy = function() {
      $tooltip.remove();
    };

    this.findHoverIndexFromDataPoints = function(posX, series, last) {
      var ps = series.datapoints.pointsize;
      var initial = last*ps;
      var len = series.datapoints.points.length;
      for (var j = initial; j < len; j += ps) {
        // Special case of a non stepped line, highlight the very last point just before a null point
        if ((!series.lines.steps && series.datapoints.points[initial] != null && series.datapoints.points[j] == null)
            //normal case
            || series.datapoints.points[j] > posX) {
          return Math.max(j - ps,  0)/ps;
        }
      }
      return j/ps - 1;
    };

    this.findHoverIndexFromData = function(posX, series) {
      var lower = 0;
      var upper = series.data.length - 1;
      var middle;
      while (true) {
        if (lower > upper) {
          return Math.max(upper, 0);
        }
        middle = Math.floor((lower + upper) / 2);
        if (series.data[middle][0] === posX) {
          return middle;
        } else if (series.data[middle][0] < posX) {
          lower = middle + 1;
        } else {
          upper = middle - 1;
        }
      }
    };

    this.renderAndShow = function(absoluteTime, innerHtml, pos, xMode) {
      if (xMode === 'time') {
        innerHtml = '<div class="graph-tooltip-time">'+ absoluteTime + '</div>' + innerHtml;
      }
      $tooltip.html(innerHtml).place_tt(pos.pageX + 20, pos.pageY);
    };

    this.getMultiSeriesPlotHoverInfo = function(seriesList, pos) {
      var value, i, series, hoverIndex, hoverDistance, pointTime, yaxis;
      // 3 sub-arrays, 1st for hidden series, 2nd for left yaxis, 3rd for right yaxis.
      var results = [[],[],[]];

      //now we know the current X (j) position for X and Y values
      var last_value = 0; //needed for stacked values

      var minDistance, minTime;

      for (i = 0; i < seriesList.length; i++) {
        series = seriesList[i];

        if (!series.data.length || (panel.legend.hideEmpty && series.allIsNull)) {
          // Init value so that it does not brake series sorting
          results[0].push({ hidden: true, value: 0 });
          continue;
        }

        if (!series.data.length || (panel.legend.hideZero && series.allIsZero)) {
          // Init value so that it does not brake series sorting
          results[0].push({ hidden: true, value: 0 });
          continue;
        }

        hoverIndex = this.findHoverIndexFromData(pos.x, series);
        hoverDistance = pos.x - series.data[hoverIndex][0];
        pointTime = series.data[hoverIndex][0];

        // Take the closest point before the cursor, or if it does not exist, the closest after
        if (! minDistance
            || (hoverDistance >=0 && (hoverDistance < minDistance || minDistance < 0))
            || (hoverDistance < 0 && hoverDistance > minDistance)) {
          minDistance = hoverDistance;
          minTime = pointTime;
        }

        if (series.stack) {
          if (panel.tooltip.value_type === 'individual') {
            value = series.data[hoverIndex][1];
          } else if (!series.stack) {
            value = series.data[hoverIndex][1];
          } else {
            last_value += series.data[hoverIndex][1];
            value = last_value;
          }
        } else {
          value = series.data[hoverIndex][1];
        }

        // Highlighting multiple Points depending on the plot type
        if (series.lines.steps || series.stack) {
          // stacked and steppedLine plots can have series with different length.
          // Stacked series can increase its length on each new stacked serie if null points found,
          // to speed the index search we begin always on the last found hoverIndex.
          hoverIndex = this.findHoverIndexFromDataPoints(pos.x, series, hoverIndex);
        }

        // Be sure we have a yaxis so that it does not brake series sorting
        yaxis = 0;
        if (series.yaxis) {
          yaxis = series.yaxis.n;
        }

        results[yaxis].push({
          value: value,
          hoverIndex: hoverIndex,
          color: series.color,
          label: series.aliasEscaped,
          time: pointTime,
          distance: hoverDistance,
          index: i
        });
      }

      // Contat the 3 sub-arrays
      results = results[0].concat(results[1],results[2]);

      // Time of the point closer to pointer
      results.time = minTime;

      return results;
    };

    elem.mouseleave(function () {
      if (panel.tooltip.shared) {
        var plot = elem.data().plot;
        if (plot) {
          $tooltip.detach();
          plot.unhighlight();
        }
      }
      appEvents.emit('graph-hover-clear');
    });

    elem.bind("plothover", function (event, pos, item) {
      self.show(pos, item);

      // broadcast to other graph panels that we are hovering!
      pos.panelRelY = (pos.pageY - elem.offset().top) / elem.height();
      appEvents.emit('graph-hover', {pos: pos, panel: panel});
    });

    elem.bind("plotclick", function (event, pos, item) {
      appEvents.emit('graph-click', {pos: pos, panel: panel, item: item});
    });

    this.clear = function(plot) {
      $tooltip.detach();
      plot.clearCrosshair();
      plot.unhighlight();
    };

    this.show = function(pos, item) {
      var plot = elem.data().plot;
      var plotData = plot.getData();
      var xAxes = plot.getXAxes();
      var xMode = xAxes[0].options.mode;
      var seriesList = getSeriesFn();
      var allSeriesMode = panel.tooltip.shared;
      var group, value, absoluteTime, hoverInfo, i, series, seriesHtml, tooltipFormat;

      // if panelRelY is defined another panel wants us to show a tooltip
      // get pageX from position on x axis and pageY from relative position in original panel
      if (pos.panelRelY) {
        var pointOffset = plot.pointOffset({x: pos.x});
        if (Number.isNaN(pointOffset.left) || pointOffset.left < 0 || pointOffset.left > elem.width()) {
          self.clear(plot);
          return;
        }
        pos.pageX = elem.offset().left + pointOffset.left;
        pos.pageY = elem.offset().top + elem.height() * pos.panelRelY;
        var isVisible = pos.pageY >= $(window).scrollTop() && pos.pageY <= $(window).innerHeight() + $(window).scrollTop();
        if (!isVisible) {
          self.clear(plot);
          return;
        }
        plot.setCrosshair(pos);
        allSeriesMode = true;

        if (dashboard.sharedCrosshairModeOnly()) {
          // if only crosshair mode we are done
          return;
        }
      }

      if (seriesList.length === 0) {
        return;
      }

      if (seriesList[0].hasMsResolution) {
        tooltipFormat = 'YYYY-MM-DD HH:mm:ss.SSS';
      } else {
        tooltipFormat = 'YYYY-MM-DD HH:mm:ss';
      }

      if (allSeriesMode) {
        plot.unhighlight();

        var seriesHoverInfo = self.getMultiSeriesPlotHoverInfo(plotData, pos);

        seriesHtml = '';

        absoluteTime = dashboard.formatDate(seriesHoverInfo.time, tooltipFormat);

        // Dynamically reorder the hovercard for the current time point if the
        // option is enabled.
        if (panel.tooltip.sort === 2) {
          seriesHoverInfo.sort(function(a, b) {
            return b.value - a.value;
          });
        } else if (panel.tooltip.sort === 1) {
          seriesHoverInfo.sort(function(a, b) {
            return a.value - b.value;
          });
        }

        for (i = 0; i < seriesHoverInfo.length; i++) {
          hoverInfo = seriesHoverInfo[i];

          if (hoverInfo.hidden) {
            continue;
          }

          var highlightClass = '';
          if (item && hoverInfo.index === item.seriesIndex) {
            highlightClass = 'graph-tooltip-list-item--highlight';
          }

          series = seriesList[hoverInfo.index];

          value = series.formatValue(hoverInfo.value);

          seriesHtml += '<div class="graph-tooltip-list-item ' + highlightClass + '"><div class="graph-tooltip-series-name">';
          seriesHtml += '<i class="fa fa-minus" style="color:' + hoverInfo.color +';"></i> ' + hoverInfo.label + ':</div>';
          seriesHtml += '<div class="graph-tooltip-value">' + value + '</div></div>';
          plot.highlight(hoverInfo.index, hoverInfo.hoverIndex);
        }

        self.renderAndShow(absoluteTime, seriesHtml, pos, xMode);
      }
      // single series tooltip
      else if (item) {
        series = seriesList[item.seriesIndex];
        group = '<div class="graph-tooltip-list-item"><div class="graph-tooltip-series-name">';
        group += '<i class="fa fa-minus" style="color:' + item.series.color +';"></i> ' + series.aliasEscaped + ':</div>';

        if (panel.stack && panel.tooltip.value_type === 'individual') {
          value = item.datapoint[1] - item.datapoint[2];
        }
        else {
          value = item.datapoint[1];
        }

        value = series.formatValue(value);

        absoluteTime = dashboard.formatDate(item.datapoint[0], tooltipFormat);

        group += '<div class="graph-tooltip-value">' + value + '</div>';

        self.renderAndShow(absoluteTime, group, pos, xMode);
      }
      // no hit
      else {
        $tooltip.detach();
      }
    };
  }

  return GraphTooltip;
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ 1486:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ThresholdManager; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_vendor_flot_jquery_flot__ = __webpack_require__(1315);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_vendor_flot_jquery_flot___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_vendor_flot_jquery_flot__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_jquery__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_jquery___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_jquery__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_lodash__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_lodash__);



var ThresholdManager = /** @class */ (function () {
    function ThresholdManager(panelCtrl) {
        this.panelCtrl = panelCtrl;
    }
    ThresholdManager.prototype.getHandleHtml = function (handleIndex, model, valueStr) {
        var stateClass = model.colorMode;
        if (model.colorMode === 'custom') {
            stateClass = 'critical';
        }
        return "\n    <div class=\"alert-handle-wrapper alert-handle-wrapper--T" + handleIndex + "\">\n      <div class=\"alert-handle-line alert-handle-line--" + stateClass + "\">\n      </div>\n      <div class=\"alert-handle\" data-handle-index=\"" + handleIndex + "\">\n        <i class=\"icon-gf icon-gf-" + stateClass + " alert-state-" + stateClass + "\"></i>\n        <span class=\"alert-handle-value\">" + valueStr + "<i class=\"alert-handle-grip\"></i></span>\n      </div>\n    </div>";
    };
    ThresholdManager.prototype.initDragging = function (evt) {
        var handleElem = __WEBPACK_IMPORTED_MODULE_1_jquery___default()(evt.currentTarget).parents(".alert-handle-wrapper");
        var handleIndex = __WEBPACK_IMPORTED_MODULE_1_jquery___default()(evt.currentTarget).data("handleIndex");
        var isMoving = false;
        var lastY = null;
        var posTop;
        var plot = this.plot;
        var panelCtrl = this.panelCtrl;
        var model = this.thresholds[handleIndex];
        function dragging(evt) {
            if (lastY === null) {
                lastY = evt.clientY;
            }
            else {
                var diff = evt.clientY - lastY;
                posTop = posTop + diff;
                lastY = evt.clientY;
                handleElem.css({ top: posTop + diff });
            }
        }
        function stopped() {
            isMoving = false;
            // calculate graph level
            var graphValue = plot.c2p({ left: 0, top: posTop }).y;
            graphValue = parseInt(graphValue.toFixed(0));
            model.value = graphValue;
            handleElem.off("mousemove", dragging);
            handleElem.off("mouseup", dragging);
            handleElem.off("mouseleave", dragging);
            // trigger digest and render
            panelCtrl.$scope.$apply(function () {
                panelCtrl.render();
                panelCtrl.events.emit('threshold-changed', { threshold: model, handleIndex: handleIndex });
            });
        }
        isMoving = true;
        lastY = null;
        posTop = handleElem.position().top;
        handleElem.on("mousemove", dragging);
        handleElem.on("mouseup", stopped);
        handleElem.on("mouseleave", stopped);
    };
    ThresholdManager.prototype.cleanUp = function () {
        this.placeholder.find(".alert-handle-wrapper").remove();
        this.needsCleanup = false;
    };
    ThresholdManager.prototype.renderHandle = function (handleIndex, defaultHandleTopPos) {
        var model = this.thresholds[handleIndex];
        var value = model.value;
        var valueStr = value;
        var handleTopPos = 0;
        // handle no value
        if (!__WEBPACK_IMPORTED_MODULE_2_lodash___default.a.isNumber(value)) {
            valueStr = '';
            handleTopPos = defaultHandleTopPos;
        }
        else {
            var valueCanvasPos = this.plot.p2c({ x: 0, y: value });
            handleTopPos = Math.round(Math.min(Math.max(valueCanvasPos.top, 0), this.height) - 6);
        }
        var handleElem = __WEBPACK_IMPORTED_MODULE_1_jquery___default()(this.getHandleHtml(handleIndex, model, valueStr));
        this.placeholder.append(handleElem);
        handleElem.toggleClass('alert-handle-wrapper--no-value', valueStr === '');
        handleElem.css({ top: handleTopPos });
    };
    ThresholdManager.prototype.shouldDrawHandles = function () {
        return !this.hasSecondYAxis && this.panelCtrl.editingThresholds && this.panelCtrl.panel.thresholds.length > 0;
    };
    ThresholdManager.prototype.prepare = function (elem, data) {
        this.hasSecondYAxis = false;
        for (var i = 0; i < data.length; i++) {
            if (data[i].yaxis > 1) {
                this.hasSecondYAxis = true;
                break;
            }
        }
        if (this.shouldDrawHandles()) {
            var thresholdMargin = this.panelCtrl.panel.thresholds.length > 1 ? '220px' : '110px';
            elem.css('margin-right', thresholdMargin);
        }
        else if (this.needsCleanup) {
            elem.css('margin-right', '0');
        }
    };
    ThresholdManager.prototype.draw = function (plot) {
        this.thresholds = this.panelCtrl.panel.thresholds;
        this.plot = plot;
        this.placeholder = plot.getPlaceholder();
        if (this.needsCleanup) {
            this.cleanUp();
        }
        if (!this.shouldDrawHandles()) {
            return;
        }
        this.height = plot.height();
        if (this.thresholds.length > 0) {
            this.renderHandle(0, 10);
        }
        if (this.thresholds.length > 1) {
            this.renderHandle(1, this.height - 30);
        }
        this.placeholder.off('mousedown', '.alert-handle');
        this.placeholder.on('mousedown', '.alert-handle', this.initDragging.bind(this));
        this.needsCleanup = true;
    };
    ThresholdManager.prototype.addFlotOptions = function (options, panel) {
        if (!panel.thresholds || panel.thresholds.length === 0) {
            return;
        }
        var gtLimit = Infinity;
        var ltLimit = -Infinity;
        var i, threshold, other;
        for (i = 0; i < panel.thresholds.length; i++) {
            threshold = panel.thresholds[i];
            if (!__WEBPACK_IMPORTED_MODULE_2_lodash___default.a.isNumber(threshold.value)) {
                continue;
            }
            var limit;
            switch (threshold.op) {
                case 'gt': {
                    limit = gtLimit;
                    // if next threshold is less then op and greater value, then use that as limit
                    if (panel.thresholds.length > i + 1) {
                        other = panel.thresholds[i + 1];
                        if (other.value > threshold.value) {
                            limit = other.value;
                            ltLimit = limit;
                        }
                    }
                    break;
                }
                case 'lt': {
                    limit = ltLimit;
                    // if next threshold is less then op and greater value, then use that as limit
                    if (panel.thresholds.length > i + 1) {
                        other = panel.thresholds[i + 1];
                        if (other.value < threshold.value) {
                            limit = other.value;
                            gtLimit = limit;
                        }
                    }
                    break;
                }
            }
            var fillColor, lineColor;
            switch (threshold.colorMode) {
                case 'critical': {
                    fillColor = 'rgba(234, 112, 112, 0.12)';
                    lineColor = 'rgba(237, 46, 24, 0.60)';
                    break;
                }
                case 'warning': {
                    fillColor = 'rgba(235, 138, 14, 0.12)';
                    lineColor = 'rgba(247, 149, 32, 0.60)';
                    break;
                }
                case 'ok': {
                    fillColor = 'rgba(11, 237, 50, 0.090)';
                    lineColor = 'rgba(6,163,69, 0.60)';
                    break;
                }
                case 'custom': {
                    fillColor = threshold.fillColor;
                    lineColor = threshold.lineColor;
                    break;
                }
            }
            // fill
            if (threshold.fill) {
                options.grid.markings.push({ yaxis: { from: threshold.value, to: limit }, color: fillColor });
            }
            if (threshold.line) {
                options.grid.markings.push({ yaxis: { from: threshold.value, to: threshold.value }, color: lineColor });
            }
        }
    };
    return ThresholdManager;
}());



/***/ }),

/***/ 1487:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["b"] = getSeriesValues;
/* harmony export (immutable) */ __webpack_exports__["a"] = convertValuesToHistogram;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_lodash__);

/**
 * Convert series into array of series values.
 * @param data Array of series
 */
function getSeriesValues(dataList) {
    var VALUE_INDEX = 0;
    var values = [];
    // Count histogam stats
    for (var i = 0; i < dataList.length; i++) {
        var series = dataList[i];
        var datapoints = series.datapoints;
        for (var j = 0; j < datapoints.length; j++) {
            if (datapoints[j][VALUE_INDEX] !== null) {
                values.push(datapoints[j][VALUE_INDEX]);
            }
        }
    }
    return values;
}
/**
 * Convert array of values into timeseries-like histogram:
 * [[val_1, count_1], [val_2, count_2], ..., [val_n, count_n]]
 * @param values
 * @param bucketSize
 */
function convertValuesToHistogram(values, bucketSize) {
    var histogram = {};
    for (var i = 0; i < values.length; i++) {
        var bound = getBucketBound(values[i], bucketSize);
        if (histogram[bound]) {
            histogram[bound] = histogram[bound] + 1;
        }
        else {
            histogram[bound] = 1;
        }
    }
    var histogam_series = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.map(histogram, function (count, bound) {
        return [Number(bound), count];
    });
    // Sort by Y axis values
    return __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.sortBy(histogam_series, function (point) { return point[0]; });
}
function getBucketBound(value, bucketSize) {
    return Math.floor(value / bucketSize) * bucketSize;
}


/***/ }),

/***/ 1488:
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
  __webpack_require__(12),
  __webpack_require__(7),
  __webpack_require__(13),
], __WEBPACK_AMD_DEFINE_RESULT__ = function (angular, _, $) {
  'use strict';

  var module = angular.module('grafana.directives');

  module.directive('graphLegend', ["popoverSrv", "$timeout", function(popoverSrv, $timeout) {

    return {
      link: function(scope, elem) {
        var $container = $('<section class="graph-legend"></section>');
        var firstRender = true;
        var ctrl = scope.ctrl;
        var panel = ctrl.panel;
        var data;
        var seriesList;
        var i;

        ctrl.events.on('render', function() {
          data = ctrl.seriesList;
          if (data) {
            render();
          }
        });

        function getSeriesIndexForElement(el) {
          return el.parents('[data-series-index]').data('series-index');
        }

        function openColorSelector(e) {
          // if we clicked inside poup container ignore click
          if ($(e.target).parents('.popover').length) {
            return;
          }

          var el = $(e.currentTarget).find('.fa-minus');
          var index = getSeriesIndexForElement(el);
          var series = seriesList[index];

          $timeout(function() {
            popoverSrv.show({
              element: el[0],
              position: 'bottom center',
              template: '<series-color-picker series="series" onToggleAxis="toggleAxis" onColorChange="colorSelected">' +
                '</series-color-picker>',
              openOn: 'hover',
              model: {
                series: series,
                toggleAxis: function() {
                  ctrl.toggleAxis(series);
                },
                colorSelected: function(color) {
                  ctrl.changeSeriesColor(series, color);
                }
              },
            });
          });
        }

        function toggleSeries(e) {
          var el = $(e.currentTarget);
          var index = getSeriesIndexForElement(el);
          var seriesInfo = seriesList[index];
          var scrollPosition = $($container.children('tbody')).scrollTop();
          ctrl.toggleSeries(seriesInfo, e);
          $($container.children('tbody')).scrollTop(scrollPosition);
        }

        function sortLegend(e) {
          var el = $(e.currentTarget);
          var stat = el.data('stat');

          if (stat !== panel.legend.sort) { panel.legend.sortDesc = null; }

          // if already sort ascending, disable sorting
          if (panel.legend.sortDesc === false) {
            panel.legend.sort = null;
            panel.legend.sortDesc = null;
            ctrl.render();
            return;
          }

          panel.legend.sortDesc = !panel.legend.sortDesc;
          panel.legend.sort = stat;
          ctrl.render();
        }

        function getTableHeaderHtml(statName) {
          if (!panel.legend[statName]) { return ""; }
          var html = '<th class="pointer" data-stat="' + statName + '">' + statName;

          if (panel.legend.sort === statName) {
            var cssClass = panel.legend.sortDesc ? 'fa fa-caret-down' : 'fa fa-caret-up' ;
            html += ' <span class="' + cssClass + '"></span>';
          }

          return html + '</th>';
        }

        function render() {
          if (!ctrl.panel.legend.show) {
            elem.empty();
            firstRender = true;
            return;
          }

          if (firstRender) {
            elem.append($container);
            $container.on('click', '.graph-legend-icon', openColorSelector);
            $container.on('click', '.graph-legend-alias', toggleSeries);
            $container.on('click', 'th', sortLegend);
            firstRender = false;
          }

          seriesList = data;

          $container.empty();

          // Set min-width if side style and there is a value, otherwise remove the CSS propery
          var width = panel.legend.rightSide && panel.legend.sideWidth ? panel.legend.sideWidth + "px" : "";
          $container.css("min-width", width);

          $container.toggleClass('graph-legend-table', panel.legend.alignAsTable === true);

          var tableHeaderElem;
          if (panel.legend.alignAsTable) {
            var header = '<tr>';
            header += '<th colspan="2" style="text-align:left"></th>';
            if (panel.legend.values) {
              header += getTableHeaderHtml('min');
              header += getTableHeaderHtml('max');
              header += getTableHeaderHtml('avg');
              header += getTableHeaderHtml('current');
              header += getTableHeaderHtml('total');
            }
            header += '</tr>';
            tableHeaderElem = $(header);
          }

          if (panel.legend.sort) {
            seriesList = _.sortBy(seriesList, function(series) {
              return series.stats[panel.legend.sort];
            });
            if (panel.legend.sortDesc) {
              seriesList = seriesList.reverse();
            }
          }

          var seriesShown = 0;
          var seriesElements = [];

          for (i = 0; i < seriesList.length; i++) {
            var series = seriesList[i];

            if (series.hideFromLegend(panel.legend)) {
              continue;
            }

            var html = '<div class="graph-legend-series';

            if (series.yaxis === 2) { html += ' graph-legend-series--right-y'; }
            if (ctrl.hiddenSeries[series.alias]) { html += ' graph-legend-series-hidden'; }
            html += '" data-series-index="' + i + '">';
            html += '<div class="graph-legend-icon">';
            html += '<i class="fa fa-minus pointer" style="color:' + series.color + '"></i>';
            html += '</div>';

            html += '<a class="graph-legend-alias pointer" title="' + series.aliasEscaped + '">' + series.aliasEscaped + '</a>';

            if (panel.legend.values) {
              var avg = series.formatValue(series.stats.avg);
              var current = series.formatValue(series.stats.current);
              var min = series.formatValue(series.stats.min);
              var max = series.formatValue(series.stats.max);
              var total = series.formatValue(series.stats.total);

              if (panel.legend.min) { html += '<div class="graph-legend-value min">' + min + '</div>'; }
              if (panel.legend.max) { html += '<div class="graph-legend-value max">' + max + '</div>'; }
              if (panel.legend.avg) { html += '<div class="graph-legend-value avg">' + avg + '</div>'; }
              if (panel.legend.current) { html += '<div class="graph-legend-value current">' + current + '</div>'; }
              if (panel.legend.total) { html += '<div class="graph-legend-value total">' + total + '</div>'; }
            }

            html += '</div>';
            seriesElements.push($(html));

            seriesShown++;
          }

          if (panel.legend.alignAsTable) {
            var maxHeight = ctrl.height;

            if (!panel.legend.rightSide) {
              maxHeight = maxHeight/2;
            }

            var topPadding = 6;
            var tbodyElem = $('<tbody></tbody>');
            tbodyElem.css("max-height", maxHeight - topPadding);
            tbodyElem.append(tableHeaderElem);
            tbodyElem.append(seriesElements);
            $container.append(tbodyElem);
          } else {
            $container.append(seriesElements);
          }
        }
      }
    };
  }]);

}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(201)(module)))

/***/ }),

/***/ 1489:
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
  __webpack_require__(12),
  __webpack_require__(13),
  __webpack_require__(7),
], __WEBPACK_AMD_DEFINE_RESULT__ = function(angular, jquery, _) {
  'use strict';

  var module = angular.module('grafana.controllers');

  module.controller('SeriesOverridesCtrl', ["$scope", "$element", "popoverSrv", function($scope, $element, popoverSrv) {
    $scope.overrideMenu = [];
    $scope.currentOverrides = [];
    $scope.override = $scope.override || {};

    $scope.addOverrideOption = function(name, propertyName, values) {
      var option = {};
      option.text = name;
      option.propertyName = propertyName;
      option.index = $scope.overrideMenu.length;
      option.values = values;

      option.submenu = _.map(values, function(value) {
        return { text: String(value), value: value };
      });

      $scope.overrideMenu.push(option);
    };

    $scope.setOverride = function(item, subItem) {
      // handle color overrides
      if (item.propertyName === 'color') {
        $scope.openColorSelector($scope.override['color']);
        return;
      }

      $scope.override[item.propertyName] = subItem.value;

      // automatically disable lines for this series and the fill bellow to series
      // can be removed by the user if they still want lines
      if (item.propertyName === 'fillBelowTo') {
        $scope.override['lines'] = false;
        $scope.ctrl.addSeriesOverride({alias: subItem.value, lines: false });
      }

      $scope.updateCurrentOverrides();
      $scope.ctrl.render();
    };

    $scope.colorSelected = function(color) {
      $scope.override['color'] = color;
      $scope.updateCurrentOverrides();
      $scope.ctrl.render();
    };

    $scope.openColorSelector = function(color) {
      var fakeSeries = {color: color};
      popoverSrv.show({
        element: $element.find(".dropdown")[0],
        position: 'top center',
        openOn: 'click',
        template: '<series-color-picker series="series" onColorChange="colorSelected" />',
        model: {
          autoClose: true,
          colorSelected: $scope.colorSelected,
          series: fakeSeries
        },
        onClose: function() {
          $scope.ctrl.render();
        }
      });
    };

    $scope.removeOverride = function(option) {
      delete $scope.override[option.propertyName];
      $scope.updateCurrentOverrides();
      $scope.ctrl.refresh();
    };

    $scope.getSeriesNames = function() {
      return _.map($scope.ctrl.seriesList, function(series) {
        return series.alias;
      });
    };

    $scope.updateCurrentOverrides = function() {
      $scope.currentOverrides = [];
      _.each($scope.overrideMenu, function(option) {
        var value = $scope.override[option.propertyName];
        if (_.isUndefined(value)) { return; }
        $scope.currentOverrides.push({
          name: option.text,
          propertyName: option.propertyName,
          value: String(value)
        });
      });
    };

    $scope.addOverrideOption('Bars', 'bars', [true, false]);
    $scope.addOverrideOption('Lines', 'lines', [true, false]);
    $scope.addOverrideOption('Line fill', 'fill', [0,1,2,3,4,5,6,7,8,9,10]);
    $scope.addOverrideOption('Line width', 'linewidth', [0,1,2,3,4,5,6,7,8,9,10]);
    $scope.addOverrideOption('Null point mode', 'nullPointMode', ['connected', 'null', 'null as zero']);
    $scope.addOverrideOption('Fill below to', 'fillBelowTo', $scope.getSeriesNames());
    $scope.addOverrideOption('Staircase line', 'steppedLine', [true, false]);
    $scope.addOverrideOption('Dashes', 'dashes', [true, false]);
    $scope.addOverrideOption('Dash Length', 'dashLength', [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]);
    $scope.addOverrideOption('Dash Space', 'spaceLength', [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]);
    $scope.addOverrideOption('Points', 'points', [true, false]);
    $scope.addOverrideOption('Points Radius', 'pointradius', [1,2,3,4,5]);
    $scope.addOverrideOption('Stack', 'stack', [true, false, 'A', 'B', 'C', 'D']);
    $scope.addOverrideOption('Color', 'color', ['change']);
    $scope.addOverrideOption('Y-axis', 'yaxis', [1, 2]);
    $scope.addOverrideOption('Z-index', 'zindex', [-3,-2,-1,0,1,2,3]);
    $scope.addOverrideOption('Transform', 'transform', ['negative-Y']);
    $scope.addOverrideOption('Legend', 'legend', [true, false]);
    $scope.updateCurrentOverrides();
  }]);
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(201)(module)))

/***/ }),

/***/ 1490:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export ThresholdFormCtrl */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_app_core_core_module__ = __webpack_require__(2);
///<reference path="../../../headers/common.d.ts" />

var ThresholdFormCtrl = /** @class */ (function () {
    /** @ngInject */
    ThresholdFormCtrl.$inject = ["$scope"];
    function ThresholdFormCtrl($scope) {
        var _this = this;
        this.panel = this.panelCtrl.panel;
        if (this.panel.alert) {
            this.disabled = true;
        }
        var unbindDestroy = $scope.$on("$destroy", function () {
            _this.panelCtrl.editingThresholds = false;
            _this.panelCtrl.render();
            unbindDestroy();
        });
        this.panelCtrl.editingThresholds = true;
    }
    ThresholdFormCtrl.prototype.addThreshold = function () {
        this.panel.thresholds.push({ value: undefined, colorMode: "critical", op: 'gt', fill: true, line: true });
        this.panelCtrl.render();
    };
    ThresholdFormCtrl.prototype.removeThreshold = function (index) {
        this.panel.thresholds.splice(index, 1);
        this.panelCtrl.render();
    };
    ThresholdFormCtrl.prototype.render = function () {
        this.panelCtrl.render();
    };
    ThresholdFormCtrl.prototype.onFillColorChange = function (index) {
        var _this = this;
        return function (newColor) {
            _this.panel.thresholds[index].fillColor = newColor;
            _this.render();
        };
    };
    ThresholdFormCtrl.prototype.onLineColorChange = function (index) {
        var _this = this;
        return function (newColor) {
            _this.panel.thresholds[index].lineColor = newColor;
            _this.render();
        };
    };
    return ThresholdFormCtrl;
}());

var template = "\n<div class=\"gf-form-group\">\n  <h5>Thresholds</h5>\n  <p class=\"muted\" ng-show=\"ctrl.disabled\">\n    Visual thresholds options <strong>disabled.</strong>\n    Visit the Alert tab update your thresholds. <br>\n    To re-enable thresholds, the alert rule must be deleted from this panel.\n  </p>\n  <div ng-class=\"{'thresholds-form-disabled': ctrl.disabled}\">\n    <div class=\"gf-form-inline\" ng-repeat=\"threshold in ctrl.panel.thresholds\">\n      <div class=\"gf-form\">\n        <label class=\"gf-form-label\">T{{$index+1}}</label>\n      </div>\n\n      <div class=\"gf-form\">\n        <div class=\"gf-form-select-wrapper\">\n          <select class=\"gf-form-input\" ng-model=\"threshold.op\"\n                  ng-options=\"f for f in ['gt', 'lt']\" ng-change=\"ctrl.render()\" ng-disabled=\"ctrl.disabled\"></select>\n        </div>\n        <input type=\"number\" ng-model=\"threshold.value\" class=\"gf-form-input width-8\"\n               ng-change=\"ctrl.render()\" placeholder=\"value\" ng-disabled=\"ctrl.disabled\">\n      </div>\n\n      <div class=\"gf-form\">\n        <label class=\"gf-form-label\">Color</label>\n        <div class=\"gf-form-select-wrapper\">\n          <select class=\"gf-form-input\" ng-model=\"threshold.colorMode\"\n                  ng-options=\"f for f in ['custom', 'critical', 'warning', 'ok']\" ng-change=\"ctrl.render()\" ng-disabled=\"ctrl.disabled\">\n          </select>\n        </div>\n      </div>\n\n      <gf-form-switch class=\"gf-form\" label=\"Fill\" checked=\"threshold.fill\"\n                      on-change=\"ctrl.render()\" ng-disabled=\"ctrl.disabled\"></gf-form-switch>\n\n      <div class=\"gf-form\" ng-if=\"threshold.fill && threshold.colorMode === 'custom'\">\n        <label class=\"gf-form-label\">Fill color</label>\n        <span class=\"gf-form-label\">\n          <color-picker color=\"threshold.fillColor\" onChange=\"ctrl.onFillColorChange($index)\"></color-picker>\n        </span>\n      </div>\n\n      <gf-form-switch class=\"gf-form\" label=\"Line\" checked=\"threshold.line\"\n                      on-change=\"ctrl.render()\" ng-disabled=\"ctrl.disabled\"></gf-form-switch>\n\n      <div class=\"gf-form\" ng-if=\"threshold.line && threshold.colorMode === 'custom'\">\n        <label class=\"gf-form-label\">Line color</label>\n        <span class=\"gf-form-label\">\n          <color-picker color=\"threshold.lineColor\" onChange=\"ctrl.onLineColorChange($index)\"></color-picker>\n        </span>\n      </div>\n\n      <div class=\"gf-form\">\n        <label class=\"gf-form-label\">\n          <a class=\"pointer\" ng-click=\"ctrl.removeThreshold($index)\" ng-disabled=\"ctrl.disabled\">\n            <i class=\"fa fa-trash\"></i>\n          </a>\n        </label>\n      </div>\n    </div>\n\n    <div class=\"gf-form-button-row\">\n      <button class=\"btn btn-inverse\" ng-click=\"ctrl.addThreshold()\" ng-disabled=\"ctrl.disabled\">\n        <i class=\"fa fa-plus\"></i>&nbsp;Add Threshold\n      </button>\n    </div>\n  </div>\n</div>\n";
__WEBPACK_IMPORTED_MODULE_0_app_core_core_module__["default"].directive('graphThresholdForm', function () {
    return {
        restrict: 'E',
        template: template,
        controller: ThresholdFormCtrl,
        bindToController: true,
        controllerAs: 'ctrl',
        scope: {
            panelCtrl: "="
        }
    };
});


/***/ }),

/***/ 1491:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var template = "\n<div class=\"graph-wrapper\" ng-class=\"{'graph-legend-rightside': ctrl.panel.legend.rightSide}\">\n  <div class=\"graph-canvas-wrapper\">\n\n    <div class=\"datapoints-warning\" ng-if=\"ctrl.dataWarning\">\n      <span class=\"small\" bs-tooltip=\"ctrl.dataWarning.tip\">{{ctrl.dataWarning.title}}</span>\n    </div>\n\n    <div grafana-graph class=\"histogram-chart\" ng-dblclick=\"ctrl.zoomOut()\">\n    </div>\n\n  </div>\n\n  <div class=\"graph-legend-wrapper\" graph-legend></div>\n  </div>\n\n<div class=\"clearfix\"></div>\n";
/* harmony default export */ __webpack_exports__["a"] = (template);


/***/ }),

/***/ 1492:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return DataProcessor; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_app_core_time_series2__ = __webpack_require__(1309);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_app_core_utils_colors__ = __webpack_require__(202);



var DataProcessor = /** @class */ (function () {
    function DataProcessor(panel) {
        this.panel = panel;
    }
    DataProcessor.prototype.getSeriesList = function (options) {
        var _this = this;
        if (!options.dataList || options.dataList.length === 0) {
            return [];
        }
        // auto detect xaxis mode
        var firstItem;
        if (options.dataList && options.dataList.length > 0) {
            firstItem = options.dataList[0];
            var autoDetectMode = this.getAutoDetectXAxisMode(firstItem);
            if (this.panel.xaxis.mode !== autoDetectMode) {
                this.panel.xaxis.mode = autoDetectMode;
                this.setPanelDefaultsForNewXAxisMode();
            }
        }
        switch (this.panel.xaxis.mode) {
            case 'series':
            case 'time': {
                return options.dataList.map(function (item, index) {
                    return _this.timeSeriesHandler(item, index, options);
                });
            }
            case 'histogram': {
                var histogramDataList = [{
                        target: 'count',
                        datapoints: __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.concat([], __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.flatten(__WEBPACK_IMPORTED_MODULE_0_lodash___default.a.map(options.dataList, 'datapoints')))
                    }];
                return histogramDataList.map(function (item, index) {
                    return _this.timeSeriesHandler(item, index, options);
                });
            }
            case 'field': {
                return this.customHandler(firstItem);
            }
        }
    };
    DataProcessor.prototype.getAutoDetectXAxisMode = function (firstItem) {
        switch (firstItem.type) {
            case 'docs': return 'field';
            case 'table': return 'field';
            default: {
                if (this.panel.xaxis.mode === 'series') {
                    return 'series';
                }
                if (this.panel.xaxis.mode === 'histogram') {
                    return 'histogram';
                }
                return 'time';
            }
        }
    };
    DataProcessor.prototype.setPanelDefaultsForNewXAxisMode = function () {
        switch (this.panel.xaxis.mode) {
            case 'time': {
                this.panel.bars = false;
                this.panel.lines = true;
                this.panel.points = false;
                this.panel.legend.show = true;
                this.panel.tooltip.shared = true;
                this.panel.xaxis.values = [];
                break;
            }
            case 'series': {
                this.panel.bars = true;
                this.panel.lines = false;
                this.panel.points = false;
                this.panel.stack = false;
                this.panel.legend.show = false;
                this.panel.tooltip.shared = false;
                this.panel.xaxis.values = ['total'];
                break;
            }
            case 'histogram': {
                this.panel.bars = true;
                this.panel.lines = false;
                this.panel.points = false;
                this.panel.stack = false;
                this.panel.legend.show = false;
                this.panel.tooltip.shared = false;
                break;
            }
        }
    };
    DataProcessor.prototype.timeSeriesHandler = function (seriesData, index, options) {
        var datapoints = seriesData.datapoints || [];
        var alias = seriesData.target;
        var colorIndex = index % __WEBPACK_IMPORTED_MODULE_2_app_core_utils_colors__["f" /* default */].length;
        var color = this.panel.aliasColors[alias] || __WEBPACK_IMPORTED_MODULE_2_app_core_utils_colors__["f" /* default */][colorIndex];
        var series = new __WEBPACK_IMPORTED_MODULE_1_app_core_time_series2__["a" /* default */]({ datapoints: datapoints, alias: alias, color: color, unit: seriesData.unit });
        if (datapoints && datapoints.length > 0) {
            var last = datapoints[datapoints.length - 1][1];
            var from = options.range.from;
            if (last - from < -10000) {
                series.isOutsideRange = true;
            }
        }
        return series;
    };
    DataProcessor.prototype.customHandler = function (dataItem) {
        var nameField = this.panel.xaxis.name;
        if (!nameField) {
            throw { message: 'No field name specified to use for x-axis, check your axes settings' };
        }
        return [];
    };
    DataProcessor.prototype.validateXAxisSeriesValue = function () {
        switch (this.panel.xaxis.mode) {
            case 'series': {
                if (this.panel.xaxis.values.length === 0) {
                    this.panel.xaxis.values = ['total'];
                    return;
                }
                var validOptions = this.getXAxisValueOptions({});
                var found = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.find(validOptions, { value: this.panel.xaxis.values[0] });
                if (!found) {
                    this.panel.xaxis.values = ['total'];
                }
                return;
            }
        }
    };
    DataProcessor.prototype.getDataFieldNames = function (dataList, onlyNumbers) {
        if (dataList.length === 0) {
            return [];
        }
        var fields = [];
        var firstItem = dataList[0];
        var fieldParts = [];
        function getPropertiesRecursive(obj) {
            __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.forEach(obj, function (value, key) {
                if (__WEBPACK_IMPORTED_MODULE_0_lodash___default.a.isObject(value)) {
                    fieldParts.push(key);
                    getPropertiesRecursive(value);
                }
                else {
                    if (!onlyNumbers || __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.isNumber(value)) {
                        var field = fieldParts.concat(key).join('.');
                        fields.push(field);
                    }
                }
            });
            fieldParts.pop();
        }
        if (firstItem.type === 'docs') {
            if (firstItem.datapoints.length === 0) {
                return [];
            }
            getPropertiesRecursive(firstItem.datapoints[0]);
        }
        return fields;
    };
    DataProcessor.prototype.getXAxisValueOptions = function (options) {
        switch (this.panel.xaxis.mode) {
            case 'series': {
                return [
                    { text: 'Avg', value: 'avg' },
                    { text: 'Min', value: 'min' },
                    { text: 'Max', value: 'max' },
                    { text: 'Total', value: 'total' },
                    { text: 'Count', value: 'count' },
                ];
            }
        }
        return [];
    };
    DataProcessor.prototype.pluckDeep = function (obj, property) {
        var propertyParts = property.split('.');
        var value = obj;
        for (var i = 0; i < propertyParts.length; ++i) {
            if (value[propertyParts[i]]) {
                value = value[propertyParts[i]];
            }
            else {
                return undefined;
            }
        }
        return value;
    };
    return DataProcessor;
}());



/***/ }),

/***/ 1493:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export AxesEditorCtrl */
/* harmony export (immutable) */ __webpack_exports__["a"] = axesEditorComponent;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_app_core_utils_kbn__ = __webpack_require__(464);
///<reference path="../../../headers/common.d.ts" />

var AxesEditorCtrl = /** @class */ (function () {
    /** @ngInject **/
    AxesEditorCtrl.$inject = ["$scope", "$q"];
    function AxesEditorCtrl($scope, $q) {
        this.$scope = $scope;
        this.$q = $q;
        this.panelCtrl = $scope.ctrl;
        this.panel = this.panelCtrl.panel;
        this.$scope.ctrl = this;
        this.unitFormats = __WEBPACK_IMPORTED_MODULE_0_app_core_utils_kbn__["default"].getUnitFormats();
        this.logScales = {
            'linear': 1,
            'log (base 2)': 2,
            'log (base 10)': 10,
            'log (base 32)': 32,
            'log (base 1024)': 1024
        };
        this.xAxisModes = {
            'Time': 'time',
            'Series': 'series',
            'Histogram': 'histogram'
            // 'Data field': 'field',
        };
        this.xAxisStatOptions = [
            { text: 'Avg', value: 'avg' },
            { text: 'Min', value: 'min' },
            { text: 'Max', value: 'max' },
            { text: 'Total', value: 'total' },
            { text: 'Count', value: 'count' },
            { text: 'Current', value: 'current' },
        ];
        if (this.panel.xaxis.mode === 'custom') {
            if (!this.panel.xaxis.name) {
                this.panel.xaxis.name = 'specify field';
            }
        }
    }
    AxesEditorCtrl.prototype.setUnitFormat = function (axis, subItem) {
        axis.format = subItem.value;
        this.panelCtrl.render();
    };
    AxesEditorCtrl.prototype.render = function () {
        this.panelCtrl.render();
    };
    AxesEditorCtrl.prototype.xAxisModeChanged = function () {
        this.panelCtrl.processor.setPanelDefaultsForNewXAxisMode();
        this.panelCtrl.onDataReceived(this.panelCtrl.dataList);
    };
    AxesEditorCtrl.prototype.xAxisValueChanged = function () {
        this.panelCtrl.onDataReceived(this.panelCtrl.dataList);
    };
    AxesEditorCtrl.prototype.getDataFieldNames = function (onlyNumbers) {
        var props = this.panelCtrl.processor.getDataFieldNames(this.panelCtrl.dataList, onlyNumbers);
        var items = props.map(function (prop) {
            return { text: prop, value: prop };
        });
        return this.$q.when(items);
    };
    return AxesEditorCtrl;
}());

/** @ngInject **/
function axesEditorComponent() {
    'use strict';
    return {
        restrict: 'E',
        scope: true,
        templateUrl: 'public/app/plugins/panel/graph/axes_editor.html',
        controller: AxesEditorCtrl,
    };
}


/***/ }),

/***/ 1494:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DashListCtrl", function() { return DashListCtrl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PanelCtrl", function() { return DashListCtrl; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_app_plugins_sdk__ = __webpack_require__(1305);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_app_features_dashboard_impression_store__ = __webpack_require__(1312);
///<reference path="../../../headers/common.d.ts" />
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();



var DashListCtrl = /** @class */ (function (_super) {
    __extends(DashListCtrl, _super);
    /** @ngInject */
    DashListCtrl.$inject = ["$scope", "$injector", "backendSrv", "dashboardSrv"];
    function DashListCtrl($scope, $injector, backendSrv, dashboardSrv) {
        var _this = _super.call(this, $scope, $injector) || this;
        _this.backendSrv = backendSrv;
        _this.dashboardSrv = dashboardSrv;
        _this.panelDefaults = {
            query: '',
            limit: 10,
            tags: [],
            recent: false,
            search: false,
            starred: true,
            headings: true,
        };
        __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.defaults(_this.panel, _this.panelDefaults);
        if (_this.panel.tag) {
            _this.panel.tags = [_this.panel.tag];
            delete _this.panel.tag;
        }
        _this.events.on('refresh', _this.onRefresh.bind(_this));
        _this.events.on('init-edit-mode', _this.onInitEditMode.bind(_this));
        _this.groups = [
            { list: [], show: false, header: "Starred dashboards", },
            { list: [], show: false, header: "Recently viewed dashboards" },
            { list: [], show: false, header: "Search" },
        ];
        // update capability
        if (_this.panel.mode) {
            if (_this.panel.mode === 'starred') {
                _this.panel.starred = true;
                _this.panel.headings = false;
            }
            if (_this.panel.mode === 'recently viewed') {
                _this.panel.recent = true;
                _this.panel.starred = false;
                _this.panel.headings = false;
            }
            if (_this.panel.mode === 'search') {
                _this.panel.search = true;
                _this.panel.starred = false;
                _this.panel.headings = false;
            }
            delete _this.panel.mode;
        }
        return _this;
    }
    DashListCtrl.prototype.onInitEditMode = function () {
        this.editorTabIndex = 1;
        this.modes = ['starred', 'search', 'recently viewed'];
        this.addEditorTab('Options', 'public/app/plugins/panel/dashlist/editor.html');
    };
    DashListCtrl.prototype.onRefresh = function () {
        var promises = [];
        promises.push(this.getRecentDashboards());
        promises.push(this.getStarred());
        promises.push(this.getSearch());
        return Promise.all(promises)
            .then(this.renderingCompleted.bind(this));
    };
    DashListCtrl.prototype.getSearch = function () {
        var _this = this;
        this.groups[2].show = this.panel.search;
        if (!this.panel.search) {
            return Promise.resolve();
        }
        var params = {
            limit: this.panel.limit,
            query: this.panel.query,
            tag: this.panel.tags,
        };
        return this.backendSrv.search(params).then(function (result) {
            _this.groups[2].list = result;
        });
    };
    DashListCtrl.prototype.getStarred = function () {
        var _this = this;
        this.groups[0].show = this.panel.starred;
        if (!this.panel.starred) {
            return Promise.resolve();
        }
        var params = { limit: this.panel.limit, starred: "true" };
        return this.backendSrv.search(params).then(function (result) {
            _this.groups[0].list = result;
        });
    };
    DashListCtrl.prototype.starDashboard = function (dash, evt) {
        this.dashboardSrv.starDashboard(dash.id, dash.isStarred).then(function (newState) {
            dash.isStarred = newState;
        });
        if (evt) {
            evt.stopPropagation();
            evt.preventDefault();
        }
    };
    DashListCtrl.prototype.getRecentDashboards = function () {
        var _this = this;
        this.groups[1].show = this.panel.recent;
        if (!this.panel.recent) {
            return Promise.resolve();
        }
        var dashIds = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.take(__WEBPACK_IMPORTED_MODULE_2_app_features_dashboard_impression_store__["impressions"].getDashboardOpened(), this.panel.limit);
        return this.backendSrv.search({ dashboardIds: dashIds, limit: this.panel.limit }).then(function (result) {
            _this.groups[1].list = dashIds.map(function (orderId) {
                return __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.find(result, function (dashboard) {
                    return dashboard.id === orderId;
                });
            }).filter(function (el) {
                return el !== undefined;
            });
        });
    };
    DashListCtrl.templateUrl = 'module.html';
    return DashListCtrl;
}(__WEBPACK_IMPORTED_MODULE_1_app_plugins_sdk__["PanelCtrl"]));



/***/ }),

/***/ 1495:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PluginListCtrl", function() { return PluginListCtrl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PanelCtrl", function() { return PluginListCtrl; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__features_panel_panel_ctrl__ = __webpack_require__(1313);
///<reference path="../../../headers/common.d.ts" />
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();


var PluginListCtrl = /** @class */ (function (_super) {
    __extends(PluginListCtrl, _super);
    /** @ngInject */
    PluginListCtrl.$inject = ["$scope", "$injector", "backendSrv", "$location"];
    function PluginListCtrl($scope, $injector, backendSrv, $location) {
        var _this = _super.call(this, $scope, $injector) || this;
        _this.backendSrv = backendSrv;
        _this.$location = $location;
        // Set and populate defaults
        _this.panelDefaults = {};
        __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.defaults(_this.panel, _this.panelDefaults);
        _this.events.on('init-edit-mode', _this.onInitEditMode.bind(_this));
        _this.pluginList = [];
        _this.viewModel = [
            { header: "Installed Apps", list: [], type: 'app' },
            { header: "Installed Panels", list: [], type: 'panel' },
            { header: "Installed Datasources", list: [], type: 'datasource' },
        ];
        _this.update();
        return _this;
    }
    PluginListCtrl.prototype.onInitEditMode = function () {
        this.editorTabIndex = 1;
        this.addEditorTab('Options', 'public/app/plugins/panel/pluginlist/editor.html');
    };
    PluginListCtrl.prototype.gotoPlugin = function (plugin, evt) {
        if (evt) {
            evt.stopPropagation();
        }
        this.$location.url("plugins/" + plugin.id + "/edit");
    };
    PluginListCtrl.prototype.updateAvailable = function (plugin, $event) {
        $event.stopPropagation();
        $event.preventDefault();
        var modalScope = this.$scope.$new(true);
        modalScope.plugin = plugin;
        this.publishAppEvent('show-modal', {
            src: 'public/app/features/plugins/partials/update_instructions.html',
            scope: modalScope
        });
    };
    PluginListCtrl.prototype.update = function () {
        var _this = this;
        this.backendSrv.get('api/plugins', { embedded: 0, core: 0 }).then(function (plugins) {
            _this.pluginList = plugins;
            _this.viewModel[0].list = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.filter(plugins, { type: 'app' });
            _this.viewModel[1].list = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.filter(plugins, { type: 'panel' });
            _this.viewModel[2].list = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.filter(plugins, { type: 'datasource' });
            for (var _i = 0, _a = _this.pluginList; _i < _a.length; _i++) {
                var plugin = _a[_i];
                if (plugin.hasUpdate) {
                    plugin.state = 'has-update';
                }
                else if (!plugin.enabled) {
                    plugin.state = 'not-enabled';
                }
            }
        });
    };
    PluginListCtrl.templateUrl = 'module.html';
    return PluginListCtrl;
}(__WEBPACK_IMPORTED_MODULE_1__features_panel_panel_ctrl__["a" /* PanelCtrl */]));



/***/ }),

/***/ 1496:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AlertListPanel", function() { return AlertListPanel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PanelCtrl", function() { return AlertListPanel; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_moment__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_moment___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_moment__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__features_alerting_alert_def__ = __webpack_require__(1307);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_app_plugins_sdk__ = __webpack_require__(1305);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_app_core_utils_datemath__ = __webpack_require__(467);
///<reference path="../../../headers/common.d.ts" />
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();





var AlertListPanel = /** @class */ (function (_super) {
    __extends(AlertListPanel, _super);
    /** @ngInject */
    AlertListPanel.$inject = ["$scope", "$injector", "backendSrv"];
    function AlertListPanel($scope, $injector, backendSrv) {
        var _this = _super.call(this, $scope, $injector) || this;
        _this.backendSrv = backendSrv;
        _this.showOptions = [
            { text: 'Current state', value: 'current' },
            { text: 'Recent state changes', value: 'changes' }
        ];
        _this.sortOrderOptions = [
            { text: 'Alphabetical (asc)', value: 1 },
            { text: 'Alphabetical (desc)', value: 2 },
            { text: 'Importance', value: 3 },
        ];
        _this.stateFilter = {};
        _this.currentAlerts = [];
        _this.alertHistory = [];
        // Set and populate defaults
        _this.panelDefaults = {
            show: 'current',
            limit: 10,
            stateFilter: [],
            onlyAlertsOnDashboard: false,
            sortOrder: 1
        };
        __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.defaults(_this.panel, _this.panelDefaults);
        _this.events.on('init-edit-mode', _this.onInitEditMode.bind(_this));
        _this.events.on('refresh', _this.onRefresh.bind(_this));
        for (var key in _this.panel.stateFilter) {
            _this.stateFilter[_this.panel.stateFilter[key]] = true;
        }
        return _this;
    }
    AlertListPanel.prototype.sortResult = function (alerts) {
        if (this.panel.sortOrder === 3) {
            return __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.sortBy(alerts, function (a) { return __WEBPACK_IMPORTED_MODULE_2__features_alerting_alert_def__["a" /* default */].alertStateSortScore[a.state]; });
        }
        var result = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.sortBy(alerts, function (a) { return a.name.toLowerCase(); });
        if (this.panel.sortOrder === 2) {
            result.reverse();
        }
        return result;
    };
    AlertListPanel.prototype.updateStateFilter = function () {
        var result = [];
        for (var key in this.stateFilter) {
            if (this.stateFilter[key]) {
                result.push(key);
            }
        }
        this.panel.stateFilter = result;
        this.onRefresh();
    };
    AlertListPanel.prototype.onRefresh = function () {
        if (this.panel.show === 'current') {
            this.getCurrentAlertState();
        }
        if (this.panel.show === 'changes') {
            this.getStateChanges();
        }
    };
    AlertListPanel.prototype.getStateChanges = function () {
        var _this = this;
        var params = {
            limit: this.panel.limit,
            type: 'alert',
            newState: this.panel.stateFilter,
        };
        if (this.panel.onlyAlertsOnDashboard) {
            params.dashboardId = this.dashboard.id;
        }
        params.from = __WEBPACK_IMPORTED_MODULE_4_app_core_utils_datemath__["parse"](this.dashboard.time.from).unix() * 1000;
        params.to = __WEBPACK_IMPORTED_MODULE_4_app_core_utils_datemath__["parse"](this.dashboard.time.to).unix() * 1000;
        this.backendSrv.get("/api/annotations", params)
            .then(function (res) {
            _this.alertHistory = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.map(res, function (al) {
                al.time = _this.dashboard.formatDate(al.time, 'MMM D, YYYY HH:mm:ss');
                al.stateModel = __WEBPACK_IMPORTED_MODULE_2__features_alerting_alert_def__["a" /* default */].getStateDisplayModel(al.newState);
                al.info = __WEBPACK_IMPORTED_MODULE_2__features_alerting_alert_def__["a" /* default */].getAlertAnnotationInfo(al);
                return al;
            });
            _this.noAlertsMessage = _this.alertHistory.length === 0 ? 'No alerts in current time range' : '';
        });
    };
    AlertListPanel.prototype.getCurrentAlertState = function () {
        var _this = this;
        var params = {
            state: this.panel.stateFilter
        };
        if (this.panel.onlyAlertsOnDashboard) {
            params.dashboardId = this.dashboard.id;
        }
        this.backendSrv.get("/api/alerts", params)
            .then(function (res) {
            _this.currentAlerts = _this.sortResult(__WEBPACK_IMPORTED_MODULE_0_lodash___default.a.map(res, function (al) {
                al.stateModel = __WEBPACK_IMPORTED_MODULE_2__features_alerting_alert_def__["a" /* default */].getStateDisplayModel(al.state);
                al.newStateDateAgo = __WEBPACK_IMPORTED_MODULE_1_moment___default()(al.newStateDate).locale('en').fromNow(true);
                return al;
            }));
            _this.noAlertsMessage = _this.currentAlerts.length === 0 ? 'No alerts' : '';
        });
    };
    AlertListPanel.prototype.onInitEditMode = function () {
        this.addEditorTab('Options', 'public/app/plugins/panel/alertlist/editor.html');
    };
    AlertListPanel.templateUrl = 'module.html';
    return AlertListPanel;
}(__WEBPACK_IMPORTED_MODULE_3_app_plugins_sdk__["PanelCtrl"]));



/***/ }),

/***/ 1497:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__color_legend__ = __webpack_require__(1498);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__heatmap_ctrl__ = __webpack_require__(1499);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "PanelCtrl", function() { return __WEBPACK_IMPORTED_MODULE_1__heatmap_ctrl__["a"]; });





/***/ }),

/***/ 1498:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_angular__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_angular___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_angular__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_lodash__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_jquery__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_jquery___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_jquery__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_d3__ = __webpack_require__(470);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_app_core_core__ = __webpack_require__(465);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_app_core_utils_ticks__ = __webpack_require__(1314);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__color_scale__ = __webpack_require__(1341);







var module = __WEBPACK_IMPORTED_MODULE_0_angular___default.a.module('grafana.directives');
/**
 * Color legend for heatmap editor.
 */
module.directive('colorLegend', function () {
    return {
        restrict: 'E',
        template: '<div class="heatmap-color-legend"><svg width="16.8rem" height="24px"></svg></div>',
        link: function (scope, elem, attrs) {
            var ctrl = scope.ctrl;
            var panel = scope.ctrl.panel;
            render();
            ctrl.events.on('render', function () {
                render();
            });
            function render() {
                var legendElem = __WEBPACK_IMPORTED_MODULE_2_jquery___default()(elem).find('svg');
                var legendWidth = Math.floor(legendElem.outerWidth());
                if (panel.color.mode === 'spectrum') {
                    var colorScheme = __WEBPACK_IMPORTED_MODULE_1_lodash___default.a.find(ctrl.colorSchemes, { value: panel.color.colorScheme });
                    var colorScale = Object(__WEBPACK_IMPORTED_MODULE_6__color_scale__["a" /* getColorScale */])(colorScheme, __WEBPACK_IMPORTED_MODULE_4_app_core_core__["contextSrv"].user.lightTheme, legendWidth);
                    drawSimpleColorLegend(elem, colorScale);
                }
                else if (panel.color.mode === 'opacity') {
                    var colorOptions = panel.color;
                    drawSimpleOpacityLegend(elem, colorOptions);
                }
            }
        }
    };
});
/**
 * Heatmap legend with scale values.
 */
module.directive('heatmapLegend', function () {
    return {
        restrict: 'E',
        template: '<div class="heatmap-color-legend"><svg width="100px" height="14px"></svg></div>',
        link: function (scope, elem, attrs) {
            var ctrl = scope.ctrl;
            var panel = scope.ctrl.panel;
            render();
            ctrl.events.on('render', function () {
                render();
            });
            function render() {
                clearLegend(elem);
                if (!__WEBPACK_IMPORTED_MODULE_1_lodash___default.a.isEmpty(ctrl.data) && !__WEBPACK_IMPORTED_MODULE_1_lodash___default.a.isEmpty(ctrl.data.cards)) {
                    var rangeFrom = 0;
                    var rangeTo = ctrl.data.cardStats.max;
                    var maxValue = panel.color.max || rangeTo;
                    var minValue = panel.color.min || 0;
                    if (panel.color.mode === 'spectrum') {
                        var colorScheme = __WEBPACK_IMPORTED_MODULE_1_lodash___default.a.find(ctrl.colorSchemes, { value: panel.color.colorScheme });
                        drawColorLegend(elem, colorScheme, rangeFrom, rangeTo, maxValue, minValue);
                    }
                    else if (panel.color.mode === 'opacity') {
                        var colorOptions = panel.color;
                        drawOpacityLegend(elem, colorOptions, rangeFrom, rangeTo, maxValue, minValue);
                    }
                }
            }
        }
    };
});
function drawColorLegend(elem, colorScheme, rangeFrom, rangeTo, maxValue, minValue) {
    var legendElem = __WEBPACK_IMPORTED_MODULE_2_jquery___default()(elem).find('svg');
    var legend = __WEBPACK_IMPORTED_MODULE_3_d3__["select"](legendElem.get(0));
    clearLegend(elem);
    var legendWidth = Math.floor(legendElem.outerWidth()) - 30;
    var legendHeight = legendElem.attr("height");
    var rangeStep = 1;
    if (rangeTo - rangeFrom > legendWidth) {
        rangeStep = Math.floor((rangeTo - rangeFrom) / legendWidth);
    }
    var widthFactor = legendWidth / (rangeTo - rangeFrom);
    var valuesRange = __WEBPACK_IMPORTED_MODULE_3_d3__["range"](rangeFrom, rangeTo, rangeStep);
    var colorScale = Object(__WEBPACK_IMPORTED_MODULE_6__color_scale__["a" /* getColorScale */])(colorScheme, __WEBPACK_IMPORTED_MODULE_4_app_core_core__["contextSrv"].user.lightTheme, maxValue, minValue);
    legend.selectAll(".heatmap-color-legend-rect")
        .data(valuesRange)
        .enter().append("rect")
        .attr("x", function (d) { return d * widthFactor; })
        .attr("y", 0)
        .attr("width", rangeStep * widthFactor + 1) // Overlap rectangles to prevent gaps
        .attr("height", legendHeight)
        .attr("stroke-width", 0)
        .attr("fill", function (d) { return colorScale(d); });
    drawLegendValues(elem, colorScale, rangeFrom, rangeTo, maxValue, minValue, legendWidth);
}
function drawOpacityLegend(elem, options, rangeFrom, rangeTo, maxValue, minValue) {
    var legendElem = __WEBPACK_IMPORTED_MODULE_2_jquery___default()(elem).find('svg');
    var legend = __WEBPACK_IMPORTED_MODULE_3_d3__["select"](legendElem.get(0));
    clearLegend(elem);
    var legendWidth = Math.floor(legendElem.outerWidth()) - 30;
    var legendHeight = legendElem.attr("height");
    var rangeStep = 1;
    if (rangeTo - rangeFrom > legendWidth) {
        rangeStep = Math.floor((rangeTo - rangeFrom) / legendWidth);
    }
    var widthFactor = legendWidth / (rangeTo - rangeFrom);
    var valuesRange = __WEBPACK_IMPORTED_MODULE_3_d3__["range"](rangeFrom, rangeTo, rangeStep);
    var opacityScale = Object(__WEBPACK_IMPORTED_MODULE_6__color_scale__["b" /* getOpacityScale */])(options, maxValue, minValue);
    legend.selectAll(".heatmap-opacity-legend-rect")
        .data(valuesRange)
        .enter().append("rect")
        .attr("x", function (d) { return d * widthFactor; })
        .attr("y", 0)
        .attr("width", rangeStep * widthFactor)
        .attr("height", legendHeight)
        .attr("stroke-width", 0)
        .attr("fill", options.cardColor)
        .style("opacity", function (d) { return opacityScale(d); });
    drawLegendValues(elem, opacityScale, rangeFrom, rangeTo, maxValue, minValue, legendWidth);
}
function drawLegendValues(elem, colorScale, rangeFrom, rangeTo, maxValue, minValue, legendWidth) {
    var legendElem = __WEBPACK_IMPORTED_MODULE_2_jquery___default()(elem).find('svg');
    var legend = __WEBPACK_IMPORTED_MODULE_3_d3__["select"](legendElem.get(0));
    if (legendWidth <= 0 || legendElem.get(0).childNodes.length === 0) {
        return;
    }
    var legendValueScale = __WEBPACK_IMPORTED_MODULE_3_d3__["scaleLinear"]()
        .domain([0, rangeTo])
        .range([0, legendWidth]);
    var ticks = buildLegendTicks(0, rangeTo, maxValue, minValue);
    var xAxis = __WEBPACK_IMPORTED_MODULE_3_d3__["axisBottom"](legendValueScale)
        .tickValues(ticks)
        .tickSize(2);
    var colorRect = legendElem.find(":first-child");
    var posY = getSvgElemHeight(legendElem) + 2;
    var posX = getSvgElemX(colorRect);
    __WEBPACK_IMPORTED_MODULE_3_d3__["select"](legendElem.get(0)).append("g")
        .attr("class", "axis")
        .attr("transform", "translate(" + posX + "," + posY + ")")
        .call(xAxis);
    legend.select(".axis").select(".domain").remove();
}
function drawSimpleColorLegend(elem, colorScale) {
    var legendElem = __WEBPACK_IMPORTED_MODULE_2_jquery___default()(elem).find('svg');
    clearLegend(elem);
    var legendWidth = Math.floor(legendElem.outerWidth());
    var legendHeight = legendElem.attr("height");
    if (legendWidth) {
        var valuesNumber = Math.floor(legendWidth / 2);
        var rangeStep = Math.floor(legendWidth / valuesNumber);
        var valuesRange = __WEBPACK_IMPORTED_MODULE_3_d3__["range"](0, legendWidth, rangeStep);
        var legend = __WEBPACK_IMPORTED_MODULE_3_d3__["select"](legendElem.get(0));
        var legendRects = legend.selectAll(".heatmap-color-legend-rect").data(valuesRange);
        legendRects.enter().append("rect")
            .attr("x", function (d) { return d; })
            .attr("y", 0)
            .attr("width", rangeStep + 1) // Overlap rectangles to prevent gaps
            .attr("height", legendHeight)
            .attr("stroke-width", 0)
            .attr("fill", function (d) { return colorScale(d); });
    }
}
function drawSimpleOpacityLegend(elem, options) {
    var legendElem = __WEBPACK_IMPORTED_MODULE_2_jquery___default()(elem).find('svg');
    clearLegend(elem);
    var legend = __WEBPACK_IMPORTED_MODULE_3_d3__["select"](legendElem.get(0));
    var legendWidth = Math.floor(legendElem.outerWidth());
    var legendHeight = legendElem.attr("height");
    if (legendWidth) {
        var legendOpacityScale_1;
        if (options.colorScale === 'linear') {
            legendOpacityScale_1 = __WEBPACK_IMPORTED_MODULE_3_d3__["scaleLinear"]()
                .domain([0, legendWidth])
                .range([0, 1]);
        }
        else if (options.colorScale === 'sqrt') {
            legendOpacityScale_1 = __WEBPACK_IMPORTED_MODULE_3_d3__["scalePow"]().exponent(options.exponent)
                .domain([0, legendWidth])
                .range([0, 1]);
        }
        var rangeStep = 10;
        var valuesRange = __WEBPACK_IMPORTED_MODULE_3_d3__["range"](0, legendWidth, rangeStep);
        var legendRects = legend.selectAll(".heatmap-opacity-legend-rect").data(valuesRange);
        legendRects.enter().append("rect")
            .attr("x", function (d) { return d; })
            .attr("y", 0)
            .attr("width", rangeStep)
            .attr("height", legendHeight)
            .attr("stroke-width", 0)
            .attr("fill", options.cardColor)
            .style("opacity", function (d) { return legendOpacityScale_1(d); });
    }
}
function clearLegend(elem) {
    var legendElem = __WEBPACK_IMPORTED_MODULE_2_jquery___default()(elem).find('svg');
    legendElem.empty();
}
function getSvgElemX(elem) {
    var svgElem = elem.get(0);
    if (svgElem && svgElem.x && svgElem.x.baseVal) {
        return svgElem.x.baseVal.value;
    }
    else {
        return 0;
    }
}
function getSvgElemHeight(elem) {
    var svgElem = elem.get(0);
    if (svgElem && svgElem.height && svgElem.height.baseVal) {
        return svgElem.height.baseVal.value;
    }
    else {
        return 0;
    }
}
function buildLegendTicks(rangeFrom, rangeTo, maxValue, minValue) {
    var range = rangeTo - rangeFrom;
    var tickStepSize = Object(__WEBPACK_IMPORTED_MODULE_5_app_core_utils_ticks__["tickStep"])(rangeFrom, rangeTo, 3);
    var ticksNum = Math.round(range / tickStepSize);
    var ticks = [];
    for (var i = 0; i < ticksNum; i++) {
        var current = tickStepSize * i;
        // Add user-defined min and max if it had been set
        if (isValueCloseTo(minValue, current, tickStepSize)) {
            ticks.push(minValue);
            continue;
        }
        else if (minValue < current) {
            ticks.push(minValue);
        }
        if (isValueCloseTo(maxValue, current, tickStepSize)) {
            ticks.push(maxValue);
            continue;
        }
        else if (maxValue < current) {
            ticks.push(maxValue);
        }
        ticks.push(tickStepSize * i);
    }
    if (!isValueCloseTo(maxValue, rangeTo, tickStepSize)) {
        ticks.push(maxValue);
    }
    ticks.push(rangeTo);
    ticks = __WEBPACK_IMPORTED_MODULE_1_lodash___default.a.sortBy(__WEBPACK_IMPORTED_MODULE_1_lodash___default.a.uniq(ticks));
    return ticks;
}
function isValueCloseTo(val, valueTo, step) {
    var diff = Math.abs(val - valueTo);
    return diff < step * 0.3;
}


/***/ }),

/***/ 1499:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return HeatmapCtrl; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_app_plugins_sdk__ = __webpack_require__(1305);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_lodash__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_app_core_utils_kbn__ = __webpack_require__(464);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_app_core_time_series2__ = __webpack_require__(1309);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__axes_editor__ = __webpack_require__(1500);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__display_editor__ = __webpack_require__(1501);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__rendering__ = __webpack_require__(1502);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__heatmap_data_converter__ = __webpack_require__(1318);
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();








var X_BUCKET_NUMBER_DEFAULT = 30;
var Y_BUCKET_NUMBER_DEFAULT = 10;
var panelDefaults = {
    heatmap: {},
    cards: {
        cardPadding: null,
        cardRound: null
    },
    color: {
        mode: 'spectrum',
        cardColor: '#b4ff00',
        colorScale: 'sqrt',
        exponent: 0.5,
        colorScheme: 'interpolateOranges',
    },
    legend: {
        show: false
    },
    dataFormat: 'timeseries',
    xAxis: {
        show: true,
    },
    yAxis: {
        show: true,
        format: 'short',
        decimals: null,
        logBase: 1,
        splitFactor: null,
        min: null,
        max: null,
    },
    xBucketSize: null,
    xBucketNumber: null,
    yBucketSize: null,
    yBucketNumber: null,
    tooltip: {
        show: true,
        showHistogram: false
    },
    highlightCards: true
};
var colorModes = ['opacity', 'spectrum'];
var opacityScales = ['linear', 'sqrt'];
// Schemes from d3-scale-chromatic
// https://github.com/d3/d3-scale-chromatic
var colorSchemes = [
    // Diverging
    { name: 'Spectral', value: 'interpolateSpectral', invert: 'always' },
    { name: 'RdYlGn', value: 'interpolateRdYlGn', invert: 'always' },
    // Sequential (Single Hue)
    { name: 'Blues', value: 'interpolateBlues', invert: 'dark' },
    { name: 'Greens', value: 'interpolateGreens', invert: 'dark' },
    { name: 'Greys', value: 'interpolateGreys', invert: 'dark' },
    { name: 'Oranges', value: 'interpolateOranges', invert: 'dark' },
    { name: 'Purples', value: 'interpolatePurples', invert: 'dark' },
    { name: 'Reds', value: 'interpolateReds', invert: 'dark' },
    // Sequential (Multi-Hue)
    { name: 'BuGn', value: 'interpolateBuGn', invert: 'dark' },
    { name: 'BuPu', value: 'interpolateBuPu', invert: 'dark' },
    { name: 'GnBu', value: 'interpolateGnBu', invert: 'dark' },
    { name: 'OrRd', value: 'interpolateOrRd', invert: 'dark' },
    { name: 'PuBuGn', value: 'interpolatePuBuGn', invert: 'dark' },
    { name: 'PuBu', value: 'interpolatePuBu', invert: 'dark' },
    { name: 'PuRd', value: 'interpolatePuRd', invert: 'dark' },
    { name: 'RdPu', value: 'interpolateRdPu', invert: 'dark' },
    { name: 'YlGnBu', value: 'interpolateYlGnBu', invert: 'dark' },
    { name: 'YlGn', value: 'interpolateYlGn', invert: 'dark' },
    { name: 'YlOrBr', value: 'interpolateYlOrBr', invert: 'dark' },
    { name: 'YlOrRd', value: 'interpolateYlOrRd', invert: 'darm' }
];
var HeatmapCtrl = /** @class */ (function (_super) {
    __extends(HeatmapCtrl, _super);
    /** @ngInject */
    HeatmapCtrl.$inject = ["$scope", "$injector", "$rootScope", "timeSrv"];
    function HeatmapCtrl($scope, $injector, $rootScope, timeSrv) {
        var _this = _super.call(this, $scope, $injector) || this;
        _this.$rootScope = $rootScope;
        _this.opacityScales = [];
        _this.colorModes = [];
        _this.colorSchemes = [];
        _this.$rootScope = $rootScope;
        _this.timeSrv = timeSrv;
        _this.selectionActivated = false;
        __WEBPACK_IMPORTED_MODULE_1_lodash___default.a.defaultsDeep(_this.panel, panelDefaults);
        _this.opacityScales = opacityScales;
        _this.colorModes = colorModes;
        _this.colorSchemes = colorSchemes;
        // Bind grafana panel events
        _this.events.on('render', _this.onRender.bind(_this));
        _this.events.on('data-received', _this.onDataReceived.bind(_this));
        _this.events.on('data-error', _this.onDataError.bind(_this));
        _this.events.on('data-snapshot-load', _this.onDataReceived.bind(_this));
        _this.events.on('init-edit-mode', _this.onInitEditMode.bind(_this));
        _this.onCardColorChange = _this.onCardColorChange.bind(_this);
        return _this;
    }
    HeatmapCtrl.prototype.onInitEditMode = function () {
        this.addEditorTab('Axes', __WEBPACK_IMPORTED_MODULE_4__axes_editor__["a" /* axesEditor */], 2);
        this.addEditorTab('Display', __WEBPACK_IMPORTED_MODULE_5__display_editor__["a" /* heatmapDisplayEditor */], 3);
        this.unitFormats = __WEBPACK_IMPORTED_MODULE_2_app_core_utils_kbn__["default"].getUnitFormats();
    };
    HeatmapCtrl.prototype.zoomOut = function (evt) {
        this.publishAppEvent('zoom-out', 2);
    };
    HeatmapCtrl.prototype.onRender = function () {
        if (!this.range) {
            return;
        }
        var xBucketSize, yBucketSize, heatmapStats, bucketsData;
        var logBase = this.panel.yAxis.logBase;
        if (this.panel.dataFormat === 'tsbuckets') {
            heatmapStats = this.parseHistogramSeries(this.series);
            bucketsData = Object(__WEBPACK_IMPORTED_MODULE_7__heatmap_data_converter__["d" /* elasticHistogramToHeatmap */])(this.series);
            // Calculate bucket size based on ES heatmap data
            var xBucketBoundSet = __WEBPACK_IMPORTED_MODULE_1_lodash___default.a.map(__WEBPACK_IMPORTED_MODULE_1_lodash___default.a.keys(bucketsData), function (key) { return Number(key); });
            var yBucketBoundSet = __WEBPACK_IMPORTED_MODULE_1_lodash___default.a.map(this.series, function (series) { return Number(series.alias); });
            xBucketSize = Object(__WEBPACK_IMPORTED_MODULE_7__heatmap_data_converter__["a" /* calculateBucketSize */])(xBucketBoundSet);
            yBucketSize = Object(__WEBPACK_IMPORTED_MODULE_7__heatmap_data_converter__["a" /* calculateBucketSize */])(yBucketBoundSet, logBase);
            if (logBase !== 1) {
                // Use yBucketSize in meaning of "Split factor" for log scales
                yBucketSize = 1 / yBucketSize;
            }
        }
        else {
            var xBucketNumber = this.panel.xBucketNumber || X_BUCKET_NUMBER_DEFAULT;
            var xBucketSizeByNumber = Math.floor((this.range.to - this.range.from) / xBucketNumber);
            // Parse X bucket size (number or interval)
            var isIntervalString = __WEBPACK_IMPORTED_MODULE_2_app_core_utils_kbn__["default"].interval_regex.test(this.panel.xBucketSize);
            if (isIntervalString) {
                xBucketSize = __WEBPACK_IMPORTED_MODULE_2_app_core_utils_kbn__["default"].interval_to_ms(this.panel.xBucketSize);
            }
            else if (isNaN(Number(this.panel.xBucketSize)) || this.panel.xBucketSize === '' || this.panel.xBucketSize === null) {
                xBucketSize = xBucketSizeByNumber;
            }
            else {
                xBucketSize = Number(this.panel.xBucketSize);
            }
            // Calculate Y bucket size
            heatmapStats = this.parseSeries(this.series);
            var yBucketNumber = this.panel.yBucketNumber || Y_BUCKET_NUMBER_DEFAULT;
            if (logBase !== 1) {
                yBucketSize = this.panel.yAxis.splitFactor;
            }
            else {
                if (heatmapStats.max === heatmapStats.min) {
                    if (heatmapStats.max) {
                        yBucketSize = heatmapStats.max / Y_BUCKET_NUMBER_DEFAULT;
                    }
                    else {
                        yBucketSize = 1;
                    }
                }
                else {
                    yBucketSize = (heatmapStats.max - heatmapStats.min) / yBucketNumber;
                }
                yBucketSize = this.panel.yBucketSize || yBucketSize;
            }
            bucketsData = Object(__WEBPACK_IMPORTED_MODULE_7__heatmap_data_converter__["c" /* convertToHeatMap */])(this.series, yBucketSize, xBucketSize, logBase);
        }
        // Set default Y range if no data
        if (!heatmapStats.min && !heatmapStats.max) {
            heatmapStats = { min: -1, max: 1, minLog: 1 };
            yBucketSize = 1;
        }
        var _a = Object(__WEBPACK_IMPORTED_MODULE_7__heatmap_data_converter__["b" /* convertToCards */])(bucketsData), cards = _a.cards, cardStats = _a.cardStats;
        this.data = {
            buckets: bucketsData,
            heatmapStats: heatmapStats,
            xBucketSize: xBucketSize,
            yBucketSize: yBucketSize,
            cards: cards,
            cardStats: cardStats
        };
    };
    HeatmapCtrl.prototype.onDataReceived = function (dataList) {
        this.series = dataList.map(this.seriesHandler.bind(this));
        this.dataWarning = null;
        var datapointsCount = __WEBPACK_IMPORTED_MODULE_1_lodash___default.a.reduce(this.series, function (sum, series) {
            return sum + series.datapoints.length;
        }, 0);
        if (datapointsCount === 0) {
            this.dataWarning = {
                title: 'No data points',
                tip: 'No datapoints returned from data query'
            };
        }
        else {
            for (var _i = 0, _a = this.series; _i < _a.length; _i++) {
                var series = _a[_i];
                if (series.isOutsideRange) {
                    this.dataWarning = {
                        title: 'Data points outside time range',
                        tip: 'Can be caused by timezone mismatch or missing time filter in query',
                    };
                    break;
                }
            }
        }
        this.render();
    };
    HeatmapCtrl.prototype.onDataError = function () {
        this.series = [];
        this.render();
    };
    HeatmapCtrl.prototype.onCardColorChange = function (newColor) {
        this.panel.color.cardColor = newColor;
        this.render();
    };
    HeatmapCtrl.prototype.seriesHandler = function (seriesData) {
        var series = new __WEBPACK_IMPORTED_MODULE_3_app_core_time_series2__["a" /* default */]({
            datapoints: seriesData.datapoints,
            alias: seriesData.target
        });
        series.flotpairs = series.getFlotPairs(this.panel.nullPointMode);
        var datapoints = seriesData.datapoints || [];
        if (datapoints && datapoints.length > 0) {
            var last = datapoints[datapoints.length - 1][1];
            var from = this.range.from;
            if (last - from < -10000) {
                series.isOutsideRange = true;
            }
        }
        return series;
    };
    HeatmapCtrl.prototype.parseSeries = function (series) {
        var min = __WEBPACK_IMPORTED_MODULE_1_lodash___default.a.min(__WEBPACK_IMPORTED_MODULE_1_lodash___default.a.map(series, function (s) { return s.stats.min; }));
        var minLog = __WEBPACK_IMPORTED_MODULE_1_lodash___default.a.min(__WEBPACK_IMPORTED_MODULE_1_lodash___default.a.map(series, function (s) { return s.stats.logmin; }));
        var max = __WEBPACK_IMPORTED_MODULE_1_lodash___default.a.max(__WEBPACK_IMPORTED_MODULE_1_lodash___default.a.map(series, function (s) { return s.stats.max; }));
        return {
            max: max,
            min: min,
            minLog: minLog
        };
    };
    HeatmapCtrl.prototype.parseHistogramSeries = function (series) {
        var bounds = __WEBPACK_IMPORTED_MODULE_1_lodash___default.a.map(series, function (s) { return Number(s.alias); });
        var min = __WEBPACK_IMPORTED_MODULE_1_lodash___default.a.min(bounds);
        var minLog = __WEBPACK_IMPORTED_MODULE_1_lodash___default.a.min(bounds);
        var max = __WEBPACK_IMPORTED_MODULE_1_lodash___default.a.max(bounds);
        return {
            max: max,
            min: min,
            minLog: minLog
        };
    };
    HeatmapCtrl.prototype.link = function (scope, elem, attrs, ctrl) {
        Object(__WEBPACK_IMPORTED_MODULE_6__rendering__["a" /* default */])(scope, elem, attrs, ctrl);
    };
    HeatmapCtrl.templateUrl = 'module.html';
    return HeatmapCtrl;
}(__WEBPACK_IMPORTED_MODULE_0_app_plugins_sdk__["MetricsPanelCtrl"]));



/***/ }),

/***/ 1500:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export AxesEditorCtrl */
/* harmony export (immutable) */ __webpack_exports__["a"] = axesEditor;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_app_core_utils_kbn__ = __webpack_require__(464);
///<reference path="../../../headers/common.d.ts" />

var AxesEditorCtrl = /** @class */ (function () {
    /** @ngInject */
    AxesEditorCtrl.$inject = ["$scope", "uiSegmentSrv"];
    function AxesEditorCtrl($scope, uiSegmentSrv) {
        $scope.editor = this;
        this.panelCtrl = $scope.ctrl;
        this.panel = this.panelCtrl.panel;
        this.unitFormats = __WEBPACK_IMPORTED_MODULE_0_app_core_utils_kbn__["default"].getUnitFormats();
        this.logScales = {
            'linear': 1,
            'log (base 2)': 2,
            'log (base 10)': 10,
            'log (base 32)': 32,
            'log (base 1024)': 1024
        };
        this.dataFormats = {
            'Time series': 'timeseries',
            'Time series buckets': 'tsbuckets'
        };
    }
    AxesEditorCtrl.prototype.setUnitFormat = function (subItem) {
        this.panel.yAxis.format = subItem.value;
        this.panelCtrl.render();
    };
    return AxesEditorCtrl;
}());

/** @ngInject */
function axesEditor() {
    'use strict';
    return {
        restrict: 'E',
        scope: true,
        templateUrl: 'public/app/plugins/panel/heatmap/partials/axes_editor.html',
        controller: AxesEditorCtrl,
    };
}


/***/ }),

/***/ 1501:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export HeatmapDisplayEditorCtrl */
/* harmony export (immutable) */ __webpack_exports__["a"] = heatmapDisplayEditor;
///<reference path="../../../headers/common.d.ts" />
var HeatmapDisplayEditorCtrl = /** @class */ (function () {
    /** @ngInject */
    HeatmapDisplayEditorCtrl.$inject = ["$scope"];
    function HeatmapDisplayEditorCtrl($scope) {
        $scope.editor = this;
        this.panelCtrl = $scope.ctrl;
        this.panel = this.panelCtrl.panel;
        this.panelCtrl.render();
    }
    return HeatmapDisplayEditorCtrl;
}());

/** @ngInject */
function heatmapDisplayEditor() {
    'use strict';
    return {
        restrict: 'E',
        scope: true,
        templateUrl: 'public/app/plugins/panel/heatmap/partials/display_editor.html',
        controller: HeatmapDisplayEditorCtrl,
    };
}


/***/ }),

/***/ 1502:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = link;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_jquery__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_jquery___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_jquery__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_moment__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_moment___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_moment__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_d3__ = __webpack_require__(470);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_app_core_utils_kbn__ = __webpack_require__(464);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_app_core_core__ = __webpack_require__(465);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_app_core_utils_ticks__ = __webpack_require__(1314);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__heatmap_tooltip__ = __webpack_require__(1503);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__heatmap_data_converter__ = __webpack_require__(1318);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__color_scale__ = __webpack_require__(1341);










var MIN_CARD_SIZE = 1, CARD_PADDING = 1, CARD_ROUND = 0, DATA_RANGE_WIDING_FACTOR = 1.2, DEFAULT_X_TICK_SIZE_PX = 100, DEFAULT_Y_TICK_SIZE_PX = 50, X_AXIS_TICK_PADDING = 10, Y_AXIS_TICK_PADDING = 5, MIN_SELECTION_WIDTH = 2;
function link(scope, elem, attrs, ctrl) {
    var data, timeRange, panel, heatmap;
    // $heatmap is JQuery object, but heatmap is D3
    var $heatmap = elem.find('.heatmap-panel');
    var tooltip = new __WEBPACK_IMPORTED_MODULE_7__heatmap_tooltip__["a" /* HeatmapTooltip */]($heatmap, scope);
    var width, height, yScale, xScale, chartWidth, chartHeight, chartTop, chartBottom, yAxisWidth, xAxisHeight, cardPadding, cardRound, cardWidth, cardHeight, colorScale, opacityScale, mouseUpHandler;
    var selection = {
        active: false,
        x1: -1,
        x2: -1
    };
    var padding = { left: 0, right: 0, top: 0, bottom: 0 }, margin = { left: 25, right: 15, top: 10, bottom: 20 }, dataRangeWidingFactor = DATA_RANGE_WIDING_FACTOR;
    ctrl.events.on('render', function () {
        render();
        ctrl.renderingCompleted();
    });
    function setElementHeight() {
        try {
            var height = ctrl.height || panel.height || ctrl.row.height;
            if (__WEBPACK_IMPORTED_MODULE_0_lodash___default.a.isString(height)) {
                height = parseInt(height.replace('px', ''), 10);
            }
            height -= 5; // padding
            height -= panel.title ? 24 : 9; // subtract panel title bar
            $heatmap.css('height', height + 'px');
            return true;
        }
        catch (e) {
            return false;
        }
    }
    function getYAxisWidth(elem) {
        var axis_text = elem.selectAll(".axis-y text").nodes();
        var max_text_width = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.max(__WEBPACK_IMPORTED_MODULE_0_lodash___default.a.map(axis_text, function (text) {
            // Use SVG getBBox method
            return text.getBBox().width;
        }));
        return max_text_width;
    }
    function getXAxisHeight(elem) {
        var axis_line = elem.select(".axis-x line");
        if (!axis_line.empty()) {
            var axis_line_position = parseFloat(elem.select(".axis-x line").attr("y2"));
            var canvas_width = parseFloat(elem.attr("height"));
            return canvas_width - axis_line_position;
        }
        else {
            // Default height
            return 30;
        }
    }
    function addXAxis() {
        scope.xScale = xScale = __WEBPACK_IMPORTED_MODULE_3_d3__["scaleTime"]()
            .domain([timeRange.from, timeRange.to])
            .range([0, chartWidth]);
        var ticks = chartWidth / DEFAULT_X_TICK_SIZE_PX;
        var grafanaTimeFormatter = grafanaTimeFormat(ticks, timeRange.from, timeRange.to);
        var timeFormat;
        var dashboardTimeZone = ctrl.dashboard.getTimezone();
        if (dashboardTimeZone === 'utc') {
            timeFormat = __WEBPACK_IMPORTED_MODULE_3_d3__["utcFormat"](grafanaTimeFormatter);
        }
        else {
            timeFormat = __WEBPACK_IMPORTED_MODULE_3_d3__["timeFormat"](grafanaTimeFormatter);
        }
        var xAxis = __WEBPACK_IMPORTED_MODULE_3_d3__["axisBottom"](xScale)
            .ticks(ticks)
            .tickFormat(timeFormat)
            .tickPadding(X_AXIS_TICK_PADDING)
            .tickSize(chartHeight);
        var posY = margin.top;
        var posX = yAxisWidth;
        heatmap.append("g")
            .attr("class", "axis axis-x")
            .attr("transform", "translate(" + posX + "," + posY + ")")
            .call(xAxis);
        // Remove horizontal line in the top of axis labels (called domain in d3)
        heatmap.select(".axis-x").select(".domain").remove();
    }
    function addYAxis() {
        var ticks = Math.ceil(chartHeight / DEFAULT_Y_TICK_SIZE_PX);
        var tick_interval = Object(__WEBPACK_IMPORTED_MODULE_6_app_core_utils_ticks__["tickStep"])(data.heatmapStats.min, data.heatmapStats.max, ticks);
        var _a = wideYAxisRange(data.heatmapStats.min, data.heatmapStats.max, tick_interval), y_min = _a.y_min, y_max = _a.y_max;
        // Rewrite min and max if it have been set explicitly
        y_min = panel.yAxis.min !== null ? panel.yAxis.min : y_min;
        y_max = panel.yAxis.max !== null ? panel.yAxis.max : y_max;
        // Adjust ticks after Y range widening
        tick_interval = Object(__WEBPACK_IMPORTED_MODULE_6_app_core_utils_ticks__["tickStep"])(y_min, y_max, ticks);
        ticks = Math.ceil((y_max - y_min) / tick_interval);
        var decimalsAuto = getPrecision(tick_interval);
        var decimals = panel.yAxis.decimals === null ? decimalsAuto : panel.yAxis.decimals;
        // Calculate scaledDecimals for log scales using tick size (as in jquery.flot.js)
        var flot_tick_size = Object(__WEBPACK_IMPORTED_MODULE_6_app_core_utils_ticks__["getFlotTickSize"])(y_min, y_max, ticks, decimalsAuto);
        var scaledDecimals = Object(__WEBPACK_IMPORTED_MODULE_6_app_core_utils_ticks__["getScaledDecimals"])(decimals, flot_tick_size);
        ctrl.decimals = decimals;
        ctrl.scaledDecimals = scaledDecimals;
        // Set default Y min and max if no data
        if (__WEBPACK_IMPORTED_MODULE_0_lodash___default.a.isEmpty(data.buckets)) {
            y_max = 1;
            y_min = -1;
            ticks = 3;
            decimals = 1;
        }
        data.yAxis = {
            min: y_min,
            max: y_max,
            ticks: ticks
        };
        scope.yScale = yScale = __WEBPACK_IMPORTED_MODULE_3_d3__["scaleLinear"]()
            .domain([y_min, y_max])
            .range([chartHeight, 0]);
        var yAxis = __WEBPACK_IMPORTED_MODULE_3_d3__["axisLeft"](yScale)
            .ticks(ticks)
            .tickFormat(tickValueFormatter(decimals, scaledDecimals))
            .tickSizeInner(0 - width)
            .tickSizeOuter(0)
            .tickPadding(Y_AXIS_TICK_PADDING);
        heatmap.append("g")
            .attr("class", "axis axis-y")
            .call(yAxis);
        // Calculate Y axis width first, then move axis into visible area
        var posY = margin.top;
        var posX = getYAxisWidth(heatmap) + Y_AXIS_TICK_PADDING;
        heatmap.select(".axis-y").attr("transform", "translate(" + posX + "," + posY + ")");
        // Remove vertical line in the right of axis labels (called domain in d3)
        heatmap.select(".axis-y").select(".domain").remove();
    }
    // Wide Y values range and anjust to bucket size
    function wideYAxisRange(min, max, tickInterval) {
        var y_widing = (max * (dataRangeWidingFactor - 1) - min * (dataRangeWidingFactor - 1)) / 2;
        var y_min, y_max;
        if (tickInterval === 0) {
            y_max = max * dataRangeWidingFactor;
            y_min = min - min * (dataRangeWidingFactor - 1);
            tickInterval = (y_max - y_min) / 2;
        }
        else {
            y_max = Math.ceil((max + y_widing) / tickInterval) * tickInterval;
            y_min = Math.floor((min - y_widing) / tickInterval) * tickInterval;
        }
        // Don't wide axis below 0 if all values are positive
        if (min >= 0 && y_min < 0) {
            y_min = 0;
        }
        return { y_min: y_min, y_max: y_max };
    }
    function addLogYAxis() {
        var log_base = panel.yAxis.logBase;
        var _a = adjustLogRange(data.heatmapStats.minLog, data.heatmapStats.max, log_base), y_min = _a.y_min, y_max = _a.y_max;
        y_min = panel.yAxis.min && panel.yAxis.min !== '0' ? adjustLogMin(panel.yAxis.min, log_base) : y_min;
        y_max = panel.yAxis.max !== null ? adjustLogMax(panel.yAxis.max, log_base) : y_max;
        // Set default Y min and max if no data
        if (__WEBPACK_IMPORTED_MODULE_0_lodash___default.a.isEmpty(data.buckets)) {
            y_max = Math.pow(log_base, 2);
            y_min = 1;
        }
        scope.yScale = yScale = __WEBPACK_IMPORTED_MODULE_3_d3__["scaleLog"]()
            .base(panel.yAxis.logBase)
            .domain([y_min, y_max])
            .range([chartHeight, 0]);
        var domain = yScale.domain();
        var tick_values = logScaleTickValues(domain, log_base);
        var decimalsAuto = getPrecision(y_min);
        var decimals = panel.yAxis.decimals || decimalsAuto;
        // Calculate scaledDecimals for log scales using tick size (as in jquery.flot.js)
        var flot_tick_size = Object(__WEBPACK_IMPORTED_MODULE_6_app_core_utils_ticks__["getFlotTickSize"])(y_min, y_max, tick_values.length, decimalsAuto);
        var scaledDecimals = Object(__WEBPACK_IMPORTED_MODULE_6_app_core_utils_ticks__["getScaledDecimals"])(decimals, flot_tick_size);
        ctrl.decimals = decimals;
        ctrl.scaledDecimals = scaledDecimals;
        data.yAxis = {
            min: y_min,
            max: y_max,
            ticks: tick_values.length
        };
        var yAxis = __WEBPACK_IMPORTED_MODULE_3_d3__["axisLeft"](yScale)
            .tickValues(tick_values)
            .tickFormat(tickValueFormatter(decimals, scaledDecimals))
            .tickSizeInner(0 - width)
            .tickSizeOuter(0)
            .tickPadding(Y_AXIS_TICK_PADDING);
        heatmap.append("g")
            .attr("class", "axis axis-y")
            .call(yAxis);
        // Calculate Y axis width first, then move axis into visible area
        var posY = margin.top;
        var posX = getYAxisWidth(heatmap) + Y_AXIS_TICK_PADDING;
        heatmap.select(".axis-y").attr("transform", "translate(" + posX + "," + posY + ")");
        // Set first tick as pseudo 0
        if (y_min < 1) {
            heatmap.select(".axis-y").select(".tick text").text("0");
        }
        // Remove vertical line in the right of axis labels (called domain in d3)
        heatmap.select(".axis-y").select(".domain").remove();
    }
    // Adjust data range to log base
    function adjustLogRange(min, max, logBase) {
        var y_min, y_max;
        y_min = data.heatmapStats.minLog;
        if (data.heatmapStats.minLog > 1 || !data.heatmapStats.minLog) {
            y_min = 1;
        }
        else {
            y_min = adjustLogMin(data.heatmapStats.minLog, logBase);
        }
        // Adjust max Y value to log base
        y_max = adjustLogMax(data.heatmapStats.max, logBase);
        return { y_min: y_min, y_max: y_max };
    }
    function adjustLogMax(max, base) {
        return Math.pow(base, Math.ceil(logp(max, base)));
    }
    function adjustLogMin(min, base) {
        return Math.pow(base, Math.floor(logp(min, base)));
    }
    function logScaleTickValues(domain, base) {
        var domainMin = domain[0];
        var domainMax = domain[1];
        var tickValues = [];
        if (domainMin < 1) {
            var under_one_ticks = Math.floor(logp(domainMin, base));
            for (var i = under_one_ticks; i < 0; i++) {
                var tick_value = Math.pow(base, i);
                tickValues.push(tick_value);
            }
        }
        var ticks = Math.ceil(logp(domainMax, base));
        for (var i = 0; i <= ticks; i++) {
            var tick_value = Math.pow(base, i);
            tickValues.push(tick_value);
        }
        return tickValues;
    }
    function tickValueFormatter(decimals, scaledDecimals) {
        if (scaledDecimals === void 0) { scaledDecimals = null; }
        var format = panel.yAxis.format;
        return function (value) {
            return __WEBPACK_IMPORTED_MODULE_4_app_core_utils_kbn__["default"].valueFormats[format](value, decimals, scaledDecimals);
        };
    }
    function fixYAxisTickSize() {
        heatmap.select(".axis-y")
            .selectAll(".tick line")
            .attr("x2", chartWidth);
    }
    function addAxes() {
        chartHeight = height - margin.top - margin.bottom;
        chartTop = margin.top;
        chartBottom = chartTop + chartHeight;
        if (panel.yAxis.logBase === 1) {
            addYAxis();
        }
        else {
            addLogYAxis();
        }
        yAxisWidth = getYAxisWidth(heatmap) + Y_AXIS_TICK_PADDING;
        chartWidth = width - yAxisWidth - margin.right;
        fixYAxisTickSize();
        addXAxis();
        xAxisHeight = getXAxisHeight(heatmap);
        if (!panel.yAxis.show) {
            heatmap.select(".axis-y").selectAll("line").style("opacity", 0);
        }
        if (!panel.xAxis.show) {
            heatmap.select(".axis-x").selectAll("line").style("opacity", 0);
        }
    }
    function addHeatmapCanvas() {
        var heatmap_elem = $heatmap[0];
        width = Math.floor($heatmap.width()) - padding.right;
        height = Math.floor($heatmap.height()) - padding.bottom;
        cardPadding = panel.cards.cardPadding !== null ? panel.cards.cardPadding : CARD_PADDING;
        cardRound = panel.cards.cardRound !== null ? panel.cards.cardRound : CARD_ROUND;
        if (heatmap) {
            heatmap.remove();
        }
        heatmap = __WEBPACK_IMPORTED_MODULE_3_d3__["select"](heatmap_elem)
            .append("svg")
            .attr("width", width)
            .attr("height", height);
    }
    function addHeatmap() {
        addHeatmapCanvas();
        addAxes();
        if (panel.yAxis.logBase !== 1) {
            var log_base = panel.yAxis.logBase;
            var domain = yScale.domain();
            var tick_values = logScaleTickValues(domain, log_base);
            data.buckets = Object(__WEBPACK_IMPORTED_MODULE_8__heatmap_data_converter__["f" /* mergeZeroBuckets */])(data.buckets, __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.min(tick_values));
        }
        var cardsData = data.cards;
        var maxValueAuto = data.cardStats.max;
        var maxValue = panel.color.max || maxValueAuto;
        var minValue = panel.color.min || 0;
        var colorScheme = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.find(ctrl.colorSchemes, { value: panel.color.colorScheme });
        colorScale = Object(__WEBPACK_IMPORTED_MODULE_9__color_scale__["a" /* getColorScale */])(colorScheme, __WEBPACK_IMPORTED_MODULE_5_app_core_core__["contextSrv"].user.lightTheme, maxValue, minValue);
        opacityScale = Object(__WEBPACK_IMPORTED_MODULE_9__color_scale__["b" /* getOpacityScale */])(panel.color, maxValue);
        setCardSize();
        var cards = heatmap.selectAll(".heatmap-card").data(cardsData);
        cards.append("title");
        cards = cards.enter().append("rect")
            .attr("x", getCardX)
            .attr("width", getCardWidth)
            .attr("y", getCardY)
            .attr("height", getCardHeight)
            .attr("rx", cardRound)
            .attr("ry", cardRound)
            .attr("class", "bordered heatmap-card")
            .style("fill", getCardColor)
            .style("stroke", getCardColor)
            .style("stroke-width", 0)
            .style("opacity", getCardOpacity);
        var $cards = $heatmap.find(".heatmap-card");
        $cards.on("mouseenter", function (event) {
            tooltip.mouseOverBucket = true;
            highlightCard(event);
        })
            .on("mouseleave", function (event) {
            tooltip.mouseOverBucket = false;
            resetCardHighLight(event);
        });
    }
    function highlightCard(event) {
        var color = __WEBPACK_IMPORTED_MODULE_3_d3__["select"](event.target).style("fill");
        var highlightColor = __WEBPACK_IMPORTED_MODULE_3_d3__["color"](color).darker(2);
        var strokeColor = __WEBPACK_IMPORTED_MODULE_3_d3__["color"](color).brighter(4);
        var current_card = __WEBPACK_IMPORTED_MODULE_3_d3__["select"](event.target);
        tooltip.originalFillColor = color;
        current_card.style("fill", highlightColor.toString())
            .style("stroke", strokeColor.toString())
            .style("stroke-width", 1);
    }
    function resetCardHighLight(event) {
        __WEBPACK_IMPORTED_MODULE_3_d3__["select"](event.target).style("fill", tooltip.originalFillColor)
            .style("stroke", tooltip.originalFillColor)
            .style("stroke-width", 0);
    }
    function setCardSize() {
        var xGridSize = Math.floor(xScale(data.xBucketSize) - xScale(0));
        var yGridSize = Math.floor(yScale(yScale.invert(0) - data.yBucketSize));
        if (panel.yAxis.logBase !== 1) {
            var base = panel.yAxis.logBase;
            var splitFactor = data.yBucketSize || 1;
            yGridSize = Math.floor((yScale(1) - yScale(base)) / splitFactor);
        }
        cardWidth = xGridSize - cardPadding * 2;
        cardHeight = yGridSize ? yGridSize - cardPadding * 2 : 0;
    }
    function getCardX(d) {
        var x;
        if (xScale(d.x) < 0) {
            // Cut card left to prevent overlay
            x = yAxisWidth + cardPadding;
        }
        else {
            x = xScale(d.x) + yAxisWidth + cardPadding;
        }
        return x;
    }
    function getCardWidth(d) {
        var w;
        if (xScale(d.x) < 0) {
            // Cut card left to prevent overlay
            var cutted_width = xScale(d.x) + cardWidth;
            w = cutted_width > 0 ? cutted_width : 0;
        }
        else if (xScale(d.x) + cardWidth > chartWidth) {
            // Cut card right to prevent overlay
            w = chartWidth - xScale(d.x) - cardPadding;
        }
        else {
            w = cardWidth;
        }
        // Card width should be MIN_CARD_SIZE at least
        w = Math.max(w, MIN_CARD_SIZE);
        return w;
    }
    function getCardY(d) {
        var y = yScale(d.y) + chartTop - cardHeight - cardPadding;
        if (panel.yAxis.logBase !== 1 && d.y === 0) {
            y = chartBottom - cardHeight - cardPadding;
        }
        else {
            if (y < chartTop) {
                y = chartTop;
            }
        }
        return y;
    }
    function getCardHeight(d) {
        var y = yScale(d.y) + chartTop - cardHeight - cardPadding;
        var h = cardHeight;
        if (panel.yAxis.logBase !== 1 && d.y === 0) {
            return cardHeight;
        }
        // Cut card height to prevent overlay
        if (y < chartTop) {
            h = yScale(d.y) - cardPadding;
        }
        else if (yScale(d.y) > chartBottom) {
            h = chartBottom - y;
        }
        else if (y + cardHeight > chartBottom) {
            h = chartBottom - y;
        }
        // Height can't be more than chart height
        h = Math.min(h, chartHeight);
        // Card height should be MIN_CARD_SIZE at least
        h = Math.max(h, MIN_CARD_SIZE);
        return h;
    }
    function getCardColor(d) {
        if (panel.color.mode === 'opacity') {
            return panel.color.cardColor;
        }
        else {
            return colorScale(d.count);
        }
    }
    function getCardOpacity(d) {
        if (panel.color.mode === 'opacity') {
            return opacityScale(d.count);
        }
        else {
            return 1;
        }
    }
    /////////////////////////////
    // Selection and crosshair //
    /////////////////////////////
    // Shared crosshair and tooltip
    __WEBPACK_IMPORTED_MODULE_5_app_core_core__["appEvents"].on('graph-hover', function (event) {
        drawSharedCrosshair(event.pos);
    }, scope);
    __WEBPACK_IMPORTED_MODULE_5_app_core_core__["appEvents"].on('graph-hover-clear', function () {
        clearCrosshair();
    }, scope);
    function onMouseDown(event) {
        selection.active = true;
        selection.x1 = event.offsetX;
        mouseUpHandler = function () {
            onMouseUp();
        };
        __WEBPACK_IMPORTED_MODULE_1_jquery___default()(document).one("mouseup", mouseUpHandler);
    }
    function onMouseUp() {
        __WEBPACK_IMPORTED_MODULE_1_jquery___default()(document).unbind("mouseup", mouseUpHandler);
        mouseUpHandler = null;
        selection.active = false;
        var selectionRange = Math.abs(selection.x2 - selection.x1);
        if (selection.x2 >= 0 && selectionRange > MIN_SELECTION_WIDTH) {
            var timeFrom = xScale.invert(Math.min(selection.x1, selection.x2) - yAxisWidth);
            var timeTo = xScale.invert(Math.max(selection.x1, selection.x2) - yAxisWidth);
            ctrl.timeSrv.setTime({
                from: __WEBPACK_IMPORTED_MODULE_2_moment___default.a.utc(timeFrom),
                to: __WEBPACK_IMPORTED_MODULE_2_moment___default.a.utc(timeTo)
            });
        }
        clearSelection();
    }
    function onMouseLeave() {
        __WEBPACK_IMPORTED_MODULE_5_app_core_core__["appEvents"].emit('graph-hover-clear');
        clearCrosshair();
    }
    function onMouseMove(event) {
        if (!heatmap) {
            return;
        }
        if (selection.active) {
            // Clear crosshair and tooltip
            clearCrosshair();
            tooltip.destroy();
            selection.x2 = limitSelection(event.offsetX);
            drawSelection(selection.x1, selection.x2);
        }
        else {
            emitGraphHoverEvet(event);
            drawCrosshair(event.offsetX);
            tooltip.show(event, data);
        }
    }
    function emitGraphHoverEvet(event) {
        var x = xScale.invert(event.offsetX - yAxisWidth).valueOf();
        var y = yScale.invert(event.offsetY);
        var pos = {
            pageX: event.pageX,
            pageY: event.pageY,
            x: x, x1: x,
            y: y, y1: y,
            panelRelY: null
        };
        // Set minimum offset to prevent showing legend from another panel
        pos.panelRelY = Math.max(event.offsetY / height, 0.001);
        // broadcast to other graph panels that we are hovering
        __WEBPACK_IMPORTED_MODULE_5_app_core_core__["appEvents"].emit('graph-hover', { pos: pos, panel: panel });
    }
    function limitSelection(x2) {
        x2 = Math.max(x2, yAxisWidth);
        x2 = Math.min(x2, chartWidth + yAxisWidth);
        return x2;
    }
    function drawSelection(posX1, posX2) {
        if (heatmap) {
            heatmap.selectAll(".heatmap-selection").remove();
            var selectionX = Math.min(posX1, posX2);
            var selectionWidth = Math.abs(posX1 - posX2);
            if (selectionWidth > MIN_SELECTION_WIDTH) {
                heatmap.append("rect")
                    .attr("class", "heatmap-selection")
                    .attr("x", selectionX)
                    .attr("width", selectionWidth)
                    .attr("y", chartTop)
                    .attr("height", chartHeight);
            }
        }
    }
    function clearSelection() {
        selection.x1 = -1;
        selection.x2 = -1;
        if (heatmap) {
            heatmap.selectAll(".heatmap-selection").remove();
        }
    }
    function drawCrosshair(position) {
        if (heatmap) {
            heatmap.selectAll(".heatmap-crosshair").remove();
            var posX = position;
            posX = Math.max(posX, yAxisWidth);
            posX = Math.min(posX, chartWidth + yAxisWidth);
            heatmap.append("g")
                .attr("class", "heatmap-crosshair")
                .attr("transform", "translate(" + posX + ",0)")
                .append("line")
                .attr("x1", 1)
                .attr("y1", chartTop)
                .attr("x2", 1)
                .attr("y2", chartBottom)
                .attr("stroke-width", 1);
        }
    }
    function drawSharedCrosshair(pos) {
        if (heatmap && ctrl.dashboard.graphTooltip !== 0) {
            var posX = xScale(pos.x) + yAxisWidth;
            drawCrosshair(posX);
        }
    }
    function clearCrosshair() {
        if (heatmap) {
            heatmap.selectAll(".heatmap-crosshair").remove();
        }
    }
    function render() {
        data = ctrl.data;
        panel = ctrl.panel;
        timeRange = ctrl.range;
        if (!setElementHeight() || !data) {
            return;
        }
        // Draw default axes and return if no data
        if (__WEBPACK_IMPORTED_MODULE_0_lodash___default.a.isEmpty(data.buckets)) {
            addHeatmapCanvas();
            addAxes();
            return;
        }
        addHeatmap();
        scope.yAxisWidth = yAxisWidth;
        scope.xAxisHeight = xAxisHeight;
        scope.chartHeight = chartHeight;
        scope.chartWidth = chartWidth;
        scope.chartTop = chartTop;
    }
    // Register selection listeners
    $heatmap.on("mousedown", onMouseDown);
    $heatmap.on("mousemove", onMouseMove);
    $heatmap.on("mouseleave", onMouseLeave);
}
function grafanaTimeFormat(ticks, min, max) {
    if (min && max && ticks) {
        var range = max - min;
        var secPerTick = (range / ticks) / 1000;
        var oneDay = 86400000;
        var oneYear = 31536000000;
        if (secPerTick <= 45) {
            return "%H:%M:%S";
        }
        if (secPerTick <= 7200 || range <= oneDay) {
            return "%H:%M";
        }
        if (secPerTick <= 80000) {
            return "%m/%d %H:%M";
        }
        if (secPerTick <= 2419200 || range <= oneYear) {
            return "%m/%d";
        }
        return "%Y-%m";
    }
    return "%H:%M";
}
function logp(value, base) {
    return Math.log(value) / Math.log(base);
}
function getPrecision(num) {
    var str = num.toString();
    var dot_index = str.indexOf(".");
    if (dot_index === -1) {
        return 0;
    }
    else {
        return str.length - dot_index - 1;
    }
}


/***/ }),

/***/ 1503:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return HeatmapTooltip; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_d3__ = __webpack_require__(470);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_jquery__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_jquery___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_jquery__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_lodash__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_app_core_utils_kbn__ = __webpack_require__(464);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__heatmap_data_converter__ = __webpack_require__(1318);





var TOOLTIP_PADDING_X = 30;
var TOOLTIP_PADDING_Y = 5;
var HISTOGRAM_WIDTH = 160;
var HISTOGRAM_HEIGHT = 40;
var HeatmapTooltip = /** @class */ (function () {
    function HeatmapTooltip(elem, scope) {
        this.scope = scope;
        this.dashboard = scope.ctrl.dashboard;
        this.panelCtrl = scope.ctrl;
        this.panel = scope.ctrl.panel;
        this.heatmapPanel = elem;
        this.mouseOverBucket = false;
        this.originalFillColor = null;
        elem.on("mouseover", this.onMouseOver.bind(this));
        elem.on("mouseleave", this.onMouseLeave.bind(this));
    }
    HeatmapTooltip.prototype.onMouseOver = function (e) {
        if (!this.panel.tooltip.show || !this.scope.ctrl.data || __WEBPACK_IMPORTED_MODULE_2_lodash___default.a.isEmpty(this.scope.ctrl.data.buckets)) {
            return;
        }
        if (!this.tooltip) {
            this.add();
            this.move(e);
        }
    };
    HeatmapTooltip.prototype.onMouseLeave = function () {
        this.destroy();
    };
    HeatmapTooltip.prototype.onMouseMove = function (e) {
        if (!this.panel.tooltip.show) {
            return;
        }
        this.move(e);
    };
    HeatmapTooltip.prototype.add = function () {
        this.tooltip = __WEBPACK_IMPORTED_MODULE_0_d3__["select"]("body")
            .append("div")
            .attr("class", "heatmap-tooltip graph-tooltip grafana-tooltip");
    };
    HeatmapTooltip.prototype.destroy = function () {
        if (this.tooltip) {
            this.tooltip.remove();
        }
        this.tooltip = null;
    };
    HeatmapTooltip.prototype.show = function (pos, data) {
        if (!this.panel.tooltip.show || !data) {
            return;
        }
        // shared tooltip mode
        if (pos.panelRelY) {
            return;
        }
        var _a = this.getBucketIndexes(pos, data), xBucketIndex = _a.xBucketIndex, yBucketIndex = _a.yBucketIndex;
        if (!data.buckets[xBucketIndex] || !this.tooltip) {
            this.destroy();
            return;
        }
        var boundBottom, boundTop, valuesNumber;
        var xData = data.buckets[xBucketIndex];
        // Search in special 'zero' bucket also
        var yData = __WEBPACK_IMPORTED_MODULE_2_lodash___default.a.find(xData.buckets, function (bucket, bucketIndex) {
            return bucket.bounds.bottom === yBucketIndex || bucketIndex === yBucketIndex;
        });
        var tooltipTimeFormat = 'YYYY-MM-DD HH:mm:ss';
        var time = this.dashboard.formatDate(xData.x, tooltipTimeFormat);
        // Decimals override. Code from panel/graph/graph.ts
        var valueFormatter;
        if (__WEBPACK_IMPORTED_MODULE_2_lodash___default.a.isNumber(this.panel.tooltipDecimals)) {
            valueFormatter = this.valueFormatter(this.panel.tooltipDecimals, null);
        }
        else {
            // auto decimals
            // legend and tooltip gets one more decimal precision
            // than graph legend ticks
            var decimals = (this.panelCtrl.decimals || -1) + 1;
            valueFormatter = this.valueFormatter(decimals, this.panelCtrl.scaledDecimals + 2);
        }
        var tooltipHtml = "<div class=\"graph-tooltip-time\">" + time + "</div>\n      <div class=\"heatmap-histogram\"></div>";
        if (yData) {
            if (yData.bounds) {
                // Display 0 if bucket is a special 'zero' bucket
                var bottom = yData.y ? yData.bounds.bottom : 0;
                boundBottom = valueFormatter(bottom);
                boundTop = valueFormatter(yData.bounds.top);
                valuesNumber = yData.count;
                tooltipHtml += "<div>\n          bucket: <b>" + boundBottom + " - " + boundTop + "</b> <br>\n          count: <b>" + valuesNumber + "</b> <br>\n        </div>";
            }
            else {
                // currently no bounds for pre bucketed data
                tooltipHtml += "<div>count: <b>" + yData.count + "</b><br></div>";
            }
        }
        else {
            if (!this.panel.tooltip.showHistogram) {
                this.destroy();
                return;
            }
            boundBottom = yBucketIndex;
            boundTop = '';
            valuesNumber = 0;
        }
        this.tooltip.html(tooltipHtml);
        if (this.panel.tooltip.showHistogram) {
            this.addHistogram(xData);
        }
        this.move(pos);
    };
    HeatmapTooltip.prototype.getBucketIndexes = function (pos, data) {
        var xBucketIndex = this.getXBucketIndex(pos.offsetX, data);
        var yBucketIndex = this.getYBucketIndex(pos.offsetY, data);
        return { xBucketIndex: xBucketIndex, yBucketIndex: yBucketIndex };
    };
    HeatmapTooltip.prototype.getXBucketIndex = function (offsetX, data) {
        var x = this.scope.xScale.invert(offsetX - this.scope.yAxisWidth).valueOf();
        var xBucketIndex = Object(__WEBPACK_IMPORTED_MODULE_4__heatmap_data_converter__["e" /* getValueBucketBound */])(x, data.xBucketSize, 1);
        return xBucketIndex;
    };
    HeatmapTooltip.prototype.getYBucketIndex = function (offsetY, data) {
        var y = this.scope.yScale.invert(offsetY - this.scope.chartTop);
        var yBucketIndex = Object(__WEBPACK_IMPORTED_MODULE_4__heatmap_data_converter__["e" /* getValueBucketBound */])(y, data.yBucketSize, this.panel.yAxis.logBase);
        return yBucketIndex;
    };
    HeatmapTooltip.prototype.getSharedTooltipPos = function (pos) {
        // get pageX from position on x axis and pageY from relative position in original panel
        pos.pageX = this.heatmapPanel.offset().left + this.scope.xScale(pos.x);
        pos.pageY = this.heatmapPanel.offset().top + this.scope.chartHeight * pos.panelRelY;
        return pos;
    };
    HeatmapTooltip.prototype.addHistogram = function (data) {
        var xBucket = this.scope.ctrl.data.buckets[data.x];
        var yBucketSize = this.scope.ctrl.data.yBucketSize;
        var _a = this.scope.ctrl.data.yAxis, min = _a.min, max = _a.max, ticks = _a.ticks;
        var histogramData = __WEBPACK_IMPORTED_MODULE_2_lodash___default.a.map(xBucket.buckets, function (bucket) {
            return [bucket.bounds.bottom, bucket.values.length];
        });
        histogramData = __WEBPACK_IMPORTED_MODULE_2_lodash___default.a.filter(histogramData, function (d) {
            return d[0] >= min && d[0] <= max;
        });
        var scale = this.scope.yScale.copy();
        var histXScale = scale
            .domain([min, max])
            .range([0, HISTOGRAM_WIDTH]);
        var barWidth;
        if (this.panel.yAxis.logBase === 1) {
            barWidth = Math.floor(HISTOGRAM_WIDTH / (max - min) * yBucketSize * 0.9);
        }
        else {
            var barNumberFactor = yBucketSize ? yBucketSize : 1;
            barWidth = Math.floor(HISTOGRAM_WIDTH / ticks / barNumberFactor * 0.9);
        }
        barWidth = Math.max(barWidth, 1);
        // Normalize histogram Y axis
        var histogramDomain = __WEBPACK_IMPORTED_MODULE_2_lodash___default.a.reduce(__WEBPACK_IMPORTED_MODULE_2_lodash___default.a.map(histogramData, function (d) { return d[1]; }), function (sum, val) { return sum + val; }, 0);
        var histYScale = __WEBPACK_IMPORTED_MODULE_0_d3__["scaleLinear"]()
            .domain([0, histogramDomain])
            .range([0, HISTOGRAM_HEIGHT]);
        var histogram = this.tooltip.select(".heatmap-histogram")
            .append("svg")
            .attr("width", HISTOGRAM_WIDTH)
            .attr("height", HISTOGRAM_HEIGHT);
        histogram.selectAll(".bar").data(histogramData)
            .enter().append("rect")
            .attr("x", function (d) {
            return histXScale(d[0]);
        })
            .attr("width", barWidth)
            .attr("y", function (d) {
            return HISTOGRAM_HEIGHT - histYScale(d[1]);
        })
            .attr("height", function (d) {
            return histYScale(d[1]);
        });
    };
    HeatmapTooltip.prototype.move = function (pos) {
        if (!this.tooltip) {
            return;
        }
        var elem = __WEBPACK_IMPORTED_MODULE_1_jquery___default()(this.tooltip.node())[0];
        var tooltipWidth = elem.clientWidth;
        var tooltipHeight = elem.clientHeight;
        var left = pos.pageX + TOOLTIP_PADDING_X;
        var top = pos.pageY + TOOLTIP_PADDING_Y;
        if (pos.pageX + tooltipWidth + 40 > window.innerWidth) {
            left = pos.pageX - tooltipWidth - TOOLTIP_PADDING_X;
        }
        if (pos.pageY - window.pageYOffset + tooltipHeight + 20 > window.innerHeight) {
            top = pos.pageY - tooltipHeight - TOOLTIP_PADDING_Y;
        }
        return this.tooltip
            .style("left", left + "px")
            .style("top", top + "px");
    };
    HeatmapTooltip.prototype.valueFormatter = function (decimals, scaledDecimals) {
        if (scaledDecimals === void 0) { scaledDecimals = null; }
        var format = this.panel.yAxis.format;
        return function (value) {
            return __WEBPACK_IMPORTED_MODULE_3_app_core_utils_kbn__["default"].valueFormats[format](value, decimals, scaledDecimals);
        };
    };
    return HeatmapTooltip;
}());



/***/ }),

/***/ 1504:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TablePanelCtrl", function() { return TablePanelCtrl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PanelCtrl", function() { return TablePanelCtrl; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_jquery__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_jquery___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_jquery__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_app_plugins_sdk__ = __webpack_require__(1305);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__transformers__ = __webpack_require__(1342);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__editor__ = __webpack_require__(1505);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__column_options__ = __webpack_require__(1506);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__renderer__ = __webpack_require__(1507);
///<reference path="../../../headers/common.d.ts" />
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();







var TablePanelCtrl = /** @class */ (function (_super) {
    __extends(TablePanelCtrl, _super);
    /** @ngInject */
    TablePanelCtrl.$inject = ["$scope", "$injector", "templateSrv", "annotationsSrv", "$sanitize", "variableSrv"];
    function TablePanelCtrl($scope, $injector, templateSrv, annotationsSrv, $sanitize, variableSrv) {
        var _this = _super.call(this, $scope, $injector) || this;
        _this.annotationsSrv = annotationsSrv;
        _this.$sanitize = $sanitize;
        _this.variableSrv = variableSrv;
        _this.panelDefaults = {
            targets: [{}],
            transform: 'timeseries_to_columns',
            pageSize: null,
            showHeader: true,
            styles: [
                {
                    type: 'date',
                    pattern: 'Time',
                    alias: 'Time',
                    dateFormat: 'YYYY-MM-DD HH:mm:ss',
                },
                {
                    unit: 'short',
                    type: 'number',
                    alias: '',
                    decimals: 2,
                    colors: ["rgba(245, 54, 54, 0.9)", "rgba(237, 129, 40, 0.89)", "rgba(50, 172, 45, 0.97)"],
                    colorMode: null,
                    pattern: '/.*/',
                    thresholds: [],
                }
            ],
            columns: [],
            scroll: true,
            fontSize: '100%',
            sort: { col: 0, desc: true },
        };
        _this.pageIndex = 0;
        if (_this.panel.styles === void 0) {
            _this.panel.styles = _this.panel.columns;
            _this.panel.columns = _this.panel.fields;
            delete _this.panel.columns;
            delete _this.panel.fields;
        }
        __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.defaults(_this.panel, _this.panelDefaults);
        _this.events.on('data-received', _this.onDataReceived.bind(_this));
        _this.events.on('data-error', _this.onDataError.bind(_this));
        _this.events.on('data-snapshot-load', _this.onDataReceived.bind(_this));
        _this.events.on('init-edit-mode', _this.onInitEditMode.bind(_this));
        _this.events.on('init-panel-actions', _this.onInitPanelActions.bind(_this));
        return _this;
    }
    TablePanelCtrl.prototype.onInitEditMode = function () {
        this.addEditorTab('Options', __WEBPACK_IMPORTED_MODULE_4__editor__["a" /* tablePanelEditor */], 2);
        this.addEditorTab('Column Styles', __WEBPACK_IMPORTED_MODULE_5__column_options__["a" /* columnOptionsTab */], 3);
    };
    TablePanelCtrl.prototype.onInitPanelActions = function (actions) {
        actions.push({ text: 'Export CSV', click: 'ctrl.exportCsv()' });
    };
    TablePanelCtrl.prototype.issueQueries = function (datasource) {
        this.pageIndex = 0;
        if (this.panel.transform === 'annotations') {
            this.setTimeQueryStart();
            return this.annotationsSrv.getAnnotations({ dashboard: this.dashboard, panel: this.panel, range: this.range })
                .then(function (annotations) {
                return { data: annotations };
            });
        }
        return _super.prototype.issueQueries.call(this, datasource);
    };
    TablePanelCtrl.prototype.onDataError = function (err) {
        this.dataRaw = [];
        this.render();
    };
    TablePanelCtrl.prototype.onDataReceived = function (dataList) {
        this.dataRaw = dataList;
        this.pageIndex = 0;
        // automatically correct transform mode based on data
        if (this.dataRaw && this.dataRaw.length) {
            if (this.dataRaw[0].type === 'table') {
                this.panel.transform = 'table';
            }
            else {
                if (this.dataRaw[0].type === 'docs') {
                    this.panel.transform = 'json';
                }
                else {
                    if (this.panel.transform === 'table' || this.panel.transform === 'json') {
                        this.panel.transform = 'timeseries_to_rows';
                    }
                }
            }
        }
        this.render();
    };
    TablePanelCtrl.prototype.render = function () {
        this.table = Object(__WEBPACK_IMPORTED_MODULE_3__transformers__["a" /* transformDataToTable */])(this.dataRaw, this.panel);
        this.table.sort(this.panel.sort);
        this.renderer = new __WEBPACK_IMPORTED_MODULE_6__renderer__["a" /* TableRenderer */](this.panel, this.table, this.dashboard.isTimezoneUtc(), this.$sanitize, this.templateSrv);
        return _super.prototype.render.call(this, this.table);
    };
    TablePanelCtrl.prototype.toggleColumnSort = function (col, colIndex) {
        // remove sort flag from current column
        if (this.table.columns[this.panel.sort.col]) {
            this.table.columns[this.panel.sort.col].sort = false;
        }
        if (this.panel.sort.col === colIndex) {
            if (this.panel.sort.desc) {
                this.panel.sort.desc = false;
            }
            else {
                this.panel.sort.col = null;
            }
        }
        else {
            this.panel.sort.col = colIndex;
            this.panel.sort.desc = true;
        }
        this.render();
    };
    TablePanelCtrl.prototype.exportCsv = function () {
        var scope = this.$scope.$new(true);
        scope.tableData = this.renderer.render_values();
        scope.panel = 'table';
        this.publishAppEvent('show-modal', {
            templateHtml: '<export-data-modal panel="panel" data="tableData"></export-data-modal>',
            scope: scope,
            modalClass: 'modal--narrow'
        });
    };
    TablePanelCtrl.prototype.link = function (scope, elem, attrs, ctrl) {
        var data;
        var panel = ctrl.panel;
        var pageCount = 0;
        function getTableHeight() {
            var panelHeight = ctrl.height;
            if (pageCount > 1) {
                panelHeight -= 26;
            }
            return (panelHeight - 31) + 'px';
        }
        function appendTableRows(tbodyElem) {
            ctrl.renderer.setTable(data);
            tbodyElem.empty();
            tbodyElem.html(ctrl.renderer.render(ctrl.pageIndex));
        }
        function switchPage(e) {
            var el = __WEBPACK_IMPORTED_MODULE_1_jquery___default()(e.currentTarget);
            ctrl.pageIndex = (parseInt(el.text(), 10) - 1);
            renderPanel();
        }
        function appendPaginationControls(footerElem) {
            footerElem.empty();
            var pageSize = panel.pageSize || 100;
            pageCount = Math.ceil(data.rows.length / pageSize);
            if (pageCount === 1) {
                return;
            }
            var startPage = Math.max(ctrl.pageIndex - 3, 0);
            var endPage = Math.min(pageCount, startPage + 9);
            var paginationList = __WEBPACK_IMPORTED_MODULE_1_jquery___default()('<ul></ul>');
            for (var i = startPage; i < endPage; i++) {
                var activeClass = i === ctrl.pageIndex ? 'active' : '';
                var pageLinkElem = __WEBPACK_IMPORTED_MODULE_1_jquery___default()('<li><a class="table-panel-page-link pointer ' + activeClass + '">' + (i + 1) + '</a></li>');
                paginationList.append(pageLinkElem);
            }
            footerElem.append(paginationList);
        }
        function renderPanel() {
            var panelElem = elem.parents('.panel');
            var rootElem = elem.find('.table-panel-scroll');
            var tbodyElem = elem.find('tbody');
            var footerElem = elem.find('.table-panel-footer');
            elem.css({ 'font-size': panel.fontSize });
            panelElem.addClass('table-panel-wrapper');
            appendTableRows(tbodyElem);
            appendPaginationControls(footerElem);
            rootElem.css({ 'max-height': panel.scroll ? getTableHeight() : '' });
        }
        // hook up link tooltips
        elem.tooltip({
            selector: '[data-link-tooltip]'
        });
        function addFilterClicked(e) {
            var filterData = __WEBPACK_IMPORTED_MODULE_1_jquery___default()(e.currentTarget).data();
            var options = {
                datasource: panel.datasource,
                key: data.columns[filterData.column].text,
                value: data.rows[filterData.row][filterData.column],
                operator: filterData.operator,
            };
            ctrl.variableSrv.setAdhocFilter(options);
        }
        elem.on('click', '.table-panel-page-link', switchPage);
        elem.on('click', '.table-panel-filter-link', addFilterClicked);
        var unbindDestroy = scope.$on('$destroy', function () {
            elem.off('click', '.table-panel-page-link');
            elem.off('click', '.table-panel-filter-link');
            unbindDestroy();
        });
        ctrl.events.on('render', function (renderData) {
            data = renderData || data;
            if (data) {
                renderPanel();
            }
            ctrl.renderingCompleted();
        });
    };
    TablePanelCtrl.templateUrl = 'module.html';
    return TablePanelCtrl;
}(__WEBPACK_IMPORTED_MODULE_2_app_plugins_sdk__["MetricsPanelCtrl"]));



/***/ }),

/***/ 1505:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export TablePanelEditorCtrl */
/* harmony export (immutable) */ 
tablePanelEditor.$inject = ["$q", "uiSegmentSrv"];__webpack_exports__["a"] = tablePanelEditor;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__transformers__ = __webpack_require__(1342);
///<reference path="../../../headers/common.d.ts" />


var TablePanelEditorCtrl = /** @class */ (function () {
    /** @ngInject */
    TablePanelEditorCtrl.$inject = ["$scope", "$q", "uiSegmentSrv"];
    function TablePanelEditorCtrl($scope, $q, uiSegmentSrv) {
        this.$q = $q;
        this.uiSegmentSrv = uiSegmentSrv;
        $scope.editor = this;
        this.panelCtrl = $scope.ctrl;
        this.panel = this.panelCtrl.panel;
        this.transformers = __WEBPACK_IMPORTED_MODULE_1__transformers__["b" /* transformers */];
        this.fontSizes = ['80%', '90%', '100%', '110%', '120%', '130%', '150%', '160%', '180%', '200%', '220%', '250%'];
        this.addColumnSegment = uiSegmentSrv.newPlusButton();
        this.updateTransformHints();
    }
    TablePanelEditorCtrl.prototype.updateTransformHints = function () {
        this.canSetColumns = false;
        this.columnsHelpMessage = '';
        switch (this.panel.transform) {
            case "timeseries_aggregations": {
                this.canSetColumns = true;
                break;
            }
            case "json": {
                this.canSetColumns = true;
                break;
            }
            case "table": {
                this.columnsHelpMessage = "Columns and their order are determined by the data query";
            }
        }
    };
    TablePanelEditorCtrl.prototype.getColumnOptions = function () {
        var _this = this;
        if (!this.panelCtrl.dataRaw) {
            return this.$q.when([]);
        }
        var columns = this.transformers[this.panel.transform].getColumns(this.panelCtrl.dataRaw);
        var segments = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.map(columns, function (c) { return _this.uiSegmentSrv.newSegment({ value: c.text }); });
        return this.$q.when(segments);
    };
    TablePanelEditorCtrl.prototype.addColumn = function () {
        var columns = __WEBPACK_IMPORTED_MODULE_1__transformers__["b" /* transformers */][this.panel.transform].getColumns(this.panelCtrl.dataRaw);
        var column = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.find(columns, { text: this.addColumnSegment.value });
        if (column) {
            this.panel.columns.push(column);
            this.render();
        }
        var plusButton = this.uiSegmentSrv.newPlusButton();
        this.addColumnSegment.html = plusButton.html;
        this.addColumnSegment.value = plusButton.value;
    };
    TablePanelEditorCtrl.prototype.transformChanged = function () {
        this.panel.columns = [];
        if (this.panel.transform === 'timeseries_aggregations') {
            this.panel.columns.push({ text: 'Avg', value: 'avg' });
        }
        this.updateTransformHints();
        this.render();
    };
    TablePanelEditorCtrl.prototype.render = function () {
        this.panelCtrl.render();
    };
    TablePanelEditorCtrl.prototype.removeColumn = function (column) {
        this.panel.columns = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.without(this.panel.columns, column);
        this.panelCtrl.render();
    };
    return TablePanelEditorCtrl;
}());

/** @ngInject */
function tablePanelEditor($q, uiSegmentSrv) {
    'use strict';
    return {
        restrict: 'E',
        scope: true,
        templateUrl: 'public/app/plugins/panel/table/editor.html',
        controller: TablePanelEditorCtrl,
    };
}


/***/ }),

/***/ 1506:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export ColumnOptionsCtrl */
/* harmony export (immutable) */ 
columnOptionsTab.$inject = ["$q", "uiSegmentSrv"];__webpack_exports__["a"] = columnOptionsTab;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_app_core_utils_kbn__ = __webpack_require__(464);
///<reference path="../../../headers/common.d.ts" />


var ColumnOptionsCtrl = /** @class */ (function () {
    /** @ngInject */
    ColumnOptionsCtrl.$inject = ["$scope"];
    function ColumnOptionsCtrl($scope) {
        var _this = this;
        $scope.editor = this;
        this.activeStyleIndex = 0;
        this.panelCtrl = $scope.ctrl;
        this.panel = this.panelCtrl.panel;
        this.unitFormats = __WEBPACK_IMPORTED_MODULE_1_app_core_utils_kbn__["default"].getUnitFormats();
        this.colorModes = [
            { text: 'Disabled', value: null },
            { text: 'Cell', value: 'cell' },
            { text: 'Value', value: 'value' },
            { text: 'Row', value: 'row' },
        ];
        this.columnTypes = [
            { text: 'Number', value: 'number' },
            { text: 'String', value: 'string' },
            { text: 'Date', value: 'date' },
            { text: 'Hidden', value: 'hidden' }
        ];
        this.fontSizes = ['80%', '90%', '100%', '110%', '120%', '130%', '150%', '160%', '180%', '200%', '220%', '250%'];
        this.dateFormats = [
            { text: 'YYYY-MM-DD HH:mm:ss', value: 'YYYY-MM-DD HH:mm:ss' },
            { text: 'YYYY-MM-DD HH:mm:ss.SSS', value: 'YYYY-MM-DD HH:mm:ss.SSS' },
            { text: 'MM/DD/YY h:mm:ss a', value: 'MM/DD/YY h:mm:ss a' },
            { text: 'MMMM D, YYYY LT', value: 'MMMM D, YYYY LT' },
        ];
        this.getColumnNames = function () {
            if (!_this.panelCtrl.table) {
                return [];
            }
            return __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.map(_this.panelCtrl.table.columns, function (col) {
                return col.text;
            });
        };
        this.onColorChange = this.onColorChange.bind(this);
    }
    ColumnOptionsCtrl.prototype.render = function () {
        this.panelCtrl.render();
    };
    ColumnOptionsCtrl.prototype.setUnitFormat = function (column, subItem) {
        column.unit = subItem.value;
        this.panelCtrl.render();
    };
    ColumnOptionsCtrl.prototype.addColumnStyle = function () {
        var newStyleRule = {
            unit: 'short',
            type: 'number',
            alias: '',
            decimals: 2,
            colors: ["rgba(245, 54, 54, 0.9)", "rgba(237, 129, 40, 0.89)", "rgba(50, 172, 45, 0.97)"],
            colorMode: null,
            pattern: '',
            dateFormat: 'YYYY-MM-DD HH:mm:ss',
            thresholds: [],
        };
        var styles = this.panel.styles;
        var stylesCount = styles.length;
        var indexToInsert = stylesCount;
        // check if last is a catch all rule, then add it before that one
        if (stylesCount > 0) {
            var last = styles[stylesCount - 1];
            if (last.pattern === '/.*/') {
                indexToInsert = stylesCount - 1;
            }
        }
        styles.splice(indexToInsert, 0, newStyleRule);
        this.activeStyleIndex = indexToInsert;
    };
    ColumnOptionsCtrl.prototype.removeColumnStyle = function (style) {
        this.panel.styles = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.without(this.panel.styles, style);
    };
    ColumnOptionsCtrl.prototype.invertColorOrder = function (index) {
        var ref = this.panel.styles[index].colors;
        var copy = ref[0];
        ref[0] = ref[2];
        ref[2] = copy;
        this.panelCtrl.render();
    };
    ColumnOptionsCtrl.prototype.onColorChange = function (styleIndex, colorIndex) {
        var _this = this;
        return function (newColor) {
            _this.panel.styles[styleIndex].colors[colorIndex] = newColor;
            _this.render();
        };
    };
    return ColumnOptionsCtrl;
}());

/** @ngInject */
function columnOptionsTab($q, uiSegmentSrv) {
    'use strict';
    return {
        restrict: 'E',
        scope: true,
        templateUrl: 'public/app/plugins/panel/table/column_options.html',
        controller: ColumnOptionsCtrl,
    };
}


/***/ }),

/***/ 1507:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return TableRenderer; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_moment__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_moment___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_moment__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_app_core_utils_kbn__ = __webpack_require__(464);



var TableRenderer = /** @class */ (function () {
    function TableRenderer(panel, table, isUtc, sanitize, templateSrv) {
        this.panel = panel;
        this.table = table;
        this.isUtc = isUtc;
        this.sanitize = sanitize;
        this.templateSrv = templateSrv;
        this.initColumns();
    }
    TableRenderer.prototype.setTable = function (table) {
        this.table = table;
        this.initColumns();
    };
    TableRenderer.prototype.initColumns = function () {
        this.formatters = [];
        this.colorState = {};
        for (var colIndex = 0; colIndex < this.table.columns.length; colIndex++) {
            var column = this.table.columns[colIndex];
            column.title = column.text;
            for (var i = 0; i < this.panel.styles.length; i++) {
                var style = this.panel.styles[i];
                var regex = __WEBPACK_IMPORTED_MODULE_2_app_core_utils_kbn__["default"].stringToJsRegex(style.pattern);
                if (column.text.match(regex)) {
                    column.style = style;
                    if (style.alias) {
                        column.title = column.text.replace(regex, style.alias);
                    }
                    break;
                }
            }
            this.formatters[colIndex] = this.createColumnFormatter(column);
        }
    };
    TableRenderer.prototype.getColorForValue = function (value, style) {
        if (!style.thresholds) {
            return null;
        }
        for (var i = style.thresholds.length; i > 0; i--) {
            if (value >= style.thresholds[i - 1]) {
                return style.colors[i];
            }
        }
        return __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.first(style.colors);
    };
    TableRenderer.prototype.defaultCellFormatter = function (v, style) {
        if (v === null || v === void 0 || v === undefined) {
            return '';
        }
        if (__WEBPACK_IMPORTED_MODULE_0_lodash___default.a.isArray(v)) {
            v = v.join(', ');
        }
        if (style && style.sanitize) {
            return this.sanitize(v);
        }
        else {
            return __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.escape(v);
        }
    };
    TableRenderer.prototype.createColumnFormatter = function (column) {
        var _this = this;
        if (!column.style) {
            return this.defaultCellFormatter;
        }
        if (column.style.type === 'hidden') {
            return function (v) {
                return undefined;
            };
        }
        if (column.style.type === 'date') {
            return function (v) {
                if (v === undefined || v === null) {
                    return '-';
                }
                if (__WEBPACK_IMPORTED_MODULE_0_lodash___default.a.isArray(v)) {
                    v = v[0];
                }
                var date = __WEBPACK_IMPORTED_MODULE_1_moment___default()(v);
                if (_this.isUtc) {
                    date = date.utc();
                }
                return date.format(column.style.dateFormat);
            };
        }
        if (column.style.type === 'number') {
            var valueFormatter_1 = __WEBPACK_IMPORTED_MODULE_2_app_core_utils_kbn__["default"].valueFormats[column.unit || column.style.unit];
            return function (v) {
                if (v === null || v === void 0) {
                    return '-';
                }
                if (__WEBPACK_IMPORTED_MODULE_0_lodash___default.a.isString(v)) {
                    return _this.defaultCellFormatter(v, column.style);
                }
                if (column.style.colorMode) {
                    _this.colorState[column.style.colorMode] = _this.getColorForValue(v, column.style);
                }
                return valueFormatter_1(v, column.style.decimals, null);
            };
        }
        return function (value) {
            return _this.defaultCellFormatter(value, column.style);
        };
    };
    TableRenderer.prototype.renderRowVariables = function (rowIndex) {
        var scopedVars = {};
        var cell_variable;
        var row = this.table.rows[rowIndex];
        for (var i = 0; i < row.length; i++) {
            cell_variable = "__cell_" + i;
            scopedVars[cell_variable] = { value: row[i] };
        }
        return scopedVars;
    };
    TableRenderer.prototype.formatColumnValue = function (colIndex, value) {
        return this.formatters[colIndex] ? this.formatters[colIndex](value) : value;
    };
    TableRenderer.prototype.renderCell = function (columnIndex, rowIndex, value, addWidthHack) {
        if (addWidthHack === void 0) { addWidthHack = false; }
        value = this.formatColumnValue(columnIndex, value);
        var column = this.table.columns[columnIndex];
        var style = '';
        var cellClasses = [];
        var cellClass = '';
        if (this.colorState.cell) {
            style = ' style="background-color:' + this.colorState.cell + ';color: white"';
            this.colorState.cell = null;
        }
        else if (this.colorState.value) {
            style = ' style="color:' + this.colorState.value + '"';
            this.colorState.value = null;
        }
        // because of the fixed table headers css only solution
        // there is an issue if header cell is wider the cell
        // this hack adds header content to cell (not visible)
        var columnHtml = '';
        if (addWidthHack) {
            columnHtml = '<div class="table-panel-width-hack">' + this.table.columns[columnIndex].title + '</div>';
        }
        if (value === undefined) {
            style = ' style="display:none;"';
            column.hidden = true;
        }
        else {
            column.hidden = false;
        }
        if (column.style && column.style.preserveFormat) {
            cellClasses.push("table-panel-cell-pre");
        }
        if (column.style && column.style.link) {
            // Render cell as link
            var scopedVars = this.renderRowVariables(rowIndex);
            scopedVars['__cell'] = { value: value };
            var cellLink = this.templateSrv.replace(column.style.linkUrl, scopedVars);
            var cellLinkTooltip = this.templateSrv.replace(column.style.linkTooltip, scopedVars);
            var cellTarget = column.style.linkTargetBlank ? '_blank' : '';
            cellClasses.push("table-panel-cell-link");
            columnHtml += "\n        <a href=\"" + cellLink + "\" target=\"" + cellTarget + "\" data-link-tooltip data-original-title=\"" + cellLinkTooltip + "\" data-placement=\"right\">\n          " + value + "\n        </a>\n      ";
        }
        else {
            columnHtml += value;
        }
        if (column.filterable) {
            cellClasses.push("table-panel-cell-filterable");
            columnHtml += "\n        <a class=\"table-panel-filter-link\" data-link-tooltip data-original-title=\"Filter out value\" data-placement=\"bottom\"\n           data-row=\"" + rowIndex + "\" data-column=\"" + columnIndex + "\" data-operator=\"!=\">\n          <i class=\"fa fa-search-minus\"></i>\n        </a>\n        <a class=\"table-panel-filter-link\" data-link-tooltip data-original-title=\"Filter for value\" data-placement=\"bottom\"\n           data-row=\"" + rowIndex + "\" data-column=\"" + columnIndex + "\" data-operator=\"=\">\n          <i class=\"fa fa-search-plus\"></i>\n        </a>";
        }
        if (cellClasses.length) {
            cellClass = ' class="' + cellClasses.join(' ') + '"';
        }
        columnHtml = '<td' + cellClass + style + '>' + columnHtml + '</td>';
        return columnHtml;
    };
    TableRenderer.prototype.render = function (page) {
        var pageSize = this.panel.pageSize || 100;
        var startPos = page * pageSize;
        var endPos = Math.min(startPos + pageSize, this.table.rows.length);
        var html = "";
        for (var y = startPos; y < endPos; y++) {
            var row = this.table.rows[y];
            var cellHtml = '';
            var rowStyle = '';
            for (var i = 0; i < this.table.columns.length; i++) {
                cellHtml += this.renderCell(i, y, row[i], y === startPos);
            }
            if (this.colorState.row) {
                rowStyle = ' style="background-color:' + this.colorState.row + ';color: white"';
                this.colorState.row = null;
            }
            html += '<tr ' + rowStyle + '>' + cellHtml + '</tr>';
        }
        return html;
    };
    TableRenderer.prototype.render_values = function () {
        var rows = [];
        for (var y = 0; y < this.table.rows.length; y++) {
            var row = this.table.rows[y];
            var new_row = [];
            for (var i = 0; i < this.table.columns.length; i++) {
                new_row.push(this.formatColumnValue(i, row[i]));
            }
            rows.push(new_row);
        }
        return {
            columns: this.table.columns,
            rows: rows,
        };
    };
    return TableRenderer;
}());



/***/ }),

/***/ 1508:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SingleStatCtrl", function() { return SingleStatCtrl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PanelCtrl", function() { return SingleStatCtrl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getColorForValue", function() { return getColorForValue; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_jquery__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_jquery___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_jquery__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_vendor_flot_jquery_flot__ = __webpack_require__(1315);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_vendor_flot_jquery_flot___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_vendor_flot_jquery_flot__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_vendor_flot_jquery_flot_gauge__ = __webpack_require__(1509);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_vendor_flot_jquery_flot_gauge___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_vendor_flot_jquery_flot_gauge__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_app_features_panellinks_link_srv__ = __webpack_require__(1324);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_app_core_utils_kbn__ = __webpack_require__(464);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_app_core_config__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_app_core_time_series2__ = __webpack_require__(1309);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_app_plugins_sdk__ = __webpack_require__(1305);
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();









var SingleStatCtrl = /** @class */ (function (_super) {
    __extends(SingleStatCtrl, _super);
    /** @ngInject */
    SingleStatCtrl.$inject = ["$scope", "$injector", "$location", "linkSrv"];
    function SingleStatCtrl($scope, $injector, $location, linkSrv) {
        var _this = _super.call(this, $scope, $injector) || this;
        _this.$location = $location;
        _this.linkSrv = linkSrv;
        _this.dataType = 'timeseries';
        _this.valueNameOptions = [
            { value: 'min', text: 'Min' },
            { value: 'max', text: 'Max' },
            { value: 'avg', text: 'Average' },
            { value: 'current', text: 'Current' },
            { value: 'total', text: 'Total' },
            { value: 'name', text: 'Name' },
            { value: 'first', text: 'First' },
            { value: 'delta', text: 'Delta' },
            { value: 'diff', text: 'Difference' },
            { value: 'range', text: 'Range' },
            { value: 'last_time', text: 'Time of last point' }
        ];
        // Set and populate defaults
        _this.panelDefaults = {
            links: [],
            datasource: null,
            maxDataPoints: 100,
            interval: null,
            targets: [{}],
            cacheTimeout: null,
            format: 'none',
            prefix: '',
            postfix: '',
            nullText: null,
            valueMaps: [
                { value: 'null', op: '=', text: 'N/A' }
            ],
            mappingTypes: [
                { name: 'value to text', value: 1 },
                { name: 'range to text', value: 2 },
            ],
            rangeMaps: [
                { from: 'null', to: 'null', text: 'N/A' }
            ],
            mappingType: 1,
            nullPointMode: 'connected',
            valueName: 'avg',
            prefixFontSize: '50%',
            valueFontSize: '80%',
            postfixFontSize: '50%',
            thresholds: '',
            colorBackground: false,
            colorValue: false,
            colors: ["#299c46", "rgba(237, 129, 40, 0.89)", "#d44a3a"],
            sparkline: {
                show: false,
                full: false,
                lineColor: 'rgb(31, 120, 193)',
                fillColor: 'rgba(31, 118, 189, 0.18)',
            },
            gauge: {
                show: false,
                minValue: 0,
                maxValue: 100,
                thresholdMarkers: true,
                thresholdLabels: false
            },
            tableColumn: ''
        };
        __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.defaults(_this.panel, _this.panelDefaults);
        _this.events.on('data-received', _this.onDataReceived.bind(_this));
        _this.events.on('data-error', _this.onDataError.bind(_this));
        _this.events.on('data-snapshot-load', _this.onDataReceived.bind(_this));
        _this.events.on('init-edit-mode', _this.onInitEditMode.bind(_this));
        _this.onSparklineColorChange = _this.onSparklineColorChange.bind(_this);
        _this.onSparklineFillChange = _this.onSparklineFillChange.bind(_this);
        return _this;
    }
    SingleStatCtrl.prototype.onInitEditMode = function () {
        this.fontSizes = ['20%', '30%', '50%', '70%', '80%', '100%', '110%', '120%', '150%', '170%', '200%'];
        this.addEditorTab('Options', 'public/app/plugins/panel/singlestat/editor.html', 2);
        this.addEditorTab('Value Mappings', 'public/app/plugins/panel/singlestat/mappings.html', 3);
        this.unitFormats = __WEBPACK_IMPORTED_MODULE_5_app_core_utils_kbn__["default"].getUnitFormats();
    };
    SingleStatCtrl.prototype.setUnitFormat = function (subItem) {
        this.panel.format = subItem.value;
        this.refresh();
    };
    SingleStatCtrl.prototype.onDataError = function (err) {
        this.onDataReceived([]);
    };
    SingleStatCtrl.prototype.onDataReceived = function (dataList) {
        var data = {};
        if (dataList.length > 0 && dataList[0].type === 'table') {
            this.dataType = 'table';
            var tableData = dataList.map(this.tableHandler.bind(this));
            this.setTableValues(tableData, data);
        }
        else {
            this.dataType = 'timeseries';
            this.series = dataList.map(this.seriesHandler.bind(this));
            this.setValues(data);
        }
        this.data = data;
        this.render();
    };
    SingleStatCtrl.prototype.seriesHandler = function (seriesData) {
        var series = new __WEBPACK_IMPORTED_MODULE_7_app_core_time_series2__["a" /* default */]({
            datapoints: seriesData.datapoints || [],
            alias: seriesData.target,
        });
        series.flotpairs = series.getFlotPairs(this.panel.nullPointMode);
        return series;
    };
    SingleStatCtrl.prototype.tableHandler = function (tableData) {
        var datapoints = [];
        var columnNames = {};
        tableData.columns.forEach(function (column, columnIndex) {
            columnNames[columnIndex] = column.text;
        });
        this.tableColumnOptions = columnNames;
        if (!__WEBPACK_IMPORTED_MODULE_0_lodash___default.a.find(tableData.columns, ['text', this.panel.tableColumn])) {
            this.setTableColumnToSensibleDefault(tableData);
        }
        tableData.rows.forEach(function (row) {
            var datapoint = {};
            row.forEach(function (value, columnIndex) {
                var key = columnNames[columnIndex];
                datapoint[key] = value;
            });
            datapoints.push(datapoint);
        });
        return datapoints;
    };
    SingleStatCtrl.prototype.setTableColumnToSensibleDefault = function (tableData) {
        if (this.tableColumnOptions.length === 1) {
            this.panel.tableColumn = this.tableColumnOptions[0];
        }
        else {
            this.panel.tableColumn = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.find(tableData.columns, function (col) { return col.type !== 'time'; }).text;
        }
    };
    SingleStatCtrl.prototype.setTableValues = function (tableData, data) {
        if (!tableData || tableData.length === 0) {
            return;
        }
        if (tableData[0].length === 0 || tableData[0][0][this.panel.tableColumn] === undefined) {
            return;
        }
        var datapoint = tableData[0][0];
        data.value = datapoint[this.panel.tableColumn];
        if (__WEBPACK_IMPORTED_MODULE_0_lodash___default.a.isString(data.value)) {
            data.valueFormatted = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.escape(data.value);
            data.value = 0;
            data.valueRounded = 0;
        }
        else {
            var decimalInfo = this.getDecimalsForValue(data.value);
            var formatFunc = __WEBPACK_IMPORTED_MODULE_5_app_core_utils_kbn__["default"].valueFormats[this.panel.format];
            data.valueFormatted = formatFunc(datapoint[this.panel.tableColumn], decimalInfo.decimals, decimalInfo.scaledDecimals);
            data.valueRounded = __WEBPACK_IMPORTED_MODULE_5_app_core_utils_kbn__["default"].roundValue(data.value, this.panel.decimals || 0);
        }
        this.setValueMapping(data);
    };
    SingleStatCtrl.prototype.setColoring = function (options) {
        if (options.background) {
            this.panel.colorValue = false;
            this.panel.colors = ['rgba(71, 212, 59, 0.4)', 'rgba(245, 150, 40, 0.73)', 'rgba(225, 40, 40, 0.59)'];
        }
        else {
            this.panel.colorBackground = false;
            this.panel.colors = ['rgba(50, 172, 45, 0.97)', 'rgba(237, 129, 40, 0.89)', 'rgba(245, 54, 54, 0.9)'];
        }
        this.render();
    };
    SingleStatCtrl.prototype.invertColorOrder = function () {
        var tmp = this.panel.colors[0];
        this.panel.colors[0] = this.panel.colors[2];
        this.panel.colors[2] = tmp;
        this.render();
    };
    SingleStatCtrl.prototype.onColorChange = function (panelColorIndex) {
        var _this = this;
        return function (color) {
            _this.panel.colors[panelColorIndex] = color;
            _this.render();
        };
    };
    SingleStatCtrl.prototype.onSparklineColorChange = function (newColor) {
        this.panel.sparkline.lineColor = newColor;
        this.render();
    };
    SingleStatCtrl.prototype.onSparklineFillChange = function (newColor) {
        this.panel.sparkline.fillColor = newColor;
        this.render();
    };
    SingleStatCtrl.prototype.getDecimalsForValue = function (value) {
        if (__WEBPACK_IMPORTED_MODULE_0_lodash___default.a.isNumber(this.panel.decimals)) {
            return { decimals: this.panel.decimals, scaledDecimals: null };
        }
        var delta = value / 2;
        var dec = -Math.floor(Math.log(delta) / Math.LN10);
        var magn = Math.pow(10, -dec), norm = delta / magn, // norm is between 1.0 and 10.0
        size;
        if (norm < 1.5) {
            size = 1;
        }
        else if (norm < 3) {
            size = 2;
            // special case for 2.5, requires an extra decimal
            if (norm > 2.25) {
                size = 2.5;
                ++dec;
            }
        }
        else if (norm < 7.5) {
            size = 5;
        }
        else {
            size = 10;
        }
        size *= magn;
        // reduce starting decimals if not needed
        if (Math.floor(value) === value) {
            dec = 0;
        }
        var result = {};
        result.decimals = Math.max(0, dec);
        result.scaledDecimals = result.decimals - Math.floor(Math.log(size) / Math.LN10) + 2;
        return result;
    };
    SingleStatCtrl.prototype.setValues = function (data) {
        data.flotpairs = [];
        if (this.series.length > 1) {
            var error = new Error();
            error.message = 'Multiple Series Error';
            error.data = 'Metric query returns ' + this.series.length +
                ' series. Single Stat Panel expects a single series.\n\nResponse:\n' + JSON.stringify(this.series);
            throw error;
        }
        if (this.series && this.series.length > 0) {
            var lastPoint = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.last(this.series[0].datapoints);
            var lastValue = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.isArray(lastPoint) ? lastPoint[0] : null;
            if (this.panel.valueName === 'name') {
                data.value = 0;
                data.valueRounded = 0;
                data.valueFormatted = this.series[0].alias;
            }
            else if (__WEBPACK_IMPORTED_MODULE_0_lodash___default.a.isString(lastValue)) {
                data.value = 0;
                data.valueFormatted = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.escape(lastValue);
                data.valueRounded = 0;
            }
            else if (this.panel.valueName === 'last_time') {
                var formatFunc = __WEBPACK_IMPORTED_MODULE_5_app_core_utils_kbn__["default"].valueFormats[this.panel.format];
                data.value = lastPoint[1];
                data.valueRounded = data.value;
                data.valueFormatted = formatFunc(data.value, 0, 0);
            }
            else {
                data.value = this.series[0].stats[this.panel.valueName];
                data.flotpairs = this.series[0].flotpairs;
                var decimalInfo = this.getDecimalsForValue(data.value);
                var formatFunc = __WEBPACK_IMPORTED_MODULE_5_app_core_utils_kbn__["default"].valueFormats[this.panel.format];
                data.valueFormatted = formatFunc(data.value, decimalInfo.decimals, decimalInfo.scaledDecimals);
                data.valueRounded = __WEBPACK_IMPORTED_MODULE_5_app_core_utils_kbn__["default"].roundValue(data.value, decimalInfo.decimals);
            }
            // Add $__name variable for using in prefix or postfix
            data.scopedVars = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.extend({}, this.panel.scopedVars);
            data.scopedVars["__name"] = { value: this.series[0].label };
        }
        this.setValueMapping(data);
    };
    SingleStatCtrl.prototype.setValueMapping = function (data) {
        // check value to text mappings if its enabled
        if (this.panel.mappingType === 1) {
            for (var i = 0; i < this.panel.valueMaps.length; i++) {
                var map = this.panel.valueMaps[i];
                // special null case
                if (map.value === 'null') {
                    if (data.value === null || data.value === void 0) {
                        data.valueFormatted = map.text;
                        return;
                    }
                    continue;
                }
                // value/number to text mapping
                var value = parseFloat(map.value);
                if (value === data.valueRounded) {
                    data.valueFormatted = map.text;
                    return;
                }
            }
        }
        else if (this.panel.mappingType === 2) {
            for (var i = 0; i < this.panel.rangeMaps.length; i++) {
                var map = this.panel.rangeMaps[i];
                // special null case
                if (map.from === 'null' && map.to === 'null') {
                    if (data.value === null || data.value === void 0) {
                        data.valueFormatted = map.text;
                        return;
                    }
                    continue;
                }
                // value/number to range mapping
                var from = parseFloat(map.from);
                var to = parseFloat(map.to);
                if (to >= data.valueRounded && from <= data.valueRounded) {
                    data.valueFormatted = map.text;
                    return;
                }
            }
        }
        if (data.value === null || data.value === void 0) {
            data.valueFormatted = "no value";
        }
    };
    SingleStatCtrl.prototype.removeValueMap = function (map) {
        var index = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.indexOf(this.panel.valueMaps, map);
        this.panel.valueMaps.splice(index, 1);
        this.render();
    };
    SingleStatCtrl.prototype.addValueMap = function () {
        this.panel.valueMaps.push({ value: '', op: '=', text: '' });
    };
    SingleStatCtrl.prototype.removeRangeMap = function (rangeMap) {
        var index = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.indexOf(this.panel.rangeMaps, rangeMap);
        this.panel.rangeMaps.splice(index, 1);
        this.render();
    };
    SingleStatCtrl.prototype.addRangeMap = function () {
        this.panel.rangeMaps.push({ from: '', to: '', text: '' });
    };
    SingleStatCtrl.prototype.link = function (scope, elem, attrs, ctrl) {
        var $location = this.$location;
        var linkSrv = this.linkSrv;
        var $timeout = this.$timeout;
        var panel = ctrl.panel;
        var templateSrv = this.templateSrv;
        var data, linkInfo;
        var $panelContainer = elem.find('.panel-container');
        elem = elem.find('.singlestat-panel');
        function setElementHeight() {
            elem.css('height', ctrl.height + 'px');
        }
        function applyColoringThresholds(value, valueString) {
            if (!panel.colorValue) {
                return valueString;
            }
            var color = getColorForValue(data, value);
            if (color) {
                return '<span style="color:' + color + '">' + valueString + '</span>';
            }
            return valueString;
        }
        function getSpan(className, fontSize, value) {
            value = templateSrv.replace(value, data.scopedVars);
            return '<span class="' + className + '" style="font-size:' + fontSize + '">' +
                value + '</span>';
        }
        function getBigValueHtml() {
            var body = '<div class="singlestat-panel-value-container">';
            if (panel.prefix) {
                body += getSpan('singlestat-panel-prefix', panel.prefixFontSize, panel.prefix);
            }
            var value = applyColoringThresholds(data.value, data.valueFormatted);
            body += getSpan('singlestat-panel-value', panel.valueFontSize, value);
            if (panel.postfix) {
                body += getSpan('singlestat-panel-postfix', panel.postfixFontSize, panel.postfix);
            }
            body += '</div>';
            return body;
        }
        function getValueText() {
            var result = panel.prefix ? templateSrv.replace(panel.prefix, data.scopedVars) : '';
            result += data.valueFormatted;
            result += panel.postfix ? templateSrv.replace(panel.postfix, data.scopedVars) : '';
            return result;
        }
        function addGauge() {
            var width = elem.width();
            var height = elem.height();
            // Allow to use a bit more space for wide gauges
            var dimension = Math.min(width, height * 1.3);
            ctrl.invalidGaugeRange = false;
            if (panel.gauge.minValue > panel.gauge.maxValue) {
                ctrl.invalidGaugeRange = true;
                return;
            }
            var plotCanvas = __WEBPACK_IMPORTED_MODULE_1_jquery___default()('<div></div>');
            var plotCss = {
                top: '10px',
                margin: 'auto',
                position: 'relative',
                height: (height * 0.9) + 'px',
                width: dimension + 'px'
            };
            plotCanvas.css(plotCss);
            var thresholds = [];
            for (var i = 0; i < data.thresholds.length; i++) {
                thresholds.push({
                    value: data.thresholds[i],
                    color: data.colorMap[i]
                });
            }
            thresholds.push({
                value: panel.gauge.maxValue,
                color: data.colorMap[data.colorMap.length - 1]
            });
            var bgColor = __WEBPACK_IMPORTED_MODULE_6_app_core_config__["default"].bootData.user.lightTheme
                ? 'rgb(230,230,230)'
                : 'rgb(38,38,38)';
            var fontScale = parseInt(panel.valueFontSize) / 100;
            var fontSize = Math.min(dimension / 5, 100) * fontScale;
            // Reduce gauge width if threshold labels enabled
            var gaugeWidthReduceRatio = panel.gauge.thresholdLabels ? 1.5 : 1;
            var gaugeWidth = Math.min(dimension / 6, 60) / gaugeWidthReduceRatio;
            var thresholdMarkersWidth = gaugeWidth / 5;
            var thresholdLabelFontSize = fontSize / 2.5;
            var options = {
                series: {
                    gauges: {
                        gauge: {
                            min: panel.gauge.minValue,
                            max: panel.gauge.maxValue,
                            background: { color: bgColor },
                            border: { color: null },
                            shadow: { show: false },
                            width: gaugeWidth,
                        },
                        frame: { show: false },
                        label: { show: false },
                        layout: { margin: 0, thresholdWidth: 0 },
                        cell: { border: { width: 0 } },
                        threshold: {
                            values: thresholds,
                            label: {
                                show: panel.gauge.thresholdLabels,
                                margin: thresholdMarkersWidth + 1,
                                font: { size: thresholdLabelFontSize }
                            },
                            show: panel.gauge.thresholdMarkers,
                            width: thresholdMarkersWidth,
                        },
                        value: {
                            color: panel.colorValue ? getColorForValue(data, data.valueRounded) : null,
                            formatter: function () { return getValueText(); },
                            font: { size: fontSize, family: '"Helvetica Neue", Helvetica, Arial, sans-serif' }
                        },
                        show: true
                    }
                }
            };
            elem.append(plotCanvas);
            var plotSeries = {
                data: [[0, data.valueRounded]]
            };
            __WEBPACK_IMPORTED_MODULE_1_jquery___default.a.plot(plotCanvas, [plotSeries], options);
        }
        function addSparkline() {
            var width = elem.width() + 20;
            if (width < 30) {
                // element has not gotten it's width yet
                // delay sparkline render
                setTimeout(addSparkline, 30);
                return;
            }
            var height = ctrl.height;
            var plotCanvas = __WEBPACK_IMPORTED_MODULE_1_jquery___default()('<div></div>');
            var plotCss = {};
            plotCss.position = 'absolute';
            if (panel.sparkline.full) {
                plotCss.bottom = '5px';
                plotCss.left = '-5px';
                plotCss.width = (width - 10) + 'px';
                var dynamicHeightMargin = height <= 100 ? 5 : (Math.round((height / 100)) * 15) + 5;
                plotCss.height = (height - dynamicHeightMargin) + 'px';
            }
            else {
                plotCss.bottom = "0px";
                plotCss.left = "-5px";
                plotCss.width = (width - 10) + 'px';
                plotCss.height = Math.floor(height * 0.25) + "px";
            }
            plotCanvas.css(plotCss);
            var options = {
                legend: { show: false },
                series: {
                    lines: {
                        show: true,
                        fill: 1,
                        lineWidth: 1,
                        fillColor: panel.sparkline.fillColor,
                    },
                },
                yaxes: { show: false },
                xaxis: {
                    show: false,
                    mode: "time",
                    min: ctrl.range.from.valueOf(),
                    max: ctrl.range.to.valueOf(),
                },
                grid: { hoverable: false, show: false },
            };
            elem.append(plotCanvas);
            var plotSeries = {
                data: data.flotpairs,
                color: panel.sparkline.lineColor
            };
            __WEBPACK_IMPORTED_MODULE_1_jquery___default.a.plot(plotCanvas, [plotSeries], options);
        }
        function render() {
            if (!ctrl.data) {
                return;
            }
            data = ctrl.data;
            // get thresholds
            data.thresholds = panel.thresholds.split(',').map(function (strVale) {
                return Number(strVale.trim());
            });
            data.colorMap = panel.colors;
            setElementHeight();
            var body = panel.gauge.show ? '' : getBigValueHtml();
            if (panel.colorBackground) {
                var color = getColorForValue(data, data.value);
                if (color) {
                    $panelContainer.css('background-color', color);
                    if (scope.fullscreen) {
                        elem.css('background-color', color);
                    }
                    else {
                        elem.css('background-color', '');
                    }
                }
            }
            else {
                $panelContainer.css('background-color', '');
                elem.css('background-color', '');
            }
            elem.html(body);
            if (panel.sparkline.show) {
                addSparkline();
            }
            if (panel.gauge.show) {
                addGauge();
            }
            elem.toggleClass('pointer', panel.links.length > 0);
            if (panel.links.length > 0) {
                linkInfo = linkSrv.getPanelLinkAnchorInfo(panel.links[0], data.scopedVars);
            }
            else {
                linkInfo = null;
            }
        }
        function hookupDrilldownLinkTooltip() {
            // drilldown link tooltip
            var drilldownTooltip = __WEBPACK_IMPORTED_MODULE_1_jquery___default()('<div id="tooltip" class="">hello</div>"');
            elem.mouseleave(function () {
                if (panel.links.length === 0) {
                    return;
                }
                $timeout(function () {
                    drilldownTooltip.detach();
                });
            });
            elem.click(function (evt) {
                if (!linkInfo) {
                    return;
                }
                // ignore title clicks in title
                if (__WEBPACK_IMPORTED_MODULE_1_jquery___default()(evt).parents('.panel-header').length > 0) {
                    return;
                }
                if (linkInfo.target === '_blank') {
                    window.open(linkInfo.href, '_blank');
                    return;
                }
                if (linkInfo.href.indexOf('http') === 0) {
                    window.location.href = linkInfo.href;
                }
                else {
                    $timeout(function () {
                        $location.url(linkInfo.href);
                    });
                }
                drilldownTooltip.detach();
            });
            elem.mousemove(function (e) {
                if (!linkInfo) {
                    return;
                }
                drilldownTooltip.text('click to go to: ' + linkInfo.title);
                drilldownTooltip.place_tt(e.pageX, e.pageY - 50);
            });
        }
        hookupDrilldownLinkTooltip();
        this.events.on('render', function () {
            render();
            ctrl.renderingCompleted();
        });
    };
    SingleStatCtrl.templateUrl = 'module.html';
    return SingleStatCtrl;
}(__WEBPACK_IMPORTED_MODULE_8_app_plugins_sdk__["MetricsPanelCtrl"]));
function getColorForValue(data, value) {
    if (!__WEBPACK_IMPORTED_MODULE_0_lodash___default.a.isFinite(value)) {
        return null;
    }
    for (var i = data.thresholds.length; i > 0; i--) {
        if (value >= data.thresholds[i - 1]) {
            return data.colorMap[i];
        }
    }
    return __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.first(data.colorMap);
}



/***/ }),

/***/ 1509:
/***/ (function(module, exports) {

/*!
 * jquery.flot.gauge v1.1.0 *
 *
 * Flot plugin for rendering gauge charts.
 *
 * Copyright (c) 2015 @toyoty99.
 * Licensed under the MIT license.
 */

/**
 * @module flot.gauge
 */
(function($) {


    /**
     * Gauge class
     *
     * @class Gauge
     */
    var Gauge = (function() {
        /**
         * context of canvas
         *
         * @property context
         * @type Object
         */
        var context;
        /**
         * placeholder of canvas
         *
         * @property placeholder
         * @type Object
         */
        var placeholder;
        /**
         * options of plot
         *
         * @property options
         * @type Object
         */
        var options;
        /**
         * options of gauge
         *
         * @property gaugeOptions
         * @type Object
         */
        var gaugeOptions;
        /**
         * data series
         *
         * @property series
         * @type Array
         */
        var series;
        /**
         * logger
         *
         * @property logger
         * @type Object
         */
        var logger;

        /**
         * constructor
         *
         * @class Gauge
         * @constructor
         * @param  {Object} gaugeOptions gauge options
         */
        var Gauge = function(plot, ctx) {
            context = ctx;
            placeholder = plot.getPlaceholder();
            options = plot.getOptions();
            gaugeOptions = options.series.gauges;
            series = plot.getData();
            logger = getLogger(gaugeOptions.debug);
        }

        /**
         * calculate layout
         *
         * @method calculateLayout
         * @return the calculated layout properties
         */
        Gauge.prototype.calculateLayout = function() {

            var canvasWidth = placeholder.width();
            var canvasHeight = placeholder.height();



            // calculate cell size
            var columns = Math.min(series.length, gaugeOptions.layout.columns);
            var rows = Math.ceil(series.length / columns);



            var margin = gaugeOptions.layout.margin;
            var hMargin = gaugeOptions.layout.hMargin;
            var vMargin = gaugeOptions.layout.vMargin;
            var cellWidth = (canvasWidth - (margin * 2) - (hMargin * (columns - 1))) / columns;
            var cellHeight = (canvasHeight - (margin * 2) - (vMargin * (rows - 1))) / rows;
            if (gaugeOptions.layout.square) {
                var cell = Math.min(cellWidth, cellHeight);
                cellWidth = cell;
                cellHeight = cell;
            }



            // calculate 'auto' values
            calculateAutoValues(gaugeOptions, cellWidth);

            // calculate maximum radius
            var cellMargin = gaugeOptions.cell.margin;
            var labelMargin = 0;
            var labelFontSize = 0;
            if (gaugeOptions.label.show) {
                labelMargin = gaugeOptions.label.margin;
                labelFontSize = gaugeOptions.label.font.size;
            }
            var valueMargin = 0;
            var valueFontSize = 0;
            if (gaugeOptions.value.show) {
                valueMargin = gaugeOptions.value.margin;
                valueFontSize = gaugeOptions.value.font.size;
            }
            var thresholdWidth = 0;
            if (gaugeOptions.threshold.show) {
                thresholdWidth = gaugeOptions.threshold.width;
            }
            var thresholdLabelMargin = 0;
            var thresholdLabelFontSize = 0;
            if (gaugeOptions.threshold.label.show) {
                thresholdLabelMargin = gaugeOptions.threshold.label.margin;
                thresholdLabelFontSize = gaugeOptions.threshold.label.font.size;
            }

            var maxRadiusH = (cellWidth / 2) - cellMargin - thresholdWidth - (thresholdLabelMargin * 2) - thresholdLabelFontSize;

            var startAngle = gaugeOptions.gauge.startAngle;
            var endAngle = gaugeOptions.gauge.endAngle;
            var dAngle = (endAngle - startAngle) / 100;
            var heightRatioV = -1;
            for (var a = startAngle; a < endAngle; a += dAngle) {
                heightRatioV = Math.max(heightRatioV, Math.sin(toRad(a)));
            }
            heightRatioV = Math.max(heightRatioV, Math.sin(toRad(endAngle)));
            var outerRadiusV = (cellHeight - (cellMargin * 2) - (labelMargin * 2) - labelFontSize) / (1 + heightRatioV);
            if (outerRadiusV * heightRatioV < valueMargin + (valueFontSize / 2)) {
                outerRadiusV = cellHeight - (cellMargin * 2) - (labelMargin * 2) - labelFontSize - valueMargin - (valueFontSize / 2);
            }
            var maxRadiusV = outerRadiusV - (thresholdLabelMargin * 2) - thresholdLabelFontSize - thresholdWidth;

            var radius = Math.min(maxRadiusH, maxRadiusV);


            var width = gaugeOptions.gauge.width;
            if (width >= radius) {
                width = Math.max(3, radius / 3);
            }


            var outerRadius = (thresholdLabelMargin * 2) + thresholdLabelFontSize + thresholdWidth + radius;
            var gaugeOuterHeight = Math.max(outerRadius * (1 + heightRatioV), outerRadius + valueMargin + (valueFontSize / 2));

            return {
                canvasWidth: canvasWidth,
                canvasHeight: canvasHeight,
                margin: margin,
                hMargin: hMargin,
                vMargin: vMargin,
                columns: columns,
                rows: rows,
                cellWidth: cellWidth,
                cellHeight: cellHeight,
                cellMargin: cellMargin,
                labelMargin: labelMargin,
                labelFontSize: labelFontSize,
                valueMargin: valueMargin,
                valueFontSize: valueFontSize,
                width: width,
                radius: radius,
                thresholdWidth: thresholdWidth,
                thresholdLabelMargin: thresholdLabelMargin,
                thresholdLabelFontSize: thresholdLabelFontSize,
                gaugeOuterHeight: gaugeOuterHeight
            };
        }

        /**
         * calculate the values which are set as 'auto'
         *
         * @method calculateAutoValues
         * @param  {Object} gaugeOptionsi the options of the gauge
         * @param  {Number} cellWidth the width of cell
         */
        function calculateAutoValues(gaugeOptionsi, cellWidth) {

            if (gaugeOptionsi.gauge.width === "auto") {
                gaugeOptionsi.gauge.width = Math.max(5, cellWidth / 8);
            }
            if (gaugeOptionsi.label.margin === "auto") {
                gaugeOptionsi.label.margin = Math.max(1, cellWidth / 20);
            }
            if (gaugeOptionsi.label.font.size === "auto") {
                gaugeOptionsi.label.font.size = Math.max(5, cellWidth / 8);
            }
            if (gaugeOptionsi.value.margin === "auto") {
                gaugeOptionsi.value.margin = Math.max(1, cellWidth / 30);
            }
            if (gaugeOptionsi.value.font.size === "auto") {
                gaugeOptionsi.value.font.size = Math.max(5, cellWidth / 9);
            }
            if (gaugeOptionsi.threshold.width === "auto") {
                gaugeOptionsi.threshold.width = Math.max(3, cellWidth / 100);
            }
            if (gaugeOptionsi.threshold.label.margin === "auto") {
                gaugeOptionsi.threshold.label.margin = Math.max(3, cellWidth / 40);
            }
            if (gaugeOptionsi.threshold.label.font.size === "auto") {
                gaugeOptionsi.threshold.label.font.size = Math.max(5, cellWidth / 15);
            }

        }
        Gauge.prototype.calculateAutoValues = calculateAutoValues;

        /**
         * calculate the layout of the cell inside
         *
         * @method calculateCellLayout
         * @param  {Object} gaugeOptionsi the options of the gauge
         * @param  {Number} cellWidth the width of cell
         * @param  {Number} i the index of the series
         * @return the calculated cell layout properties
         */
        Gauge.prototype.calculateCellLayout = function(gaugeOptionsi, layout, i) {

            // calculate top, left and center
            var c = col(layout.columns, i);
            var r = row(layout.columns, i);
            var x = layout.margin + (layout.cellWidth + layout.hMargin) * c;
            var y = layout.margin + (layout.cellHeight + layout.vMargin) * r;
            var cx = x + (layout.cellWidth / 2);
            var cy = y + layout.cellMargin + (layout.labelMargin * 2) + layout.labelFontSize + layout.thresholdWidth
                        + layout.thresholdLabelFontSize + (layout.thresholdLabelMargin * 2) + layout.radius;
            var blank = layout.cellHeight - (layout.cellMargin * 2) - (layout.labelMargin * 2) - layout.labelFontSize - layout.gaugeOuterHeight;
            var offsetY = 0;
            if (gaugeOptionsi.cell.vAlign === "middle") {
                offsetY = (blank / 2);
            } else if (gaugeOptionsi.cell.vAlign === "bottom") {
                offsetY = blank;
            }
            cy += offsetY;

            return {
                col: c,
                row: r,
                x: x,
                y: y,
                offsetY: offsetY,
                cellWidth: layout.cellWidth,
                cellHeight: layout.cellHeight,
                cellMargin: layout.cellMargin,
                cx: cx,
                cy: cy
            }
        }

        /**
         * draw the background of chart
         *
         * @method drawBackground
         * @param  {Object} layout the layout properties
         */
        Gauge.prototype.drawBackground = function(layout) {

            if (!gaugeOptions.frame.show) {
                return;
            }
            context.save();
            context.strokeStyle = options.grid.borderColor;
            context.lineWidth = options.grid.borderWidth;
            context.strokeRect(0, 0, layout.canvasWidth, layout.canvasHeight);
            if (options.grid.backgroundColor) {
                context.fillStyle = options.grid.backgroundColor;
                context.fillRect(0, 0, layout.canvasWidth, layout.canvasHeight);
            }
            context.restore();
        }

        /**
         * draw the background of cell
         *
         * @method drawCellBackground
         * @param  {Object} gaugeOptionsi the options of the gauge
         * @param  {Object} cellLayout the cell layout properties
         */
        Gauge.prototype.drawCellBackground = function(gaugeOptionsi, cellLayout) {

            context.save();
            if (gaugeOptionsi.cell.border && gaugeOptionsi.cell.border.show && gaugeOptionsi.cell.border.color && gaugeOptionsi.cell.border.width) {
                context.strokeStyle = gaugeOptionsi.cell.border.color;
                context.lineWidth = gaugeOptionsi.cell.border.width;
                context.strokeRect(cellLayout.x, cellLayout.y, cellLayout.cellWidth, cellLayout.cellHeight);
            }
            if (gaugeOptionsi.cell.background && gaugeOptionsi.cell.background.color) {
                context.fillStyle = gaugeOptionsi.cell.background.color;
                context.fillRect(cellLayout.x, cellLayout.y, cellLayout.cellWidth, cellLayout.cellHeight);
            }
            context.restore();
        }

        /**
         * draw the gauge
         *
         * @method drawGauge
         * @param  {Object} gaugeOptionsi the options of the gauge
         * @param  {Object} layout the layout properties
         * @param  {Object} cellLayout the cell layout properties
         * @param  {String} label the label of data
         * @param  {Number} data the value of the gauge
         */
        Gauge.prototype.drawGauge = function(gaugeOptionsi, layout, cellLayout, label, data) {


            var blur = gaugeOptionsi.gauge.shadow.show ? gaugeOptionsi.gauge.shadow.blur : 0;


            // draw gauge frame
            drawArcWithShadow(
                cellLayout.cx, // center x
                cellLayout.cy, // center y
                layout.radius,
                layout.width,
                toRad(gaugeOptionsi.gauge.startAngle),
                toRad(gaugeOptionsi.gauge.endAngle),
                gaugeOptionsi.gauge.border.color,      // line color
                gaugeOptionsi.gauge.border.width,      // line width
                gaugeOptionsi.gauge.background.color,  // fill color
                blur);

            // draw gauge
            var c1 = getColor(gaugeOptionsi, data);
            var a2 = calculateAngle(gaugeOptionsi, layout, data);
            drawArcWithShadow(
                cellLayout.cx, // center x
                cellLayout.cy, // center y
                layout.radius - 1,
                layout.width - 2,
                toRad(gaugeOptionsi.gauge.startAngle),
                toRad(a2),
                c1,           // line color
                1,            // line width
                c1,           // fill color
                blur);
        }

        /**
         * decide the color of the data from the threshold options
         *
         * @method getColor
         * @private
         * @param  {Object} gaugeOptionsi the options of the gauge
         * @param  {Number} data the value of the gauge
         */
        function getColor(gaugeOptionsi, data) {
            var color;
            for (var i = 0; i < gaugeOptionsi.threshold.values.length; i++) {
                var threshold = gaugeOptionsi.threshold.values[i];
                color = threshold.color;
                if (data < threshold.value) {
                    break;
                }
            }
            return color;
        }

        /**
         * calculate the angle of the data
         *
         * @method calculateAngle
         * @private
         * @param  {Object} gaugeOptionsi the options of the gauge
         * @param  {Object} layout the layout properties
         * @param  {Number} data the value of the gauge
         */
        function calculateAngle(gaugeOptionsi, layout, data) {
            var a =
                gaugeOptionsi.gauge.startAngle
                    + (gaugeOptionsi.gauge.endAngle - gaugeOptionsi.gauge.startAngle)
                        * ((data - gaugeOptionsi.gauge.min) / (gaugeOptionsi.gauge.max - gaugeOptionsi.gauge.min));

            if (a < gaugeOptionsi.gauge.startAngle) {
                a = gaugeOptionsi.gauge.startAngle;
            } else if (a > gaugeOptionsi.gauge.endAngle) {
                a = gaugeOptionsi.gauge.endAngle;
            }
            return a;
        }

        /**
         * draw the arc of the threshold
         *
         * @method drawThreshold
         * @param  {Object} gaugeOptionsi the options of the gauge
         * @param  {Object} layout the layout properties
         * @param  {Object} cellLayout the cell layout properties
         */
        Gauge.prototype.drawThreshold = function(gaugeOptionsi, layout, cellLayout) {

            var a1 = gaugeOptionsi.gauge.startAngle;
            for (var i = 0; i < gaugeOptionsi.threshold.values.length; i++) {
                var threshold = gaugeOptionsi.threshold.values[i];
                c1 = threshold.color;
                a2 = calculateAngle(gaugeOptionsi, layout, threshold.value);
                drawArc(
                    context,
                    cellLayout.cx, // center x
                    cellLayout.cy, // center y
                    layout.radius + layout.thresholdWidth,
                    layout.thresholdWidth - 2,
                    toRad(a1),
                    toRad(a2),
                    c1,           // line color
                    1,            // line width
                    c1);          // fill color
                a1 = a2;
            }
        }

        /**
         * draw an arc with a shadow
         *
         * @method drawArcWithShadow
         * @private
         * @param  {Number} cx the x position of the center
         * @param  {Number} cy the y position of the center
         * @param  {Number} r the radius of an arc
         * @param  {Number} w the width of an arc
         * @param  {Number} rd1 the start angle of an arc in radians
         * @param  {Number} rd2 the end angle of an arc in radians
         * @param  {String} lc the color of a line
         * @param  {Number} lw the widht of a line
         * @param  {String} fc the fill color  of an arc
         * @param  {Number} blur the shdow blur
         */
        function drawArcWithShadow(cx, cy, r, w, rd1, rd2, lc, lw, fc, blur) {
            if (rd1 === rd2) {
                return;
            }
            context.save();

            drawArc(context, cx, cy, r, w, rd1, rd2, lc, lw, fc);

            if (blur) {
                drawArc(context, cx, cy, r, w, rd1, rd2);
                context.clip();
                context.shadowOffsetX = 0;
                context.shadowOffsetY = 0;
                context.shadowBlur = 10;
                context.shadowColor = "gray";
                drawArc(context, cx, cy, r + 1, w + 2, rd1, rd2, lc, 1);
            }
            context.restore();
        }

        /**
         * draw the label of the gauge
         *
         * @method drawLable
         * @param  {Object} gaugeOptionsi the options of the gauge
         * @param  {Object} layout the layout properties
         * @param  {Object} cellLayout the cell layout properties
         * @param  {Number} i the index of the series
         * @param  {Object} item the item of the series
         */
        Gauge.prototype.drawLable = function(gaugeOptionsi, layout, cellLayout, i, item) {

            drawText(
                cellLayout.cx,
                cellLayout.y + cellLayout.cellMargin + layout.labelMargin + cellLayout.offsetY,
                "flotGagueLabel" + i,
                gaugeOptionsi.label.formatter ? gaugeOptionsi.label.formatter(item.label, item.data[0][1]) : text,
                gaugeOptionsi.label);
        }

        /**
         * draw the value of the gauge
         *
         * @method drawValue
         * @param  {Object} gaugeOptionsi the options of the gauge
         * @param  {Object} layout the layout properties
         * @param  {Object} cellLayout the cell layout properties
         * @param  {Number} i the index of the series
         * @param  {Object} item the item of the series
         */
        Gauge.prototype.drawValue = function(gaugeOptionsi, layout, cellLayout, i, item) {

            drawText(
                cellLayout.cx,
                cellLayout.cy - (gaugeOptionsi.value.font.size / 2),
                "flotGagueValue" + i,
                gaugeOptionsi.value.formatter ? gaugeOptionsi.value.formatter(item.label, item.data[0][1]) : text,
                gaugeOptionsi.value);
        }

        /**
         * draw the values of the threshold
         *
         * @method drawThresholdValues
         * @param  {Object} gaugeOptionsi the options of the gauge
         * @param  {Object} layout the layout properties
         * @param  {Object} cellLayout the cell layout properties
         * @param  {Number} i the index of the series
         */
        Gauge.prototype.drawThresholdValues = function(gaugeOptionsi, layout, cellLayout, i) {

            // min, max
            drawThresholdValue(gaugeOptionsi, layout, cellLayout, "Min" + i, gaugeOptionsi.gauge.min, gaugeOptionsi.gauge.startAngle);
            drawThresholdValue(gaugeOptionsi, layout, cellLayout, "Max" + i, gaugeOptionsi.gauge.max, gaugeOptionsi.gauge.endAngle);
            // threshold values
            for (var j = 0; j < gaugeOptionsi.threshold.values.length; j++) {
                var threshold = gaugeOptionsi.threshold.values[j];
                if (threshold.value > gaugeOptionsi.gauge.min && threshold.value < gaugeOptionsi.gauge.max) {
                    var a = calculateAngle(gaugeOptionsi, layout, threshold.value);
                    drawThresholdValue(gaugeOptionsi, layout, cellLayout, i + "_" + j, threshold.value, a);
                }
            }
        }

        /**
         * draw the value of the threshold
         *
         * @method drawThresholdValue
         * @param  {Object} gaugeOptionsi the options of the gauge
         * @param  {Object} layout the layout properties
         * @param  {Object} cellLayout the cell layout properties
         * @param  {Number} i the index of the series
         * @param  {Number} value the value of the threshold
         * @param  {Number} a the angle of the value drawn
         */
        function drawThresholdValue(gaugeOptionsi, layout, cellLayout, i, value, a) {
            drawText(
                cellLayout.cx
                    + ((layout.thresholdLabelMargin + (layout.thresholdLabelFontSize / 2) + layout.radius)
                        * Math.cos(toRad(a))),
                cellLayout.cy
                    + ((layout.thresholdLabelMargin + (layout.thresholdLabelFontSize / 2) + layout.radius)
                        * Math.sin(toRad(a))),
                "flotGagueThresholdValue" + i,
                gaugeOptionsi.threshold.label.formatter ? gaugeOptionsi.threshold.label.formatter(value) : value,
                gaugeOptionsi.threshold.label,
                a);
        }

        /**
         * draw a text
         *
         * the textOptions is assumed as follows:
         *
         *   textOptions: {
         *       background: {
         *           color: null,
         *           opacity: 0
         *       },
         *       font: {
         *           size: "auto"
         *           family: "\" \",sans-serif"
         *       },
         *       color: null
         *   }
         *
         * @method drawText
         * @private
         * @param  {Number} x the x position of the text drawn (left top)
         * @param  {Number} y the y position of the text drawn (left top)
         * @param  {String} id the id of the dom element
         * @param  {String} text the text drawn
         * @param  {Object} textOptions the option of the text
         * @param  {Number} [a] the angle of the value drawn
         */
        function drawText(x, y, id, text, textOptions, a) {
            var span = $("." + id, placeholder);
            var exists = span.length;
            if (!exists) {
                span = $("<span></span>")
                span.attr("id", id);
                span.css("position", "absolute");
                span.css("top", y + "px");
                if (textOptions.font.size) {
                    span.css("font-size", textOptions.font.size + "px");
                }
                if (textOptions.font.family) {
                    span.css("font-family", textOptions.font.family);
                }
                if (textOptions.color) {
                    span.css("color", textOptions.color);
                }
                if (textOptions.background.color) {
                    span.css("background-color", textOptions.background.color);
                }
                if (textOptions.background.opacity) {
                    span.css("opacity", textOptions.background.opacity);
                }
                placeholder.append(span);
            }
            span.text(text);
            // after append, readjust the left position
            span.css("left", x + "px"); // for redraw, resetting the left position is needed here
            span.css("left", (parseInt(span.css("left")) - (span.width()/ 2)) + "px");

            // at last, set angle
            if (!exists && a) {
                span.css("top", (parseInt(span.css("top")) - (span.height()/ 2)) + "px");
                span.css("transform", "rotate(" + ((180 * a) + 90) + "deg)"); // not supported for ie8
            }
        }

        return Gauge;
    })();
    /**
     * get a instance of Logger
     *
     * @method  getLogger
     * @for flot.gauge
     * @private
     * @param  {Object} debugOptions the options of debug
     */
    function getLogger(debugOptions) {
        return typeof Logger !== "undefined" ? new Logger(debugOptions) : null;
    }

    /**
     * calculate the index of columns for the specified data
     *
     * @method col
     * @for flot.gauge
     * @param  {Number} columns the number of columns
     * @param  {Number} i       the index of the series
     * @return the index of columns
     */
    function col(columns, i) {
        return i % columns;
    }

    /**
     * calculate the index of rows for the specified data
     *
     * @method row
     * @for flot.gauge
     * @param  {Number} columns the number of rows
     * @param  {Number} i       the index of the series
     * @return the index of rows
     */
    function row(columns, i) {
        return Math.floor(i / columns);
    }

    /**
     * calculate the angle in radians
     *
     * internally, use a number without PI (0 - 2).
     * so, in this function, multiply PI
     *
     * @method toRad
     * @for flot.gauge
     * @param  {Number} a the number of angle without PI
     * @return the angle in radians
     */
    function toRad(a) {
        return a * Math.PI;
    }

    /**
     * draw an arc
     *
     * @method drawArc
     * @for flot.gauge
     * @param  {Object} context the context of canvas
     * @param  {Number} cx the x position of the center
     * @param  {Number} cy the y position of the center
     * @param  {Number} r the radius of an arc
     * @param  {Number} w the width of an arc
     * @param  {Number} rd1 the start angle of an arc in radians
     * @param  {Number} rd2 the end angle of an arc in radians
     * @param  {String} lc the color of a line
     * @param  {Number} lw the widht of a line
     * @param  {String} fc the fill color  of an arc
     */
    function drawArc(context, cx, cy, r, w, rd1, rd2, lc, lw, fc) {
        if (rd1 === rd2) {
            return;
        }
        var counterClockwise = false;
        context.save();
        context.beginPath();
        context.arc(cx, cy, r, rd1, rd2, counterClockwise);
        context.lineTo(cx + (r - w) * Math.cos(rd2),
                       cy + (r - w) * Math.sin(rd2));
        context.arc(cx, cy, r - w, rd2, rd1, !counterClockwise);
        context.closePath();
        if (lw) {
            context.lineWidth = lw;
        }
        if (lc) {
            context.strokeStyle = lc;
            context.stroke();
        }
        if (fc) {
            context.fillStyle = fc;
            context.fill();
        }
        context.restore();
    }

    /**
     * initialize plugin
     *
     * @method init
     * @for flot.gauge
     * @private
     * @param  {Object} plot a instance of plot
     */
    function init (plot) {
        // add processOptions hook
        plot.hooks.processOptions.push(function(plot, options) {
            var logger = getLogger(options.series.gauges.debug);




            // turn 'grid' and 'legend' off
            if (options.series.gauges.show) {
                options.grid.show = false;
                options.legend.show = false;
            }

            // sort threshold
            var thresholds = options.series.gauges.threshold.values;

            thresholds.sort(function(a, b) {
                if (a.value < b.value) {
                    return -1;
                } else if (a.value > b.value) {
                    return 1;
                } else {
                    return 0;
                }
            });



        });

        // add draw hook
        plot.hooks.draw.push(function(plot, context) {
            var options = plot.getOptions();
            var gaugeOptions = options.series.gauges;

            var logger = getLogger(gaugeOptions.debug);


            if (!gaugeOptions.show) {
                return;
            }

            var series = plot.getData();

            if (!series || !series.length) {
                return; // if no series were passed
            }

            var gauge = new Gauge(plot, context);

            // calculate layout
            var layout = gauge.calculateLayout();

            // debug layout
            if (gaugeOptions.debug.layout) {

            }

            // draw background
            gauge.drawBackground(layout)

            // draw cells (label, gauge, value, threshold)
            for (var i = 0; i < series.length; i++) {
                var item = series[i];

                var gaugeOptionsi = $.extend({}, gaugeOptions, item.gauges);
                if (item.gauges) {
                    // re-calculate 'auto' values
                    gauge.calculateAutoValues(gaugeOptionsi, layout.cellWidth);
                }

                // calculate cell layout
                var cellLayout = gauge.calculateCellLayout(gaugeOptionsi, layout, i);

                // draw cell background
                gauge.drawCellBackground(gaugeOptionsi, cellLayout)
                // debug layout
                if (gaugeOptionsi.debug.layout) {

                }
                // draw label
                if (gaugeOptionsi.label.show) {
                    gauge.drawLable(gaugeOptionsi, layout, cellLayout, i, item);
                }
                // draw gauge
                gauge.drawGauge(gaugeOptionsi, layout, cellLayout, item.label, item.data[0][1]);
                // draw threshold
                if (gaugeOptionsi.threshold.show) {
                    gauge.drawThreshold(gaugeOptionsi, layout, cellLayout);
                }
                if (gaugeOptionsi.threshold.label.show) {
                    gauge.drawThresholdValues(gaugeOptionsi, layout, cellLayout, i)
                }
                // draw value
                if (gaugeOptionsi.value.show) {
                    gauge.drawValue(gaugeOptionsi, layout, cellLayout, i, item);
                }
            }
        });
    }

    /**
     * [defaults description]
     *
     * @property defaults
     * @type {Object}
     */
    var defaults = {
        series: {
            gauges: {
                debug: {
                    log: false,
                    layout: false,
                    alert: false
                },
                show: false,
                layout: {
                    margin: 5,
                    columns: 3,
                    hMargin: 5,
                    vMargin: 5,
                    square: false
                },
                frame: {
                    show: true
                },
                cell: {
                    background: {
                        color: null
                    },
                    border: {
                        show: true,
                        color: "black",
                        width: 1
                    },
                    margin: 5,
                    vAlign: "middle" // 'top' or 'middle' or 'bottom'
                },
                gauge: {
                    width: "auto", // a specified number, or 'auto'
                    startAngle: 0.9, // 0 - 2 factor of the radians
                    endAngle: 2.1, // 0 - 2 factor of the radians
                    min: 0,
                    max: 100,
                    background: {
                        color: "white"
                    },
                    border: {
                        color: "lightgray",
                        width: 2
                    },
                    shadow: {
                        show: true,
                        blur: 5
                    }
                },
                label: {
                    show: true,
                    margin: "auto", // a specified number, or 'auto'
                    background: {
                        color: null,
                        opacity: 0
                    },
                    font: {
                        size: "auto", // a specified number, or 'auto'
                        family: "sans-serif"
                    },
                    color: null,
                    formatter: function(label, value) {
                        return label;
                    }
                },
                value: {
                    show: true,
                    margin: "auto", // a specified number, or 'auto'
                    background: {
                        color: null,
                        opacity: 0
                    },
                    font: {
                        size: "auto", // a specified number, or 'auto'
                        family: "sans-serif"
                    },
                    color: null,
                    formatter: function(label, value) {
                        return parseInt(value);
                    }
                },
                threshold: {
                    show: true,
                    width: "auto", // a specified number, or 'auto'
                    label: {
                        show: true,
                        margin: "auto", // a specified number, or 'auto'
                        background: {
                            color: null,
                            opacity: 0
                        },
                        font: {
                            size: "auto", // a specified number, or 'auto'
                            family: ",sans-serif"
                        },
                        color: null,
                        formatter: function(value) {
                            return value;
                        }
                    },
                    values: [
                        {
                            value: 50,
                            color: "lightgreen"
                        }, {
                            value: 80,
                            color: "yellow"
                        }, {
                            value: 100,
                            color: "red"
                        }
                    ]
                }
            }
        }
    };

    // register the gauge plugin
    $.plot.plugins.push({
        init: init,
        options: defaults,
        name: "gauge",
        version: "1.1.0"
    });

})(jQuery);


/***/ }),

/***/ 1510:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GettingStartedPanelCtrl", function() { return GettingStartedPanelCtrl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PanelCtrl", function() { return GettingStartedPanelCtrl; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_app_plugins_sdk__ = __webpack_require__(1305);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_app_core_core__ = __webpack_require__(465);
///<reference path="../../../headers/common.d.ts" />
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();


var GettingStartedPanelCtrl = /** @class */ (function (_super) {
    __extends(GettingStartedPanelCtrl, _super);
    /** @ngInject **/
    GettingStartedPanelCtrl.$inject = ["$scope", "$injector", "backendSrv", "datasourceSrv", "$q"];
    function GettingStartedPanelCtrl($scope, $injector, backendSrv, datasourceSrv, $q) {
        var _this = _super.call(this, $scope, $injector) || this;
        _this.backendSrv = backendSrv;
        _this.$q = $q;
        _this.stepIndex = 0;
        _this.steps = [];
        _this.steps.push({
            title: 'Install Grafana',
            icon: 'icon-gf icon-gf-check',
            href: 'http://docs.grafana.org/',
            target: '_blank',
            note: 'Review the installation docs',
            check: function () { return $q.when(true); },
        });
        _this.steps.push({
            title: 'Create your first data source',
            cta: 'Add data source',
            icon: 'icon-gf icon-gf-datasources',
            href: 'datasources/new?gettingstarted',
            check: function () {
                return $q.when(datasourceSrv.getMetricSources().filter(function (item) {
                    return item.meta.builtIn !== true;
                }).length > 0);
            }
        });
        _this.steps.push({
            title: 'Create your first dashboard',
            cta: 'New dashboard',
            icon: 'icon-gf icon-gf-dashboard',
            href: 'dashboard/new?gettingstarted',
            check: function () {
                return _this.backendSrv.search({ limit: 1 }).then(function (result) {
                    return result.length > 0;
                });
            }
        });
        _this.steps.push({
            title: 'Invite your team',
            cta: 'Add Users',
            icon: 'icon-gf icon-gf-users',
            href: 'org/users?gettingstarted',
            check: function () {
                return _this.backendSrv.get('/api/org/users').then(function (res) {
                    return res.length > 1;
                });
            }
        });
        _this.steps.push({
            title: 'Install apps & plugins',
            cta: 'Explore plugin repository',
            icon: 'icon-gf icon-gf-apps',
            href: 'https://grafana.com/plugins?utm_source=grafana_getting_started',
            check: function () {
                return _this.backendSrv.get('/api/plugins', { embedded: 0, core: 0 }).then(function (plugins) {
                    return plugins.length > 0;
                });
            }
        });
        return _this;
    }
    GettingStartedPanelCtrl.prototype.$onInit = function () {
        var _this = this;
        this.stepIndex = -1;
        return this.nextStep().then(function (res) {
            _this.checksDone = true;
        });
    };
    GettingStartedPanelCtrl.prototype.nextStep = function () {
        var _this = this;
        if (this.stepIndex === this.steps.length - 1) {
            return this.$q.when();
        }
        this.stepIndex += 1;
        var currentStep = this.steps[this.stepIndex];
        return currentStep.check().then(function (passed) {
            if (passed) {
                currentStep.cssClass = 'completed';
                return _this.nextStep();
            }
            currentStep.cssClass = 'active';
            return _this.$q.when();
        });
    };
    GettingStartedPanelCtrl.prototype.dismiss = function () {
        this.row.removePanel(this.panel, false);
        this.backendSrv.request({
            method: 'PUT',
            url: '/api/user/helpflags/1',
            showSuccessAlert: false,
        }).then(function (res) {
            __WEBPACK_IMPORTED_MODULE_1_app_core_core__["contextSrv"].user.helpFlags1 = res.helpFlags1;
        });
    };
    GettingStartedPanelCtrl.templateUrl = 'public/app/plugins/panel/gettingstarted/module.html';
    return GettingStartedPanelCtrl;
}(__WEBPACK_IMPORTED_MODULE_0_app_plugins_sdk__["PanelCtrl"]));



/***/ }),

/***/ 1511:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ConfigCtrl", function() { return ConfigCtrl; });
///<reference path="../../../headers/common.d.ts" />
var ConfigCtrl = /** @class */ (function () {
    /** @ngInject **/
    ConfigCtrl.$inject = ["backendSrv"];
    function ConfigCtrl(backendSrv) {
        this.backendSrv = backendSrv;
        this.appEditCtrl.setPreUpdateHook(this.initDatasource.bind(this));
    }
    ConfigCtrl.prototype.initDatasource = function () {
        var _this = this;
        return this.backendSrv.get('/api/datasources').then(function (res) {
            var found = false;
            for (var _i = 0, res_1 = res; _i < res_1.length; _i++) {
                var ds = res_1[_i];
                if (ds.type === "grafana-testdata-datasource") {
                    found = true;
                }
            }
            if (!found) {
                var dsInstance = {
                    name: 'Grafana TestData',
                    type: 'grafana-testdata-datasource',
                    access: 'direct',
                    jsonData: {}
                };
                return _this.backendSrv.post('/api/datasources', dsInstance);
            }
            return Promise.resolve();
        });
    };
    ConfigCtrl.template = '';
    return ConfigCtrl;
}());



/***/ }),

/***/ 1512:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AnnotationsQueryCtrl", function() { return TestDataAnnotationsQueryCtrl; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__datasource__ = __webpack_require__(1513);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__query_ctrl__ = __webpack_require__(1514);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "TestDataDatasource", function() { return __WEBPACK_IMPORTED_MODULE_0__datasource__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "Datasource", function() { return __WEBPACK_IMPORTED_MODULE_0__datasource__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "QueryCtrl", function() { return __WEBPACK_IMPORTED_MODULE_1__query_ctrl__["a"]; });


var TestDataAnnotationsQueryCtrl = /** @class */ (function () {
    function TestDataAnnotationsQueryCtrl() {
    }
    TestDataAnnotationsQueryCtrl.template = '<h2>test data</h2>';
    return TestDataAnnotationsQueryCtrl;
}());



/***/ }),

/***/ 1513:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return TestDataDatasource; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_lodash__);

var TestDataDatasource = /** @class */ (function () {
    /** @ngInject */
    TestDataDatasource.$inject = ["instanceSettings", "backendSrv", "$q"];
    function TestDataDatasource(instanceSettings, backendSrv, $q) {
        this.backendSrv = backendSrv;
        this.$q = $q;
        this.id = instanceSettings.id;
    }
    TestDataDatasource.prototype.query = function (options) {
        var _this = this;
        var queries = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.filter(options.targets, function (item) {
            return item.hide !== true;
        }).map(function (item) {
            return {
                refId: item.refId,
                scenarioId: item.scenarioId,
                intervalMs: options.intervalMs,
                maxDataPoints: options.maxDataPoints,
                stringInput: item.stringInput,
                points: item.points,
                alias: item.alias,
                datasourceId: _this.id,
            };
        });
        if (queries.length === 0) {
            return this.$q.when({ data: [] });
        }
        return this.backendSrv.post('/api/tsdb/query', {
            from: options.range.from.valueOf().toString(),
            to: options.range.to.valueOf().toString(),
            queries: queries,
        }).then(function (res) {
            var data = [];
            if (res.results) {
                __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.forEach(res.results, function (queryRes) {
                    for (var _i = 0, _a = queryRes.series; _i < _a.length; _i++) {
                        var series = _a[_i];
                        data.push({
                            target: series.name,
                            datapoints: series.points
                        });
                    }
                });
            }
            return { data: data };
        });
    };
    TestDataDatasource.prototype.annotationQuery = function (options) {
        return this.backendSrv.get('/api/annotations', {
            from: options.range.from.valueOf(),
            to: options.range.to.valueOf(),
            limit: options.limit,
            type: options.type,
        });
    };
    return TestDataDatasource;
}());



/***/ }),

/***/ 1514:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return TestDataQueryCtrl; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_app_plugins_sdk__ = __webpack_require__(1305);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_moment__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_moment___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_moment__);
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();



var TestDataQueryCtrl = /** @class */ (function (_super) {
    __extends(TestDataQueryCtrl, _super);
    /** @ngInject **/
    TestDataQueryCtrl.$inject = ["$scope", "$injector", "backendSrv"];
    function TestDataQueryCtrl($scope, $injector, backendSrv) {
        var _this = _super.call(this, $scope, $injector) || this;
        _this.backendSrv = backendSrv;
        _this.target.scenarioId = _this.target.scenarioId || 'random_walk';
        _this.scenarioList = [];
        _this.newPointTime = __WEBPACK_IMPORTED_MODULE_2_moment___default()();
        _this.selectedPoint = { text: 'Select point', value: null };
        return _this;
    }
    TestDataQueryCtrl.prototype.getPoints = function () {
        return __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.map(this.target.points, function (point, index) {
            return {
                text: __WEBPACK_IMPORTED_MODULE_2_moment___default()(point[1]).format('MMMM Do YYYY, H:mm:ss') + ' : ' + point[0],
                value: index,
            };
        });
    };
    TestDataQueryCtrl.prototype.pointSelected = function (option) {
        this.selectedPoint = option;
    };
    TestDataQueryCtrl.prototype.deletePoint = function () {
        this.target.points.splice(this.selectedPoint.value, 1);
        this.selectedPoint = { text: 'Select point', value: null };
        this.refresh();
    };
    TestDataQueryCtrl.prototype.addPoint = function () {
        this.target.points = this.target.points || [];
        this.target.points.push([this.newPointValue, this.newPointTime.valueOf()]);
        this.target.points = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.sortBy(this.target.points, function (p) { return p[1]; });
        this.refresh();
    };
    TestDataQueryCtrl.prototype.$onInit = function () {
        var _this = this;
        return this.backendSrv.get('/api/tsdb/testdata/scenarios').then(function (res) {
            _this.scenarioList = res;
            _this.scenario = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.find(_this.scenarioList, { id: _this.target.scenarioId });
        });
    };
    TestDataQueryCtrl.prototype.scenarioChanged = function () {
        this.scenario = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.find(this.scenarioList, { id: this.target.scenarioId });
        this.target.stringInput = this.scenario.stringInput;
        if (this.target.scenarioId === 'manual_entry') {
            this.target.points = this.target.points || [];
        }
        else {
            delete this.target.points;
        }
        this.refresh();
    };
    TestDataQueryCtrl.templateUrl = 'partials/query.editor.html';
    return TestDataQueryCtrl;
}(__WEBPACK_IMPORTED_MODULE_1_app_plugins_sdk__["QueryCtrl"]));



/***/ }),

/***/ 1515:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Observable_1 = __webpack_require__(466);
var Subscriber_1 = __webpack_require__(468);
var Subscription_1 = __webpack_require__(472);
var ObjectUnsubscribedError_1 = __webpack_require__(1516);
var SubjectSubscription_1 = __webpack_require__(1517);
var rxSubscriber_1 = __webpack_require__(205);
/**
 * @class SubjectSubscriber<T>
 */
var SubjectSubscriber = (function (_super) {
    __extends(SubjectSubscriber, _super);
    function SubjectSubscriber(destination) {
        _super.call(this, destination);
        this.destination = destination;
    }
    return SubjectSubscriber;
}(Subscriber_1.Subscriber));
exports.SubjectSubscriber = SubjectSubscriber;
/**
 * @class Subject<T>
 */
var Subject = (function (_super) {
    __extends(Subject, _super);
    function Subject() {
        _super.call(this);
        this.observers = [];
        this.closed = false;
        this.isStopped = false;
        this.hasError = false;
        this.thrownError = null;
    }
    Subject.prototype[rxSubscriber_1.rxSubscriber] = function () {
        return new SubjectSubscriber(this);
    };
    Subject.prototype.lift = function (operator) {
        var subject = new AnonymousSubject(this, this);
        subject.operator = operator;
        return subject;
    };
    Subject.prototype.next = function (value) {
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        if (!this.isStopped) {
            var observers = this.observers;
            var len = observers.length;
            var copy = observers.slice();
            for (var i = 0; i < len; i++) {
                copy[i].next(value);
            }
        }
    };
    Subject.prototype.error = function (err) {
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        this.hasError = true;
        this.thrownError = err;
        this.isStopped = true;
        var observers = this.observers;
        var len = observers.length;
        var copy = observers.slice();
        for (var i = 0; i < len; i++) {
            copy[i].error(err);
        }
        this.observers.length = 0;
    };
    Subject.prototype.complete = function () {
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        this.isStopped = true;
        var observers = this.observers;
        var len = observers.length;
        var copy = observers.slice();
        for (var i = 0; i < len; i++) {
            copy[i].complete();
        }
        this.observers.length = 0;
    };
    Subject.prototype.unsubscribe = function () {
        this.isStopped = true;
        this.closed = true;
        this.observers = null;
    };
    Subject.prototype._trySubscribe = function (subscriber) {
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        else {
            return _super.prototype._trySubscribe.call(this, subscriber);
        }
    };
    Subject.prototype._subscribe = function (subscriber) {
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        else if (this.hasError) {
            subscriber.error(this.thrownError);
            return Subscription_1.Subscription.EMPTY;
        }
        else if (this.isStopped) {
            subscriber.complete();
            return Subscription_1.Subscription.EMPTY;
        }
        else {
            this.observers.push(subscriber);
            return new SubjectSubscription_1.SubjectSubscription(this, subscriber);
        }
    };
    Subject.prototype.asObservable = function () {
        var observable = new Observable_1.Observable();
        observable.source = this;
        return observable;
    };
    Subject.create = function (destination, source) {
        return new AnonymousSubject(destination, source);
    };
    return Subject;
}(Observable_1.Observable));
exports.Subject = Subject;
/**
 * @class AnonymousSubject<T>
 */
var AnonymousSubject = (function (_super) {
    __extends(AnonymousSubject, _super);
    function AnonymousSubject(destination, source) {
        _super.call(this);
        this.destination = destination;
        this.source = source;
    }
    AnonymousSubject.prototype.next = function (value) {
        var destination = this.destination;
        if (destination && destination.next) {
            destination.next(value);
        }
    };
    AnonymousSubject.prototype.error = function (err) {
        var destination = this.destination;
        if (destination && destination.error) {
            this.destination.error(err);
        }
    };
    AnonymousSubject.prototype.complete = function () {
        var destination = this.destination;
        if (destination && destination.complete) {
            this.destination.complete();
        }
    };
    AnonymousSubject.prototype._subscribe = function (subscriber) {
        var source = this.source;
        if (source) {
            return this.source.subscribe(subscriber);
        }
        else {
            return Subscription_1.Subscription.EMPTY;
        }
    };
    return AnonymousSubject;
}(Subject));
exports.AnonymousSubject = AnonymousSubject;
//# sourceMappingURL=Subject.js.map

/***/ }),

/***/ 1516:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
/**
 * An error thrown when an action is invalid because the object has been
 * unsubscribed.
 *
 * @see {@link Subject}
 * @see {@link BehaviorSubject}
 *
 * @class ObjectUnsubscribedError
 */
var ObjectUnsubscribedError = (function (_super) {
    __extends(ObjectUnsubscribedError, _super);
    function ObjectUnsubscribedError() {
        var err = _super.call(this, 'object unsubscribed');
        this.name = err.name = 'ObjectUnsubscribedError';
        this.stack = err.stack;
        this.message = err.message;
    }
    return ObjectUnsubscribedError;
}(Error));
exports.ObjectUnsubscribedError = ObjectUnsubscribedError;
//# sourceMappingURL=ObjectUnsubscribedError.js.map

/***/ }),

/***/ 1517:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscription_1 = __webpack_require__(472);
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SubjectSubscription = (function (_super) {
    __extends(SubjectSubscription, _super);
    function SubjectSubscription(subject, subscriber) {
        _super.call(this);
        this.subject = subject;
        this.subscriber = subscriber;
        this.closed = false;
    }
    SubjectSubscription.prototype.unsubscribe = function () {
        if (this.closed) {
            return;
        }
        this.closed = true;
        var subject = this.subject;
        var observers = subject.observers;
        this.subject = null;
        if (!observers || observers.length === 0 || subject.isStopped || subject.closed) {
            return;
        }
        var subscriberIndex = observers.indexOf(this.subscriber);
        if (subscriberIndex !== -1) {
            observers.splice(subscriberIndex, 1);
        }
    };
    return SubjectSubscription;
}(Subscription_1.Subscription));
exports.SubjectSubscription = SubjectSubscription;
//# sourceMappingURL=SubjectSubscription.js.map

/***/ }),

/***/ 1518:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(466);
var empty_1 = __webpack_require__(1519);
Observable_1.Observable.empty = empty_1.empty;
//# sourceMappingURL=empty.js.map

/***/ }),

/***/ 1519:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var EmptyObservable_1 = __webpack_require__(1319);
exports.empty = EmptyObservable_1.EmptyObservable.create;
//# sourceMappingURL=empty.js.map

/***/ }),

/***/ 1520:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(466);
var from_1 = __webpack_require__(1521);
Observable_1.Observable.from = from_1.from;
//# sourceMappingURL=from.js.map

/***/ }),

/***/ 1521:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var FromObservable_1 = __webpack_require__(1522);
exports.from = FromObservable_1.FromObservable.create;
//# sourceMappingURL=from.js.map

/***/ }),

/***/ 1522:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var isArray_1 = __webpack_require__(473);
var isArrayLike_1 = __webpack_require__(1343);
var isPromise_1 = __webpack_require__(1344);
var PromiseObservable_1 = __webpack_require__(1523);
var IteratorObservable_1 = __webpack_require__(1524);
var ArrayObservable_1 = __webpack_require__(1345);
var ArrayLikeObservable_1 = __webpack_require__(1526);
var iterator_1 = __webpack_require__(1320);
var Observable_1 = __webpack_require__(466);
var observeOn_1 = __webpack_require__(1527);
var observable_1 = __webpack_require__(474);
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var FromObservable = (function (_super) {
    __extends(FromObservable, _super);
    function FromObservable(ish, scheduler) {
        _super.call(this, null);
        this.ish = ish;
        this.scheduler = scheduler;
    }
    /**
     * Creates an Observable from an Array, an array-like object, a Promise, an
     * iterable object, or an Observable-like object.
     *
     * <span class="informal">Converts almost anything to an Observable.</span>
     *
     * <img src="./img/from.png" width="100%">
     *
     * Convert various other objects and data types into Observables. `from`
     * converts a Promise or an array-like or an
     * [iterable](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#iterable)
     * object into an Observable that emits the items in that promise or array or
     * iterable. A String, in this context, is treated as an array of characters.
     * Observable-like objects (contains a function named with the ES2015 Symbol
     * for Observable) can also be converted through this operator.
     *
     * @example <caption>Converts an array to an Observable</caption>
     * var array = [10, 20, 30];
     * var result = Rx.Observable.from(array);
     * result.subscribe(x => console.log(x));
     *
     * // Results in the following:
     * // 10 20 30
     *
     * @example <caption>Convert an infinite iterable (from a generator) to an Observable</caption>
     * function* generateDoubles(seed) {
     *   var i = seed;
     *   while (true) {
     *     yield i;
     *     i = 2 * i; // double it
     *   }
     * }
     *
     * var iterator = generateDoubles(3);
     * var result = Rx.Observable.from(iterator).take(10);
     * result.subscribe(x => console.log(x));
     *
     * // Results in the following:
     * // 3 6 12 24 48 96 192 384 768 1536
     *
     * @see {@link create}
     * @see {@link fromEvent}
     * @see {@link fromEventPattern}
     * @see {@link fromPromise}
     *
     * @param {ObservableInput<T>} ish A subscribable object, a Promise, an
     * Observable-like, an Array, an iterable or an array-like object to be
     * converted.
     * @param {Scheduler} [scheduler] The scheduler on which to schedule the
     * emissions of values.
     * @return {Observable<T>} The Observable whose values are originally from the
     * input object that was converted.
     * @static true
     * @name from
     * @owner Observable
     */
    FromObservable.create = function (ish, scheduler) {
        if (ish != null) {
            if (typeof ish[observable_1.observable] === 'function') {
                if (ish instanceof Observable_1.Observable && !scheduler) {
                    return ish;
                }
                return new FromObservable(ish, scheduler);
            }
            else if (isArray_1.isArray(ish)) {
                return new ArrayObservable_1.ArrayObservable(ish, scheduler);
            }
            else if (isPromise_1.isPromise(ish)) {
                return new PromiseObservable_1.PromiseObservable(ish, scheduler);
            }
            else if (typeof ish[iterator_1.iterator] === 'function' || typeof ish === 'string') {
                return new IteratorObservable_1.IteratorObservable(ish, scheduler);
            }
            else if (isArrayLike_1.isArrayLike(ish)) {
                return new ArrayLikeObservable_1.ArrayLikeObservable(ish, scheduler);
            }
        }
        throw new TypeError((ish !== null && typeof ish || ish) + ' is not observable');
    };
    FromObservable.prototype._subscribe = function (subscriber) {
        var ish = this.ish;
        var scheduler = this.scheduler;
        if (scheduler == null) {
            return ish[observable_1.observable]().subscribe(subscriber);
        }
        else {
            return ish[observable_1.observable]().subscribe(new observeOn_1.ObserveOnSubscriber(subscriber, scheduler, 0));
        }
    };
    return FromObservable;
}(Observable_1.Observable));
exports.FromObservable = FromObservable;
//# sourceMappingURL=FromObservable.js.map

/***/ }),

/***/ 1523:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var root_1 = __webpack_require__(127);
var Observable_1 = __webpack_require__(466);
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var PromiseObservable = (function (_super) {
    __extends(PromiseObservable, _super);
    function PromiseObservable(promise, scheduler) {
        _super.call(this);
        this.promise = promise;
        this.scheduler = scheduler;
    }
    /**
     * Converts a Promise to an Observable.
     *
     * <span class="informal">Returns an Observable that just emits the Promise's
     * resolved value, then completes.</span>
     *
     * Converts an ES2015 Promise or a Promises/A+ spec compliant Promise to an
     * Observable. If the Promise resolves with a value, the output Observable
     * emits that resolved value as a `next`, and then completes. If the Promise
     * is rejected, then the output Observable emits the corresponding Error.
     *
     * @example <caption>Convert the Promise returned by Fetch to an Observable</caption>
     * var result = Rx.Observable.fromPromise(fetch('http://myserver.com/'));
     * result.subscribe(x => console.log(x), e => console.error(e));
     *
     * @see {@link bindCallback}
     * @see {@link from}
     *
     * @param {PromiseLike<T>} promise The promise to be converted.
     * @param {Scheduler} [scheduler] An optional IScheduler to use for scheduling
     * the delivery of the resolved value (or the rejection).
     * @return {Observable<T>} An Observable which wraps the Promise.
     * @static true
     * @name fromPromise
     * @owner Observable
     */
    PromiseObservable.create = function (promise, scheduler) {
        return new PromiseObservable(promise, scheduler);
    };
    PromiseObservable.prototype._subscribe = function (subscriber) {
        var _this = this;
        var promise = this.promise;
        var scheduler = this.scheduler;
        if (scheduler == null) {
            if (this._isScalar) {
                if (!subscriber.closed) {
                    subscriber.next(this.value);
                    subscriber.complete();
                }
            }
            else {
                promise.then(function (value) {
                    _this.value = value;
                    _this._isScalar = true;
                    if (!subscriber.closed) {
                        subscriber.next(value);
                        subscriber.complete();
                    }
                }, function (err) {
                    if (!subscriber.closed) {
                        subscriber.error(err);
                    }
                })
                    .then(null, function (err) {
                    // escape the promise trap, throw unhandled errors
                    root_1.root.setTimeout(function () { throw err; });
                });
            }
        }
        else {
            if (this._isScalar) {
                if (!subscriber.closed) {
                    return scheduler.schedule(dispatchNext, 0, { value: this.value, subscriber: subscriber });
                }
            }
            else {
                promise.then(function (value) {
                    _this.value = value;
                    _this._isScalar = true;
                    if (!subscriber.closed) {
                        subscriber.add(scheduler.schedule(dispatchNext, 0, { value: value, subscriber: subscriber }));
                    }
                }, function (err) {
                    if (!subscriber.closed) {
                        subscriber.add(scheduler.schedule(dispatchError, 0, { err: err, subscriber: subscriber }));
                    }
                })
                    .then(null, function (err) {
                    // escape the promise trap, throw unhandled errors
                    root_1.root.setTimeout(function () { throw err; });
                });
            }
        }
    };
    return PromiseObservable;
}(Observable_1.Observable));
exports.PromiseObservable = PromiseObservable;
function dispatchNext(arg) {
    var value = arg.value, subscriber = arg.subscriber;
    if (!subscriber.closed) {
        subscriber.next(value);
        subscriber.complete();
    }
}
function dispatchError(arg) {
    var err = arg.err, subscriber = arg.subscriber;
    if (!subscriber.closed) {
        subscriber.error(err);
    }
}
//# sourceMappingURL=PromiseObservable.js.map

/***/ }),

/***/ 1524:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var root_1 = __webpack_require__(127);
var Observable_1 = __webpack_require__(466);
var iterator_1 = __webpack_require__(1320);
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var IteratorObservable = (function (_super) {
    __extends(IteratorObservable, _super);
    function IteratorObservable(iterator, scheduler) {
        _super.call(this);
        this.scheduler = scheduler;
        if (iterator == null) {
            throw new Error('iterator cannot be null.');
        }
        this.iterator = getIterator(iterator);
    }
    IteratorObservable.create = function (iterator, scheduler) {
        return new IteratorObservable(iterator, scheduler);
    };
    IteratorObservable.dispatch = function (state) {
        var index = state.index, hasError = state.hasError, iterator = state.iterator, subscriber = state.subscriber;
        if (hasError) {
            subscriber.error(state.error);
            return;
        }
        var result = iterator.next();
        if (result.done) {
            subscriber.complete();
            return;
        }
        subscriber.next(result.value);
        state.index = index + 1;
        if (subscriber.closed) {
            if (typeof iterator.return === 'function') {
                iterator.return();
            }
            return;
        }
        this.schedule(state);
    };
    IteratorObservable.prototype._subscribe = function (subscriber) {
        var index = 0;
        var _a = this, iterator = _a.iterator, scheduler = _a.scheduler;
        if (scheduler) {
            return scheduler.schedule(IteratorObservable.dispatch, 0, {
                index: index, iterator: iterator, subscriber: subscriber
            });
        }
        else {
            do {
                var result = iterator.next();
                if (result.done) {
                    subscriber.complete();
                    break;
                }
                else {
                    subscriber.next(result.value);
                }
                if (subscriber.closed) {
                    if (typeof iterator.return === 'function') {
                        iterator.return();
                    }
                    break;
                }
            } while (true);
        }
    };
    return IteratorObservable;
}(Observable_1.Observable));
exports.IteratorObservable = IteratorObservable;
var StringIterator = (function () {
    function StringIterator(str, idx, len) {
        if (idx === void 0) { idx = 0; }
        if (len === void 0) { len = str.length; }
        this.str = str;
        this.idx = idx;
        this.len = len;
    }
    StringIterator.prototype[iterator_1.iterator] = function () { return (this); };
    StringIterator.prototype.next = function () {
        return this.idx < this.len ? {
            done: false,
            value: this.str.charAt(this.idx++)
        } : {
            done: true,
            value: undefined
        };
    };
    return StringIterator;
}());
var ArrayIterator = (function () {
    function ArrayIterator(arr, idx, len) {
        if (idx === void 0) { idx = 0; }
        if (len === void 0) { len = toLength(arr); }
        this.arr = arr;
        this.idx = idx;
        this.len = len;
    }
    ArrayIterator.prototype[iterator_1.iterator] = function () { return this; };
    ArrayIterator.prototype.next = function () {
        return this.idx < this.len ? {
            done: false,
            value: this.arr[this.idx++]
        } : {
            done: true,
            value: undefined
        };
    };
    return ArrayIterator;
}());
function getIterator(obj) {
    var i = obj[iterator_1.iterator];
    if (!i && typeof obj === 'string') {
        return new StringIterator(obj);
    }
    if (!i && obj.length !== undefined) {
        return new ArrayIterator(obj);
    }
    if (!i) {
        throw new TypeError('object is not iterable');
    }
    return obj[iterator_1.iterator]();
}
var maxSafeInteger = Math.pow(2, 53) - 1;
function toLength(o) {
    var len = +o.length;
    if (isNaN(len)) {
        return 0;
    }
    if (len === 0 || !numberIsFinite(len)) {
        return len;
    }
    len = sign(len) * Math.floor(Math.abs(len));
    if (len <= 0) {
        return 0;
    }
    if (len > maxSafeInteger) {
        return maxSafeInteger;
    }
    return len;
}
function numberIsFinite(value) {
    return typeof value === 'number' && root_1.root.isFinite(value);
}
function sign(value) {
    var valueAsNumber = +value;
    if (valueAsNumber === 0) {
        return valueAsNumber;
    }
    if (isNaN(valueAsNumber)) {
        return valueAsNumber;
    }
    return valueAsNumber < 0 ? -1 : 1;
}
//# sourceMappingURL=IteratorObservable.js.map

/***/ }),

/***/ 1525:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function isScheduler(value) {
    return value && typeof value.schedule === 'function';
}
exports.isScheduler = isScheduler;
//# sourceMappingURL=isScheduler.js.map

/***/ }),

/***/ 1526:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Observable_1 = __webpack_require__(466);
var ScalarObservable_1 = __webpack_require__(1346);
var EmptyObservable_1 = __webpack_require__(1319);
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var ArrayLikeObservable = (function (_super) {
    __extends(ArrayLikeObservable, _super);
    function ArrayLikeObservable(arrayLike, scheduler) {
        _super.call(this);
        this.arrayLike = arrayLike;
        this.scheduler = scheduler;
        if (!scheduler && arrayLike.length === 1) {
            this._isScalar = true;
            this.value = arrayLike[0];
        }
    }
    ArrayLikeObservable.create = function (arrayLike, scheduler) {
        var length = arrayLike.length;
        if (length === 0) {
            return new EmptyObservable_1.EmptyObservable();
        }
        else if (length === 1) {
            return new ScalarObservable_1.ScalarObservable(arrayLike[0], scheduler);
        }
        else {
            return new ArrayLikeObservable(arrayLike, scheduler);
        }
    };
    ArrayLikeObservable.dispatch = function (state) {
        var arrayLike = state.arrayLike, index = state.index, length = state.length, subscriber = state.subscriber;
        if (subscriber.closed) {
            return;
        }
        if (index >= length) {
            subscriber.complete();
            return;
        }
        subscriber.next(arrayLike[index]);
        state.index = index + 1;
        this.schedule(state);
    };
    ArrayLikeObservable.prototype._subscribe = function (subscriber) {
        var index = 0;
        var _a = this, arrayLike = _a.arrayLike, scheduler = _a.scheduler;
        var length = arrayLike.length;
        if (scheduler) {
            return scheduler.schedule(ArrayLikeObservable.dispatch, 0, {
                arrayLike: arrayLike, index: index, length: length, subscriber: subscriber
            });
        }
        else {
            for (var i = 0; i < length && !subscriber.closed; i++) {
                subscriber.next(arrayLike[i]);
            }
            subscriber.complete();
        }
    };
    return ArrayLikeObservable;
}(Observable_1.Observable));
exports.ArrayLikeObservable = ArrayLikeObservable;
//# sourceMappingURL=ArrayLikeObservable.js.map

/***/ }),

/***/ 1527:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(468);
var Notification_1 = __webpack_require__(1528);
/**
 *
 * Re-emits all notifications from source Observable with specified scheduler.
 *
 * <span class="informal">Ensure a specific scheduler is used, from outside of an Observable.</span>
 *
 * `observeOn` is an operator that accepts a scheduler as a first parameter, which will be used to reschedule
 * notifications emitted by the source Observable. It might be useful, if you do not have control over
 * internal scheduler of a given Observable, but want to control when its values are emitted nevertheless.
 *
 * Returned Observable emits the same notifications (nexted values, complete and error events) as the source Observable,
 * but rescheduled with provided scheduler. Note that this doesn't mean that source Observables internal
 * scheduler will be replaced in any way. Original scheduler still will be used, but when the source Observable emits
 * notification, it will be immediately scheduled again - this time with scheduler passed to `observeOn`.
 * An anti-pattern would be calling `observeOn` on Observable that emits lots of values synchronously, to split
 * that emissions into asynchronous chunks. For this to happen, scheduler would have to be passed into the source
 * Observable directly (usually into the operator that creates it). `observeOn` simply delays notifications a
 * little bit more, to ensure that they are emitted at expected moments.
 *
 * As a matter of fact, `observeOn` accepts second parameter, which specifies in milliseconds with what delay notifications
 * will be emitted. The main difference between {@link delay} operator and `observeOn` is that `observeOn`
 * will delay all notifications - including error notifications - while `delay` will pass through error
 * from source Observable immediately when it is emitted. In general it is highly recommended to use `delay` operator
 * for any kind of delaying of values in the stream, while using `observeOn` to specify which scheduler should be used
 * for notification emissions in general.
 *
 * @example <caption>Ensure values in subscribe are called just before browser repaint.</caption>
 * const intervals = Rx.Observable.interval(10); // Intervals are scheduled
 *                                               // with async scheduler by default...
 *
 * intervals
 * .observeOn(Rx.Scheduler.animationFrame)       // ...but we will observe on animationFrame
 * .subscribe(val => {                           // scheduler to ensure smooth animation.
 *   someDiv.style.height = val + 'px';
 * });
 *
 * @see {@link delay}
 *
 * @param {IScheduler} scheduler Scheduler that will be used to reschedule notifications from source Observable.
 * @param {number} [delay] Number of milliseconds that states with what delay every notification should be rescheduled.
 * @return {Observable<T>} Observable that emits the same notifications as the source Observable,
 * but with provided scheduler.
 *
 * @method observeOn
 * @owner Observable
 */
function observeOn(scheduler, delay) {
    if (delay === void 0) { delay = 0; }
    return function observeOnOperatorFunction(source) {
        return source.lift(new ObserveOnOperator(scheduler, delay));
    };
}
exports.observeOn = observeOn;
var ObserveOnOperator = (function () {
    function ObserveOnOperator(scheduler, delay) {
        if (delay === void 0) { delay = 0; }
        this.scheduler = scheduler;
        this.delay = delay;
    }
    ObserveOnOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ObserveOnSubscriber(subscriber, this.scheduler, this.delay));
    };
    return ObserveOnOperator;
}());
exports.ObserveOnOperator = ObserveOnOperator;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var ObserveOnSubscriber = (function (_super) {
    __extends(ObserveOnSubscriber, _super);
    function ObserveOnSubscriber(destination, scheduler, delay) {
        if (delay === void 0) { delay = 0; }
        _super.call(this, destination);
        this.scheduler = scheduler;
        this.delay = delay;
    }
    ObserveOnSubscriber.dispatch = function (arg) {
        var notification = arg.notification, destination = arg.destination;
        notification.observe(destination);
        this.unsubscribe();
    };
    ObserveOnSubscriber.prototype.scheduleMessage = function (notification) {
        this.add(this.scheduler.schedule(ObserveOnSubscriber.dispatch, this.delay, new ObserveOnMessage(notification, this.destination)));
    };
    ObserveOnSubscriber.prototype._next = function (value) {
        this.scheduleMessage(Notification_1.Notification.createNext(value));
    };
    ObserveOnSubscriber.prototype._error = function (err) {
        this.scheduleMessage(Notification_1.Notification.createError(err));
    };
    ObserveOnSubscriber.prototype._complete = function () {
        this.scheduleMessage(Notification_1.Notification.createComplete());
    };
    return ObserveOnSubscriber;
}(Subscriber_1.Subscriber));
exports.ObserveOnSubscriber = ObserveOnSubscriber;
var ObserveOnMessage = (function () {
    function ObserveOnMessage(notification, destination) {
        this.notification = notification;
        this.destination = destination;
    }
    return ObserveOnMessage;
}());
exports.ObserveOnMessage = ObserveOnMessage;
//# sourceMappingURL=observeOn.js.map

/***/ }),

/***/ 1528:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(466);
/**
 * Represents a push-based event or value that an {@link Observable} can emit.
 * This class is particularly useful for operators that manage notifications,
 * like {@link materialize}, {@link dematerialize}, {@link observeOn}, and
 * others. Besides wrapping the actual delivered value, it also annotates it
 * with metadata of, for instance, what type of push message it is (`next`,
 * `error`, or `complete`).
 *
 * @see {@link materialize}
 * @see {@link dematerialize}
 * @see {@link observeOn}
 *
 * @class Notification<T>
 */
var Notification = (function () {
    function Notification(kind, value, error) {
        this.kind = kind;
        this.value = value;
        this.error = error;
        this.hasValue = kind === 'N';
    }
    /**
     * Delivers to the given `observer` the value wrapped by this Notification.
     * @param {Observer} observer
     * @return
     */
    Notification.prototype.observe = function (observer) {
        switch (this.kind) {
            case 'N':
                return observer.next && observer.next(this.value);
            case 'E':
                return observer.error && observer.error(this.error);
            case 'C':
                return observer.complete && observer.complete();
        }
    };
    /**
     * Given some {@link Observer} callbacks, deliver the value represented by the
     * current Notification to the correctly corresponding callback.
     * @param {function(value: T): void} next An Observer `next` callback.
     * @param {function(err: any): void} [error] An Observer `error` callback.
     * @param {function(): void} [complete] An Observer `complete` callback.
     * @return {any}
     */
    Notification.prototype.do = function (next, error, complete) {
        var kind = this.kind;
        switch (kind) {
            case 'N':
                return next && next(this.value);
            case 'E':
                return error && error(this.error);
            case 'C':
                return complete && complete();
        }
    };
    /**
     * Takes an Observer or its individual callback functions, and calls `observe`
     * or `do` methods accordingly.
     * @param {Observer|function(value: T): void} nextOrObserver An Observer or
     * the `next` callback.
     * @param {function(err: any): void} [error] An Observer `error` callback.
     * @param {function(): void} [complete] An Observer `complete` callback.
     * @return {any}
     */
    Notification.prototype.accept = function (nextOrObserver, error, complete) {
        if (nextOrObserver && typeof nextOrObserver.next === 'function') {
            return this.observe(nextOrObserver);
        }
        else {
            return this.do(nextOrObserver, error, complete);
        }
    };
    /**
     * Returns a simple Observable that just delivers the notification represented
     * by this Notification instance.
     * @return {any}
     */
    Notification.prototype.toObservable = function () {
        var kind = this.kind;
        switch (kind) {
            case 'N':
                return Observable_1.Observable.of(this.value);
            case 'E':
                return Observable_1.Observable.throw(this.error);
            case 'C':
                return Observable_1.Observable.empty();
        }
        throw new Error('unexpected notification kind value');
    };
    /**
     * A shortcut to create a Notification instance of the type `next` from a
     * given value.
     * @param {T} value The `next` value.
     * @return {Notification<T>} The "next" Notification representing the
     * argument.
     */
    Notification.createNext = function (value) {
        if (typeof value !== 'undefined') {
            return new Notification('N', value);
        }
        return Notification.undefinedValueNotification;
    };
    /**
     * A shortcut to create a Notification instance of the type `error` from a
     * given error.
     * @param {any} [err] The `error` error.
     * @return {Notification<T>} The "error" Notification representing the
     * argument.
     */
    Notification.createError = function (err) {
        return new Notification('E', undefined, err);
    };
    /**
     * A shortcut to create a Notification instance of the type `complete`.
     * @return {Notification<any>} The valueless "complete" Notification.
     */
    Notification.createComplete = function () {
        return Notification.completeNotification;
    };
    Notification.completeNotification = new Notification('C');
    Notification.undefinedValueNotification = new Notification('N', undefined);
    return Notification;
}());
exports.Notification = Notification;
//# sourceMappingURL=Notification.js.map

/***/ }),

/***/ 1529:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(466);
var map_1 = __webpack_require__(1530);
Observable_1.Observable.prototype.map = map_1.map;
//# sourceMappingURL=map.js.map

/***/ }),

/***/ 1530:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var map_1 = __webpack_require__(1531);
/**
 * Applies a given `project` function to each value emitted by the source
 * Observable, and emits the resulting values as an Observable.
 *
 * <span class="informal">Like [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map),
 * it passes each source value through a transformation function to get
 * corresponding output values.</span>
 *
 * <img src="./img/map.png" width="100%">
 *
 * Similar to the well known `Array.prototype.map` function, this operator
 * applies a projection to each value and emits that projection in the output
 * Observable.
 *
 * @example <caption>Map every click to the clientX position of that click</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var positions = clicks.map(ev => ev.clientX);
 * positions.subscribe(x => console.log(x));
 *
 * @see {@link mapTo}
 * @see {@link pluck}
 *
 * @param {function(value: T, index: number): R} project The function to apply
 * to each `value` emitted by the source Observable. The `index` parameter is
 * the number `i` for the i-th emission that has happened since the
 * subscription, starting from the number `0`.
 * @param {any} [thisArg] An optional argument to define what `this` is in the
 * `project` function.
 * @return {Observable<R>} An Observable that emits the values from the source
 * Observable transformed by the given `project` function.
 * @method map
 * @owner Observable
 */
function map(project, thisArg) {
    return map_1.map(project, thisArg)(this);
}
exports.map = map;
//# sourceMappingURL=map.js.map

/***/ }),

/***/ 1531:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(468);
/**
 * Applies a given `project` function to each value emitted by the source
 * Observable, and emits the resulting values as an Observable.
 *
 * <span class="informal">Like [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map),
 * it passes each source value through a transformation function to get
 * corresponding output values.</span>
 *
 * <img src="./img/map.png" width="100%">
 *
 * Similar to the well known `Array.prototype.map` function, this operator
 * applies a projection to each value and emits that projection in the output
 * Observable.
 *
 * @example <caption>Map every click to the clientX position of that click</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var positions = clicks.map(ev => ev.clientX);
 * positions.subscribe(x => console.log(x));
 *
 * @see {@link mapTo}
 * @see {@link pluck}
 *
 * @param {function(value: T, index: number): R} project The function to apply
 * to each `value` emitted by the source Observable. The `index` parameter is
 * the number `i` for the i-th emission that has happened since the
 * subscription, starting from the number `0`.
 * @param {any} [thisArg] An optional argument to define what `this` is in the
 * `project` function.
 * @return {Observable<R>} An Observable that emits the values from the source
 * Observable transformed by the given `project` function.
 * @method map
 * @owner Observable
 */
function map(project, thisArg) {
    return function mapOperation(source) {
        if (typeof project !== 'function') {
            throw new TypeError('argument is not a function. Are you looking for `mapTo()`?');
        }
        return source.lift(new MapOperator(project, thisArg));
    };
}
exports.map = map;
var MapOperator = (function () {
    function MapOperator(project, thisArg) {
        this.project = project;
        this.thisArg = thisArg;
    }
    MapOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new MapSubscriber(subscriber, this.project, this.thisArg));
    };
    return MapOperator;
}());
exports.MapOperator = MapOperator;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var MapSubscriber = (function (_super) {
    __extends(MapSubscriber, _super);
    function MapSubscriber(destination, project, thisArg) {
        _super.call(this, destination);
        this.project = project;
        this.count = 0;
        this.thisArg = thisArg || this;
    }
    // NOTE: This looks unoptimized, but it's actually purposefully NOT
    // using try/catch optimizations.
    MapSubscriber.prototype._next = function (value) {
        var result;
        try {
            result = this.project.call(this.thisArg, value, this.count++);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return MapSubscriber;
}(Subscriber_1.Subscriber));
//# sourceMappingURL=map.js.map

/***/ }),

/***/ 1532:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(466);
var combineAll_1 = __webpack_require__(1533);
Observable_1.Observable.prototype.combineAll = combineAll_1.combineAll;
//# sourceMappingURL=combineAll.js.map

/***/ }),

/***/ 1533:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var combineAll_1 = __webpack_require__(1534);
/**
 * Converts a higher-order Observable into a first-order Observable by waiting
 * for the outer Observable to complete, then applying {@link combineLatest}.
 *
 * <span class="informal">Flattens an Observable-of-Observables by applying
 * {@link combineLatest} when the Observable-of-Observables completes.</span>
 *
 * <img src="./img/combineAll.png" width="100%">
 *
 * Takes an Observable of Observables, and collects all Observables from it.
 * Once the outer Observable completes, it subscribes to all collected
 * Observables and combines their values using the {@link combineLatest}
 * strategy, such that:
 * - Every time an inner Observable emits, the output Observable emits.
 * - When the returned observable emits, it emits all of the latest values by:
 *   - If a `project` function is provided, it is called with each recent value
 *     from each inner Observable in whatever order they arrived, and the result
 *     of the `project` function is what is emitted by the output Observable.
 *   - If there is no `project` function, an array of all of the most recent
 *     values is emitted by the output Observable.
 *
 * @example <caption>Map two click events to a finite interval Observable, then apply combineAll</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var higherOrder = clicks.map(ev =>
 *   Rx.Observable.interval(Math.random()*2000).take(3)
 * ).take(2);
 * var result = higherOrder.combineAll();
 * result.subscribe(x => console.log(x));
 *
 * @see {@link combineLatest}
 * @see {@link mergeAll}
 *
 * @param {function} [project] An optional function to map the most recent
 * values from each inner Observable into a new result. Takes each of the most
 * recent values from each collected inner Observable as arguments, in order.
 * @return {Observable} An Observable of projected results or arrays of recent
 * values.
 * @method combineAll
 * @owner Observable
 */
function combineAll(project) {
    return combineAll_1.combineAll(project)(this);
}
exports.combineAll = combineAll;
//# sourceMappingURL=combineAll.js.map

/***/ }),

/***/ 1534:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var combineLatest_1 = __webpack_require__(1535);
function combineAll(project) {
    return function (source) { return source.lift(new combineLatest_1.CombineLatestOperator(project)); };
}
exports.combineAll = combineAll;
//# sourceMappingURL=combineAll.js.map

/***/ }),

/***/ 1535:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var ArrayObservable_1 = __webpack_require__(1345);
var isArray_1 = __webpack_require__(473);
var OuterSubscriber_1 = __webpack_require__(1536);
var subscribeToResult_1 = __webpack_require__(1537);
var none = {};
/* tslint:enable:max-line-length */
/**
 * Combines multiple Observables to create an Observable whose values are
 * calculated from the latest values of each of its input Observables.
 *
 * <span class="informal">Whenever any input Observable emits a value, it
 * computes a formula using the latest values from all the inputs, then emits
 * the output of that formula.</span>
 *
 * <img src="./img/combineLatest.png" width="100%">
 *
 * `combineLatest` combines the values from this Observable with values from
 * Observables passed as arguments. This is done by subscribing to each
 * Observable, in order, and collecting an array of each of the most recent
 * values any time any of the input Observables emits, then either taking that
 * array and passing it as arguments to an optional `project` function and
 * emitting the return value of that, or just emitting the array of recent
 * values directly if there is no `project` function.
 *
 * @example <caption>Dynamically calculate the Body-Mass Index from an Observable of weight and one for height</caption>
 * var weight = Rx.Observable.of(70, 72, 76, 79, 75);
 * var height = Rx.Observable.of(1.76, 1.77, 1.78);
 * var bmi = weight.combineLatest(height, (w, h) => w / (h * h));
 * bmi.subscribe(x => console.log('BMI is ' + x));
 *
 * // With output to console:
 * // BMI is 24.212293388429753
 * // BMI is 23.93948099205209
 * // BMI is 23.671253629592222
 *
 * @see {@link combineAll}
 * @see {@link merge}
 * @see {@link withLatestFrom}
 *
 * @param {ObservableInput} other An input Observable to combine with the source
 * Observable. More than one input Observables may be given as argument.
 * @param {function} [project] An optional function to project the values from
 * the combined latest values into a new value on the output Observable.
 * @return {Observable} An Observable of projected values from the most recent
 * values from each input Observable, or an array of the most recent values from
 * each input Observable.
 * @method combineLatest
 * @owner Observable
 */
function combineLatest() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i - 0] = arguments[_i];
    }
    var project = null;
    if (typeof observables[observables.length - 1] === 'function') {
        project = observables.pop();
    }
    // if the first and only other argument besides the resultSelector is an array
    // assume it's been called with `combineLatest([obs1, obs2, obs3], project)`
    if (observables.length === 1 && isArray_1.isArray(observables[0])) {
        observables = observables[0].slice();
    }
    return function (source) { return source.lift.call(new ArrayObservable_1.ArrayObservable([source].concat(observables)), new CombineLatestOperator(project)); };
}
exports.combineLatest = combineLatest;
var CombineLatestOperator = (function () {
    function CombineLatestOperator(project) {
        this.project = project;
    }
    CombineLatestOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new CombineLatestSubscriber(subscriber, this.project));
    };
    return CombineLatestOperator;
}());
exports.CombineLatestOperator = CombineLatestOperator;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var CombineLatestSubscriber = (function (_super) {
    __extends(CombineLatestSubscriber, _super);
    function CombineLatestSubscriber(destination, project) {
        _super.call(this, destination);
        this.project = project;
        this.active = 0;
        this.values = [];
        this.observables = [];
    }
    CombineLatestSubscriber.prototype._next = function (observable) {
        this.values.push(none);
        this.observables.push(observable);
    };
    CombineLatestSubscriber.prototype._complete = function () {
        var observables = this.observables;
        var len = observables.length;
        if (len === 0) {
            this.destination.complete();
        }
        else {
            this.active = len;
            this.toRespond = len;
            for (var i = 0; i < len; i++) {
                var observable = observables[i];
                this.add(subscribeToResult_1.subscribeToResult(this, observable, observable, i));
            }
        }
    };
    CombineLatestSubscriber.prototype.notifyComplete = function (unused) {
        if ((this.active -= 1) === 0) {
            this.destination.complete();
        }
    };
    CombineLatestSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        var values = this.values;
        var oldVal = values[outerIndex];
        var toRespond = !this.toRespond
            ? 0
            : oldVal === none ? --this.toRespond : this.toRespond;
        values[outerIndex] = innerValue;
        if (toRespond === 0) {
            if (this.project) {
                this._tryProject(values);
            }
            else {
                this.destination.next(values.slice());
            }
        }
    };
    CombineLatestSubscriber.prototype._tryProject = function (values) {
        var result;
        try {
            result = this.project.apply(this, values);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return CombineLatestSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
exports.CombineLatestSubscriber = CombineLatestSubscriber;
//# sourceMappingURL=combineLatest.js.map

/***/ }),

/***/ 1536:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(468);
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var OuterSubscriber = (function (_super) {
    __extends(OuterSubscriber, _super);
    function OuterSubscriber() {
        _super.apply(this, arguments);
    }
    OuterSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.destination.next(innerValue);
    };
    OuterSubscriber.prototype.notifyError = function (error, innerSub) {
        this.destination.error(error);
    };
    OuterSubscriber.prototype.notifyComplete = function (innerSub) {
        this.destination.complete();
    };
    return OuterSubscriber;
}(Subscriber_1.Subscriber));
exports.OuterSubscriber = OuterSubscriber;
//# sourceMappingURL=OuterSubscriber.js.map

/***/ }),

/***/ 1537:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var root_1 = __webpack_require__(127);
var isArrayLike_1 = __webpack_require__(1343);
var isPromise_1 = __webpack_require__(1344);
var isObject_1 = __webpack_require__(476);
var Observable_1 = __webpack_require__(466);
var iterator_1 = __webpack_require__(1320);
var InnerSubscriber_1 = __webpack_require__(1538);
var observable_1 = __webpack_require__(474);
function subscribeToResult(outerSubscriber, result, outerValue, outerIndex) {
    var destination = new InnerSubscriber_1.InnerSubscriber(outerSubscriber, outerValue, outerIndex);
    if (destination.closed) {
        return null;
    }
    if (result instanceof Observable_1.Observable) {
        if (result._isScalar) {
            destination.next(result.value);
            destination.complete();
            return null;
        }
        else {
            destination.syncErrorThrowable = true;
            return result.subscribe(destination);
        }
    }
    else if (isArrayLike_1.isArrayLike(result)) {
        for (var i = 0, len = result.length; i < len && !destination.closed; i++) {
            destination.next(result[i]);
        }
        if (!destination.closed) {
            destination.complete();
        }
    }
    else if (isPromise_1.isPromise(result)) {
        result.then(function (value) {
            if (!destination.closed) {
                destination.next(value);
                destination.complete();
            }
        }, function (err) { return destination.error(err); })
            .then(null, function (err) {
            // Escaping the Promise trap: globally throw unhandled errors
            root_1.root.setTimeout(function () { throw err; });
        });
        return destination;
    }
    else if (result && typeof result[iterator_1.iterator] === 'function') {
        var iterator = result[iterator_1.iterator]();
        do {
            var item = iterator.next();
            if (item.done) {
                destination.complete();
                break;
            }
            destination.next(item.value);
            if (destination.closed) {
                break;
            }
        } while (true);
    }
    else if (result && typeof result[observable_1.observable] === 'function') {
        var obs = result[observable_1.observable]();
        if (typeof obs.subscribe !== 'function') {
            destination.error(new TypeError('Provided object does not correctly implement Symbol.observable'));
        }
        else {
            return obs.subscribe(new InnerSubscriber_1.InnerSubscriber(outerSubscriber, outerValue, outerIndex));
        }
    }
    else {
        var value = isObject_1.isObject(result) ? 'an invalid object' : "'" + result + "'";
        var msg = ("You provided " + value + " where a stream was expected.")
            + ' You can provide an Observable, Promise, Array, or Iterable.';
        destination.error(new TypeError(msg));
    }
    return null;
}
exports.subscribeToResult = subscribeToResult;
//# sourceMappingURL=subscribeToResult.js.map

/***/ }),

/***/ 1538:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(468);
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var InnerSubscriber = (function (_super) {
    __extends(InnerSubscriber, _super);
    function InnerSubscriber(parent, outerValue, outerIndex) {
        _super.call(this);
        this.parent = parent;
        this.outerValue = outerValue;
        this.outerIndex = outerIndex;
        this.index = 0;
    }
    InnerSubscriber.prototype._next = function (value) {
        this.parent.notifyNext(this.outerValue, value, this.outerIndex, this.index++, this);
    };
    InnerSubscriber.prototype._error = function (error) {
        this.parent.notifyError(error, this);
        this.unsubscribe();
    };
    InnerSubscriber.prototype._complete = function () {
        this.parent.notifyComplete(this);
        this.unsubscribe();
    };
    return InnerSubscriber;
}(Subscriber_1.Subscriber));
exports.InnerSubscriber = InnerSubscriber;
//# sourceMappingURL=InnerSubscriber.js.map

/***/ }),

/***/ 1539:
/***/ (function(module, exports) {

/* Flot plugin for rendering pie charts.

Copyright (c) 2007-2013 IOLA and Ole Laursen.
Licensed under the MIT license.

The plugin assumes that each series has a single data value, and that each
value is a positive integer or zero.  Negative numbers don't make sense for a
pie chart, and have unpredictable results.  The values do NOT need to be
passed in as percentages; the plugin will calculate the total and per-slice
percentages internally.

* Created by Brian Medendorp

* Updated with contributions from btburnett3, Anthony Aragues and Xavi Ivars

The plugin supports these options:

	series: {
		pie: {
			show: true/false
			radius: 0-1 for percentage of fullsize, or a specified pixel length, or 'auto'
			innerRadius: 0-1 for percentage of fullsize or a specified pixel length, for creating a donut effect
			startAngle: 0-2 factor of PI used for starting angle (in radians) i.e 3/2 starts at the top, 0 and 2 have the same result
			tilt: 0-1 for percentage to tilt the pie, where 1 is no tilt, and 0 is completely flat (nothing will show)
			offset: {
				top: integer value to move the pie up or down
				left: integer value to move the pie left or right, or 'auto'
			},
			stroke: {
				color: any hexidecimal color value (other formats may or may not work, so best to stick with something like '#FFF')
				width: integer pixel width of the stroke
			},
			label: {
				show: true/false, or 'auto'
				formatter:  a user-defined function that modifies the text/style of the label text
				radius: 0-1 for percentage of fullsize, or a specified pixel length
				background: {
					color: any hexidecimal color value (other formats may or may not work, so best to stick with something like '#000')
					opacity: 0-1
				},
				threshold: 0-1 for the percentage value at which to hide labels (if they're too small)
			},
			combine: {
				threshold: 0-1 for the percentage value at which to combine slices (if they're too small)
				color: any hexidecimal color value (other formats may or may not work, so best to stick with something like '#CCC'), if null, the plugin will automatically use the color of the first slice to be combined
				label: any text value of what the combined slice should be labeled
			}
			highlight: {
				opacity: 0-1
			}
		}
	}

More detail and specific examples can be found in the included HTML file.

*/

(function($) {

	// Maximum redraw attempts when fitting labels within the plot

	var REDRAW_ATTEMPTS = 10;

	// Factor by which to shrink the pie when fitting labels within the plot

	var REDRAW_SHRINK = 0.95;

	function init(plot) {

		var canvas = null,
			target = null,
			maxRadius = null,
			centerLeft = null,
			centerTop = null,
			processed = false,
			ctx = null;

		// interactive variables

		var highlights = [];

		// add hook to determine if pie plugin in enabled, and then perform necessary operations

		plot.hooks.processOptions.push(function(plot, options) {
			if (options.series.pie.show) {

				options.grid.show = false;

				// set labels.show

				if (options.series.pie.label.show == "auto") {
					if (options.legend.show) {
						options.series.pie.label.show = false;
					} else {
						options.series.pie.label.show = true;
					}
				}

				// set radius

				if (options.series.pie.radius == "auto") {
					if (options.series.pie.label.show) {
						options.series.pie.radius = 3/4;
					} else {
						options.series.pie.radius = 1;
					}
				}

				// ensure sane tilt

				if (options.series.pie.tilt > 1) {
					options.series.pie.tilt = 1;
				} else if (options.series.pie.tilt < 0) {
					options.series.pie.tilt = 0;
				}
			}
		});

		plot.hooks.bindEvents.push(function(plot, eventHolder) {
			var options = plot.getOptions();
			if (options.series.pie.show) {
				if (options.grid.hoverable) {
					eventHolder.unbind("mousemove").mousemove(onMouseMove);
				}
				if (options.grid.clickable) {
					eventHolder.unbind("click").click(onClick);
				}
			}
		});

		plot.hooks.processDatapoints.push(function(plot, series, data, datapoints) {
			var options = plot.getOptions();
			if (options.series.pie.show) {
				processDatapoints(plot, series, data, datapoints);
			}
		});

		plot.hooks.drawOverlay.push(function(plot, octx) {
			var options = plot.getOptions();
			if (options.series.pie.show) {
				drawOverlay(plot, octx);
			}
		});

		plot.hooks.draw.push(function(plot, newCtx) {
			var options = plot.getOptions();
			if (options.series.pie.show) {
				draw(plot, newCtx);
			}
		});

		function processDatapoints(plot, series, datapoints) {
			if (!processed)	{
				processed = true;
				canvas = plot.getCanvas();
				target = $(canvas).parent();
				options = plot.getOptions();
				plot.setData(combine(plot.getData()));
			}
		}

		function combine(data) {

			var total = 0,
				combined = 0,
				numCombined = 0,
				color = options.series.pie.combine.color,
				newdata = [];

			// Fix up the raw data from Flot, ensuring the data is numeric

			for (var i = 0; i < data.length; ++i) {

				var value = data[i].data;

				// If the data is an array, we'll assume that it's a standard
				// Flot x-y pair, and are concerned only with the second value.

				// Note how we use the original array, rather than creating a
				// new one; this is more efficient and preserves any extra data
				// that the user may have stored in higher indexes.

				if ($.isArray(value) && value.length == 1) {
    				value = value[0];
				}

				if ($.isArray(value)) {
					// Equivalent to $.isNumeric() but compatible with jQuery < 1.7
					if (!isNaN(parseFloat(value[1])) && isFinite(value[1])) {
						value[1] = +value[1];
					} else {
						value[1] = 0;
					}
				} else if (!isNaN(parseFloat(value)) && isFinite(value)) {
					value = [1, +value];
				} else {
					value = [1, 0];
				}

				data[i].data = [value];
			}

			// Sum up all the slices, so we can calculate percentages for each

			for (var i = 0; i < data.length; ++i) {
				total += data[i].data[0][1];
			}

			// Count the number of slices with percentages below the combine
			// threshold; if it turns out to be just one, we won't combine.

			for (var i = 0; i < data.length; ++i) {
				var value = data[i].data[0][1];
				if (value / total <= options.series.pie.combine.threshold) {
					combined += value;
					numCombined++;
					if (!color) {
						color = data[i].color;
					}
				}
			}

			for (var i = 0; i < data.length; ++i) {
				var value = data[i].data[0][1];
				if (numCombined < 2 || value / total > options.series.pie.combine.threshold) {
					newdata.push({
						data: [[1, value]],
						color: data[i].color,
						label: data[i].label,
						angle: value * Math.PI * 2 / total,
						percent: value / (total / 100)
					});
				}
			}

			if (numCombined > 1) {
				newdata.push({
					data: [[1, combined]],
					color: color,
					label: options.series.pie.combine.label,
					angle: combined * Math.PI * 2 / total,
					percent: combined / (total / 100)
				});
			}

			return newdata;
		}

		function draw(plot, newCtx) {

			if (!target) {
				return; // if no series were passed
			}

			var canvasWidth = plot.getPlaceholder().width(),
				canvasHeight = plot.getPlaceholder().height(),
				legendWidth = target.children().filter(".legend").children().width() || 0;

			ctx = newCtx;

			// WARNING: HACK! REWRITE THIS CODE AS SOON AS POSSIBLE!

			// When combining smaller slices into an 'other' slice, we need to
			// add a new series.  Since Flot gives plugins no way to modify the
			// list of series, the pie plugin uses a hack where the first call
			// to processDatapoints results in a call to setData with the new
			// list of series, then subsequent processDatapoints do nothing.

			// The plugin-global 'processed' flag is used to control this hack;
			// it starts out false, and is set to true after the first call to
			// processDatapoints.

			// Unfortunately this turns future setData calls into no-ops; they
			// call processDatapoints, the flag is true, and nothing happens.

			// To fix this we'll set the flag back to false here in draw, when
			// all series have been processed, so the next sequence of calls to
			// processDatapoints once again starts out with a slice-combine.
			// This is really a hack; in 0.9 we need to give plugins a proper
			// way to modify series before any processing begins.

			processed = false;

			// calculate maximum radius and center point

			maxRadius =  Math.min(canvasWidth, canvasHeight / options.series.pie.tilt) / 2;
			centerTop = canvasHeight / 2 + options.series.pie.offset.top;
			centerLeft = canvasWidth / 2;

			if (options.series.pie.offset.left == "auto") {
				if (options.legend.position.match("w")) {
					centerLeft += legendWidth / 2;
				} else {
					centerLeft -= legendWidth / 2;
				}
			} else {
				centerLeft += options.series.pie.offset.left;
			}

			if (centerLeft < maxRadius) {
				centerLeft = maxRadius;
			} else if (centerLeft > canvasWidth - maxRadius) {
				centerLeft = canvasWidth - maxRadius;
			}

			var slices = plot.getData(),
				attempts = 0;

			// Keep shrinking the pie's radius until drawPie returns true,
			// indicating that all the labels fit, or we try too many times.

			do {
				if (attempts > 0) {
					maxRadius *= REDRAW_SHRINK;
				}
				attempts += 1;
				clear();
				if (options.series.pie.tilt <= 0.8) {
					drawShadow();
				}
			} while (!drawPie() && attempts < REDRAW_ATTEMPTS)

			if (attempts >= REDRAW_ATTEMPTS) {
				clear();
				target.prepend("<div class='error'>Could not draw pie with labels contained inside canvas</div>");
			}

			if (plot.setSeries && plot.insertLegend) {
				plot.setSeries(slices);
				plot.insertLegend();
			}

			// we're actually done at this point, just defining internal functions at this point

			function clear() {
				ctx.clearRect(0, 0, canvasWidth, canvasHeight);
				target.children().filter(".pieLabel, .pieLabelBackground").remove();
			}

			function drawShadow() {

				var shadowLeft = options.series.pie.shadow.left;
				var shadowTop = options.series.pie.shadow.top;
				var edge = 10;
				var alpha = options.series.pie.shadow.alpha;
				var radius = options.series.pie.radius > 1 ? options.series.pie.radius : maxRadius * options.series.pie.radius;

				if (radius >= canvasWidth / 2 - shadowLeft || radius * options.series.pie.tilt >= canvasHeight / 2 - shadowTop || radius <= edge) {
					return;	// shadow would be outside canvas, so don't draw it
				}

				ctx.save();
				ctx.translate(shadowLeft,shadowTop);
				ctx.globalAlpha = alpha;
				ctx.fillStyle = "#000";

				// center and rotate to starting position

				ctx.translate(centerLeft,centerTop);
				ctx.scale(1, options.series.pie.tilt);

				//radius -= edge;

				for (var i = 1; i <= edge; i++) {
					ctx.beginPath();
					ctx.arc(0, 0, radius, 0, Math.PI * 2, false);
					ctx.fill();
					radius -= i;
				}

				ctx.restore();
			}

			function drawPie() {

				var startAngle = Math.PI * options.series.pie.startAngle;
				var radius = options.series.pie.radius > 1 ? options.series.pie.radius : maxRadius * options.series.pie.radius;

				// center and rotate to starting position

				ctx.save();
				ctx.translate(centerLeft,centerTop);
				ctx.scale(1, options.series.pie.tilt);
				//ctx.rotate(startAngle); // start at top; -- This doesn't work properly in Opera

				// draw slices

				ctx.save();
				var currentAngle = startAngle;
				for (var i = 0; i < slices.length; ++i) {
					slices[i].startAngle = currentAngle;
					drawSlice(slices[i].angle, slices[i].color, true);
				}
				ctx.restore();

				// draw slice outlines

				if (options.series.pie.stroke.width > 0) {
					ctx.save();
					ctx.lineWidth = options.series.pie.stroke.width;
					currentAngle = startAngle;
					for (var i = 0; i < slices.length; ++i) {
						drawSlice(slices[i].angle, options.series.pie.stroke.color, false);
					}
					ctx.restore();
				}

				// draw donut hole

				drawDonutHole(ctx);

				ctx.restore();

				// Draw the labels, returning true if they fit within the plot

				if (options.series.pie.label.show) {
					return drawLabels();
				} else return true;

				function drawSlice(angle, color, fill) {

					if (angle <= 0 || isNaN(angle)) {
						return;
					}

					if (fill) {
						ctx.fillStyle = color;
					} else {
						ctx.strokeStyle = color;
						ctx.lineJoin = "round";
					}

					ctx.beginPath();
					if (Math.abs(angle - Math.PI * 2) > 0.000000001) {
						ctx.moveTo(0, 0); // Center of the pie
					}

					//ctx.arc(0, 0, radius, 0, angle, false); // This doesn't work properly in Opera
					ctx.arc(0, 0, radius,currentAngle, currentAngle + angle / 2, false);
					ctx.arc(0, 0, radius,currentAngle + angle / 2, currentAngle + angle, false);
					ctx.closePath();
					//ctx.rotate(angle); // This doesn't work properly in Opera
					currentAngle += angle;

					if (fill) {
						ctx.fill();
					} else {
						ctx.stroke();
					}
				}

				function drawLabels() {

					var currentAngle = startAngle;
					var radius = options.series.pie.label.radius > 1 ? options.series.pie.label.radius : maxRadius * options.series.pie.label.radius;

					for (var i = 0; i < slices.length; ++i) {
						if (slices[i].percent >= options.series.pie.label.threshold * 100) {
							if (!drawLabel(slices[i], currentAngle, i)) {
								return false;
							}
						}
						currentAngle += slices[i].angle;
					}

					return true;

					function drawLabel(slice, startAngle, index) {

						if (slice.data[0][1] == 0) {
							return true;
						}

						// format label text

						var lf = options.legend.labelFormatter, text, plf = options.series.pie.label.formatter;

						if (lf) {
							text = lf(slice.label, slice);
						} else {
							text = slice.label;
						}

						if (plf) {
							text = plf(text, slice);
						}

						var halfAngle = ((startAngle + slice.angle) + startAngle) / 2;
						var x = centerLeft + Math.round(Math.cos(halfAngle) * radius);
						var y = centerTop + Math.round(Math.sin(halfAngle) * radius) * options.series.pie.tilt;

						var html = "<span class='pieLabel' id='pieLabel" + index + "' style='position:absolute;top:" + y + "px;left:" + x + "px;'>" + text + "</span>";
						target.append(html);

						var label = target.children("#pieLabel" + index);
						var labelTop = (y - label.height() / 2);
						var labelLeft = (x - label.width() / 2);

						label.css("top", labelTop);
						label.css("left", labelLeft);

						// check to make sure that the label is not outside the canvas

						if (0 - labelTop > 0 || 0 - labelLeft > 0 || canvasHeight - (labelTop + label.height()) < 0 || canvasWidth - (labelLeft + label.width()) < 0) {
							return false;
						}

						if (options.series.pie.label.background.opacity != 0) {

							// put in the transparent background separately to avoid blended labels and label boxes

							var c = options.series.pie.label.background.color;

							if (c == null) {
								c = slice.color;
							}

							var pos = "top:" + labelTop + "px;left:" + labelLeft + "px;";
							$("<div class='pieLabelBackground' style='position:absolute;width:" + label.width() + "px;height:" + label.height() + "px;" + pos + "background-color:" + c + ";'></div>")
								.css("opacity", options.series.pie.label.background.opacity)
								.insertBefore(label);
						}

						return true;
					} // end individual label function
				} // end drawLabels function
			} // end drawPie function
		} // end draw function

		// Placed here because it needs to be accessed from multiple locations

		function drawDonutHole(layer) {
			if (options.series.pie.innerRadius > 0) {

				// subtract the center

				layer.save();
				var innerRadius = options.series.pie.innerRadius > 1 ? options.series.pie.innerRadius : maxRadius * options.series.pie.innerRadius;
				layer.globalCompositeOperation = "destination-out"; // this does not work with excanvas, but it will fall back to using the stroke color
				layer.beginPath();
				layer.fillStyle = options.series.pie.stroke.color;
				layer.arc(0, 0, innerRadius, 0, Math.PI * 2, false);
				layer.fill();
				layer.closePath();
				layer.restore();

				// add inner stroke

				layer.save();
				layer.beginPath();
				layer.strokeStyle = options.series.pie.stroke.color;
				layer.arc(0, 0, innerRadius, 0, Math.PI * 2, false);
				layer.stroke();
				layer.closePath();
				layer.restore();

				// TODO: add extra shadow inside hole (with a mask) if the pie is tilted.
			}
		}

		//-- Additional Interactive related functions --

		function isPointInPoly(poly, pt) {
			for(var c = false, i = -1, l = poly.length, j = l - 1; ++i < l; j = i)
				((poly[i][1] <= pt[1] && pt[1] < poly[j][1]) || (poly[j][1] <= pt[1] && pt[1]< poly[i][1]))
				&& (pt[0] < (poly[j][0] - poly[i][0]) * (pt[1] - poly[i][1]) / (poly[j][1] - poly[i][1]) + poly[i][0])
				&& (c = !c);
			return c;
		}

		function findNearbySlice(mouseX, mouseY) {

			var slices = plot.getData(),
				options = plot.getOptions(),
				radius = options.series.pie.radius > 1 ? options.series.pie.radius : maxRadius * options.series.pie.radius,
				x, y;

			for (var i = 0; i < slices.length; ++i) {

				var s = slices[i];

				if (s.pie.show) {

					ctx.save();
					ctx.beginPath();
					ctx.moveTo(0, 0); // Center of the pie
					//ctx.scale(1, options.series.pie.tilt);	// this actually seems to break everything when here.
					ctx.arc(0, 0, radius, s.startAngle, s.startAngle + s.angle / 2, false);
					ctx.arc(0, 0, radius, s.startAngle + s.angle / 2, s.startAngle + s.angle, false);
					ctx.closePath();
					x = mouseX - centerLeft;
					y = mouseY - centerTop;

					if (ctx.isPointInPath) {
						if (ctx.isPointInPath(mouseX - centerLeft, mouseY - centerTop)) {
							ctx.restore();
							return {
								datapoint: [s.percent, s.data],
								dataIndex: 0,
								series: s,
								seriesIndex: i
							};
						}
					} else {

						// excanvas for IE doesn;t support isPointInPath, this is a workaround.

						var p1X = radius * Math.cos(s.startAngle),
							p1Y = radius * Math.sin(s.startAngle),
							p2X = radius * Math.cos(s.startAngle + s.angle / 4),
							p2Y = radius * Math.sin(s.startAngle + s.angle / 4),
							p3X = radius * Math.cos(s.startAngle + s.angle / 2),
							p3Y = radius * Math.sin(s.startAngle + s.angle / 2),
							p4X = radius * Math.cos(s.startAngle + s.angle / 1.5),
							p4Y = radius * Math.sin(s.startAngle + s.angle / 1.5),
							p5X = radius * Math.cos(s.startAngle + s.angle),
							p5Y = radius * Math.sin(s.startAngle + s.angle),
							arrPoly = [[0, 0], [p1X, p1Y], [p2X, p2Y], [p3X, p3Y], [p4X, p4Y], [p5X, p5Y]],
							arrPoint = [x, y];

						// TODO: perhaps do some mathmatical trickery here with the Y-coordinate to compensate for pie tilt?

						if (isPointInPoly(arrPoly, arrPoint)) {
							ctx.restore();
							return {
								datapoint: [s.percent, s.data],
								dataIndex: 0,
								series: s,
								seriesIndex: i
							};
						}
					}

					ctx.restore();
				}
			}

			return null;
		}

		function onMouseMove(e) {
			triggerClickHoverEvent("plothover", e);
		}

		function onClick(e) {
			triggerClickHoverEvent("plotclick", e);
		}

		// trigger click or hover event (they send the same parameters so we share their code)

		function triggerClickHoverEvent(eventname, e) {

			var offset = plot.offset();
			var canvasX = parseInt(e.pageX - offset.left);
			var canvasY =  parseInt(e.pageY - offset.top);
			var item = findNearbySlice(canvasX, canvasY);

			if (options.grid.autoHighlight) {

				// clear auto-highlights

				for (var i = 0; i < highlights.length; ++i) {
					var h = highlights[i];
					if (h.auto == eventname && !(item && h.series == item.series)) {
						unhighlight(h.series);
					}
				}
			}

			// highlight the slice

			if (item) {
				highlight(item.series, eventname);
			}

			// trigger any hover bind events

			var pos = { pageX: e.pageX, pageY: e.pageY };
			target.trigger(eventname, [pos, item]);
		}

		function highlight(s, auto) {
			//if (typeof s == "number") {
			//	s = series[s];
			//}

			var i = indexOfHighlight(s);

			if (i == -1) {
				highlights.push({ series: s, auto: auto });
				plot.triggerRedrawOverlay();
			} else if (!auto) {
				highlights[i].auto = false;
			}
		}

		function unhighlight(s) {
			if (s == null) {
				highlights = [];
				plot.triggerRedrawOverlay();
			}

			//if (typeof s == "number") {
			//	s = series[s];
			//}

			var i = indexOfHighlight(s);

			if (i != -1) {
				highlights.splice(i, 1);
				plot.triggerRedrawOverlay();
			}
		}

		function indexOfHighlight(s) {
			for (var i = 0; i < highlights.length; ++i) {
				var h = highlights[i];
				if (h.series == s)
					return i;
			}
			return -1;
		}

		function drawOverlay(plot, octx) {

			var options = plot.getOptions();

			var radius = options.series.pie.radius > 1 ? options.series.pie.radius : maxRadius * options.series.pie.radius;

			octx.save();
			octx.translate(centerLeft, centerTop);
			octx.scale(1, options.series.pie.tilt);

			for (var i = 0; i < highlights.length; ++i) {
				drawHighlight(highlights[i].series);
			}

			drawDonutHole(octx);

			octx.restore();

			function drawHighlight(series) {

				if (series.angle <= 0 || isNaN(series.angle)) {
					return;
				}

				//octx.fillStyle = parseColor(options.series.pie.highlight.color).scale(null, null, null, options.series.pie.highlight.opacity).toString();
				octx.fillStyle = "rgba(255, 255, 255, " + options.series.pie.highlight.opacity + ")"; // this is temporary until we have access to parseColor
				octx.beginPath();
				if (Math.abs(series.angle - Math.PI * 2) > 0.000000001) {
					octx.moveTo(0, 0); // Center of the pie
				}
				octx.arc(0, 0, radius, series.startAngle, series.startAngle + series.angle / 2, false);
				octx.arc(0, 0, radius, series.startAngle + series.angle / 2, series.startAngle + series.angle, false);
				octx.closePath();
				octx.fill();
			}
		}
	} // end init (plugin body)

	// define pie specific options and their default values

	var options = {
		series: {
			pie: {
				show: false,
				radius: "auto",	// actual radius of the visible pie (based on full calculated radius if <=1, or hard pixel value)
				innerRadius: 0, /* for donut */
				startAngle: 3/2,
				tilt: 1,
				shadow: {
					left: 5,	// shadow left offset
					top: 15,	// shadow top offset
					alpha: 0.02	// shadow alpha
				},
				offset: {
					top: 0,
					left: "auto"
				},
				stroke: {
					color: "#fff",
					width: 1
				},
				label: {
					show: "auto",
					formatter: function(label, slice) {
						return "<div style='font-size:x-small;text-align:center;padding:2px;color:" + slice.color + ";'>" + label + "<br/>" + Math.round(slice.percent) + "%</div>";
					},	// formatter function
					radius: 1,	// radius at which to place the labels (based on full calculated radius if <=1, or hard pixel value)
					background: {
						color: null,
						opacity: 0
					},
					threshold: 0	// percentage at which to hide the label (i.e. the slice is too narrow)
				},
				combine: {
					threshold: -1,	// percentage at which to combine little slices into one larger slice
					color: null,	// color to give the new slice (auto-generated if null)
					label: "Other"	// label to give the new slice
				},
				highlight: {
					//color: "#fff",		// will add this functionality once parseColor is available
					opacity: 0.5
				}
			}
		}
	};

	$.plot.plugins.push({
		init: init,
		options: options,
		name: "pie",
		version: "1.1"
	});

})(jQuery);


/***/ }),

/***/ 1540:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ 
pluginDirectiveLoader.$inject = ["$compile", "datasourceSrv", "$rootScope", "$q", "$http", "$templateCache"];var __WEBPACK_IMPORTED_MODULE_0_angular__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_angular___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_angular__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_lodash__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_app_core_config__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_app_core_core_module__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__plugin_loader__ = __webpack_require__(1316);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_app_plugins_panel_unknown_module__ = __webpack_require__(1541);






/** @ngInject **/
function pluginDirectiveLoader($compile, datasourceSrv, $rootScope, $q, $http, $templateCache) {
    function getTemplate(component) {
        if (component.template) {
            return $q.when(component.template);
        }
        var cached = $templateCache.get(component.templateUrl);
        if (cached) {
            return $q.when(cached);
        }
        return $http.get(component.templateUrl).then(function (res) {
            return res.data;
        });
    }
    function relativeTemplateUrlToAbs(templateUrl, baseUrl) {
        if (!templateUrl) {
            return undefined;
        }
        if (templateUrl.indexOf('public') === 0) {
            return templateUrl;
        }
        return baseUrl + '/' + templateUrl;
    }
    function getPluginComponentDirective(options) {
        // handle relative template urls for plugin templates
        options.Component.templateUrl = relativeTemplateUrlToAbs(options.Component.templateUrl, options.baseUrl);
        return function () {
            return {
                templateUrl: options.Component.templateUrl,
                template: options.Component.template,
                restrict: 'E',
                controller: options.Component,
                controllerAs: 'ctrl',
                bindToController: true,
                scope: options.bindings,
                link: function (scope, elem, attrs, ctrl) {
                    if (ctrl.link) {
                        ctrl.link(scope, elem, attrs, ctrl);
                    }
                    if (ctrl.init) {
                        ctrl.init();
                    }
                }
            };
        };
    }
    function loadPanelComponentInfo(scope, attrs) {
        var componentInfo = {
            name: 'panel-plugin-' + scope.panel.type,
            bindings: { dashboard: "=", panel: "=", row: "=" },
            attrs: { dashboard: "ctrl.dashboard", panel: "panel", row: "ctrl.row" },
        };
        var panelInfo = __WEBPACK_IMPORTED_MODULE_2_app_core_config__["default"].panels[scope.panel.type];
        var panelCtrlPromise = Promise.resolve(__WEBPACK_IMPORTED_MODULE_5_app_plugins_panel_unknown_module__["a" /* UnknownPanelCtrl */]);
        if (panelInfo) {
            panelCtrlPromise = Object(__WEBPACK_IMPORTED_MODULE_4__plugin_loader__["importPluginModule"])(panelInfo.module).then(function (panelModule) {
                return panelModule.PanelCtrl;
            });
        }
        return panelCtrlPromise.then(function (PanelCtrl) {
            componentInfo.Component = PanelCtrl;
            if (!PanelCtrl || PanelCtrl.registered) {
                return componentInfo;
            }
            if (PanelCtrl.templatePromise) {
                return PanelCtrl.templatePromise.then(function (res) {
                    return componentInfo;
                });
            }
            if (panelInfo) {
                PanelCtrl.templateUrl = relativeTemplateUrlToAbs(PanelCtrl.templateUrl, panelInfo.baseUrl);
            }
            PanelCtrl.templatePromise = getTemplate(PanelCtrl).then(function (template) {
                PanelCtrl.templateUrl = null;
                PanelCtrl.template = "<grafana-panel ctrl=\"ctrl\">" + template + "</grafana-panel>";
                return componentInfo;
            });
            return PanelCtrl.templatePromise;
        });
    }
    function getModule(scope, attrs) {
        switch (attrs.type) {
            // QueryCtrl
            case "query-ctrl": {
                var datasource = scope.target.datasource || scope.ctrl.panel.datasource;
                return datasourceSrv.get(datasource).then(function (ds) {
                    scope.datasource = ds;
                    return Object(__WEBPACK_IMPORTED_MODULE_4__plugin_loader__["importPluginModule"])(ds.meta.module).then(function (dsModule) {
                        return {
                            baseUrl: ds.meta.baseUrl,
                            name: 'query-ctrl-' + ds.meta.id,
                            bindings: { target: "=", panelCtrl: "=", datasource: "=" },
                            attrs: { "target": "target", "panel-ctrl": "ctrl.panelCtrl", datasource: "datasource" },
                            Component: dsModule.QueryCtrl
                        };
                    });
                });
            }
            // QueryOptionsCtrl
            case "query-options-ctrl": {
                return datasourceSrv.get(scope.ctrl.panel.datasource).then(function (ds) {
                    return Object(__WEBPACK_IMPORTED_MODULE_4__plugin_loader__["importPluginModule"])(ds.meta.module).then(function (dsModule) {
                        if (!dsModule.QueryOptionsCtrl) {
                            return { notFound: true };
                        }
                        return {
                            baseUrl: ds.meta.baseUrl,
                            name: 'query-options-ctrl-' + ds.meta.id,
                            bindings: { panelCtrl: "=" },
                            attrs: { "panel-ctrl": "ctrl.panelCtrl" },
                            Component: dsModule.QueryOptionsCtrl
                        };
                    });
                });
            }
            // Annotations
            case "annotations-query-ctrl": {
                return Object(__WEBPACK_IMPORTED_MODULE_4__plugin_loader__["importPluginModule"])(scope.ctrl.currentDatasource.meta.module).then(function (dsModule) {
                    return {
                        baseUrl: scope.ctrl.currentDatasource.meta.baseUrl,
                        name: 'annotations-query-ctrl-' + scope.ctrl.currentDatasource.meta.id,
                        bindings: { annotation: "=", datasource: "=" },
                        attrs: { "annotation": "ctrl.currentAnnotation", datasource: "ctrl.currentDatasource" },
                        Component: dsModule.AnnotationsQueryCtrl,
                    };
                });
            }
            // Datasource ConfigCtrl
            case 'datasource-config-ctrl': {
                var dsMeta = scope.ctrl.datasourceMeta;
                return Object(__WEBPACK_IMPORTED_MODULE_4__plugin_loader__["importPluginModule"])(dsMeta.module).then(function (dsModule) {
                    if (!dsModule.ConfigCtrl) {
                        return { notFound: true };
                    }
                    return {
                        baseUrl: dsMeta.baseUrl,
                        name: 'ds-config-' + dsMeta.id,
                        bindings: { meta: "=", current: "=" },
                        attrs: { meta: "ctrl.datasourceMeta", current: "ctrl.current" },
                        Component: dsModule.ConfigCtrl,
                    };
                });
            }
            // AppConfigCtrl
            case 'app-config-ctrl': {
                var model_1 = scope.ctrl.model;
                return Object(__WEBPACK_IMPORTED_MODULE_4__plugin_loader__["importPluginModule"])(model_1.module).then(function (appModule) {
                    return {
                        baseUrl: model_1.baseUrl,
                        name: 'app-config-' + model_1.id,
                        bindings: { appModel: "=", appEditCtrl: "=" },
                        attrs: { "app-model": "ctrl.model", "app-edit-ctrl": "ctrl" },
                        Component: appModule.ConfigCtrl,
                    };
                });
            }
            // App Page
            case 'app-page': {
                var appModel_1 = scope.ctrl.appModel;
                return Object(__WEBPACK_IMPORTED_MODULE_4__plugin_loader__["importPluginModule"])(appModel_1.module).then(function (appModule) {
                    return {
                        baseUrl: appModel_1.baseUrl,
                        name: 'app-page-' + appModel_1.id + '-' + scope.ctrl.page.slug,
                        bindings: { appModel: "=" },
                        attrs: { "app-model": "ctrl.appModel" },
                        Component: appModule[scope.ctrl.page.component],
                    };
                });
            }
            // Panel
            case 'panel': {
                return loadPanelComponentInfo(scope, attrs);
            }
            default: {
                return $q.reject({ message: "Could not find component type: " + attrs.type });
            }
        }
    }
    function appendAndCompile(scope, elem, componentInfo) {
        var child = __WEBPACK_IMPORTED_MODULE_0_angular___default.a.element(document.createElement(componentInfo.name));
        __WEBPACK_IMPORTED_MODULE_1_lodash___default.a.each(componentInfo.attrs, function (value, key) {
            child.attr(key, value);
        });
        $compile(child)(scope);
        elem.empty();
        // let a binding digest cycle complete before adding to dom
        setTimeout(function () {
            elem.append(child);
            scope.$applyAsync(function () {
                scope.$broadcast('refresh');
            });
        });
    }
    function registerPluginComponent(scope, elem, attrs, componentInfo) {
        if (componentInfo.notFound) {
            elem.empty();
            return;
        }
        if (!componentInfo.Component) {
            throw { message: 'Failed to find exported plugin component for ' + componentInfo.name };
        }
        if (!componentInfo.Component.registered) {
            var directiveName = attrs.$normalize(componentInfo.name);
            var directiveFn = getPluginComponentDirective(componentInfo);
            __WEBPACK_IMPORTED_MODULE_3_app_core_core_module__["default"].directive(directiveName, directiveFn);
            componentInfo.Component.registered = true;
        }
        appendAndCompile(scope, elem, componentInfo);
    }
    return {
        restrict: 'E',
        link: function (scope, elem, attrs) {
            getModule(scope, attrs).then(function (componentInfo) {
                registerPluginComponent(scope, elem, attrs, componentInfo);
            }).catch(function (err) {
                $rootScope.appEvent('alert-error', ['Plugin Error', err.message || err]);
                console.log('Plugin component error', err);
            });
        }
    };
}
__WEBPACK_IMPORTED_MODULE_3_app_core_core_module__["default"].directive('pluginComponent', pluginDirectiveLoader);


/***/ }),

/***/ 1541:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return UnknownPanelCtrl; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_app_features_panel_panel_ctrl__ = __webpack_require__(1313);
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();

var UnknownPanelCtrl = /** @class */ (function (_super) {
    __extends(UnknownPanelCtrl, _super);
    /** @ngInject */
    UnknownPanelCtrl.$inject = ["$scope", "$injector"];
    function UnknownPanelCtrl($scope, $injector) {
        return _super.call(this, $scope, $injector) || this;
    }
    UnknownPanelCtrl.templateUrl = 'public/app/plugins/panel/unknown/module.html';
    return UnknownPanelCtrl;
}(__WEBPACK_IMPORTED_MODULE_0_app_features_panel_panel_ctrl__["a" /* PanelCtrl */]));



/***/ }),

/***/ 1542:
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
  __webpack_require__(12),
  __webpack_require__(7),
], __WEBPACK_AMD_DEFINE_RESULT__ = function (angular, _) {
  'use strict';

  var module = angular.module('grafana.directives');

  var iconMap = {
    "external link": "fa-external-link",
    "dashboard": "fa-th-large",
    "question": "fa-question",
    "info": "fa-info",
    "bolt": "fa-bolt",
    "doc": "fa-file-text-o",
    "cloud": "fa-cloud",
  };

  module.directive('dashLinksEditor', function() {
    return {
      restrict: 'E',
      controller: 'DashLinkEditorCtrl',
      templateUrl: 'public/app/features/dashlinks/editor.html',
      link: function() {
      }
    };
  });

  module.directive('dashLinksContainer', function() {
    return {
      scope: {
        links: "="
      },
      restrict: 'E',
      controller: 'DashLinksContainerCtrl',
      template: '<dash-link ng-repeat="link in generatedLinks" link="link"></dash-link>',
      link: function() { }
    };
  });

  module.directive('dashLink', ["$compile", "linkSrv", function($compile, linkSrv) {
    return {
      restrict: 'E',
      link: function(scope, elem) {
        var link = scope.link;
        var template = '<div class="gf-form">' +
          '<a class="pointer gf-form-label" data-placement="bottom"' +
          (link.asDropdown ? ' ng-click="fillDropdown(link)" data-toggle="dropdown"'  : "") + '>' +
          '<i></i> <span></span></a>';

        if (link.asDropdown) {
          template += '<ul class="dropdown-menu" role="menu">' +
            '<li ng-repeat="dash in link.searchHits"><a href="{{dash.url}}">{{dash.title}}</a></li>' +
            '</ul>';
        }

        template += '</div>';

        elem.html(template);
        $compile(elem.contents())(scope);

        var anchor = elem.find('a');
        var icon = elem.find('i');
        var span = elem.find('span');

        function update() {
          var linkInfo = linkSrv.getAnchorInfo(link);
          span.text(linkInfo.title);
          anchor.attr("href", linkInfo.href);
        }

        // tooltip
        elem.find('a').tooltip({ title: scope.link.tooltip, html: true, container: 'body' });
        icon.attr('class', 'fa fa-fw ' + scope.link.icon);
        anchor.attr('target', scope.link.target);

        // fix for menus on the far right
        if (link.asDropdown && scope.$last) {
          elem.find('.dropdown-menu').addClass('pull-right');
        }

        update();
        scope.$on('refresh', update);
      }
    };
  }]);

  module.controller("DashLinksContainerCtrl", ["$scope", "$rootScope", "$q", "backendSrv", "dashboardSrv", "linkSrv", function($scope, $rootScope, $q, backendSrv, dashboardSrv, linkSrv) {
    var currentDashId = dashboardSrv.getCurrent().id;

    function buildLinks(linkDef) {
      if (linkDef.type === 'dashboards') {
        if (!linkDef.tags) {
          console.log('Dashboard link missing tag');
          return $q.when([]);
        }

        if (linkDef.asDropdown) {
          return $q.when([{
            title: linkDef.title,
            tags: linkDef.tags,
            keepTime: linkDef.keepTime,
            includeVars: linkDef.includeVars,
            icon: "fa fa-bars",
            asDropdown: true
          }]);
        }

        return $scope.searchDashboards(linkDef, 7);
      }

      if (linkDef.type === 'link') {
        return $q.when([{
          url: linkDef.url,
          title: linkDef.title,
          icon: iconMap[linkDef.icon],
          tooltip: linkDef.tooltip,
          target: linkDef.targetBlank ? "_blank" : "_self",
          keepTime: linkDef.keepTime,
          includeVars: linkDef.includeVars,
        }]);
      }

      return $q.when([]);
    }

    function updateDashLinks() {
      var promises = _.map($scope.links, buildLinks);

      $q.all(promises).then(function(results) {
        $scope.generatedLinks = _.flatten(results);
      });
    }

    $scope.searchDashboards = function(link, limit) {
      return backendSrv.search({tag: link.tags, limit: limit}).then(function(results) {
        return _.reduce(results, function(memo, dash) {
          // do not add current dashboard
          if (dash.id !== currentDashId) {
            memo.push({
              title: dash.title,
              url: 'dashboard/' + dash.uri,
              icon: 'fa fa-th-large',
              keepTime: link.keepTime,
              includeVars: link.includeVars
            });
          }
          return memo;
        }, []);
      });
    };

    $scope.fillDropdown = function(link) {
      $scope.searchDashboards(link, 100).then(function(results) {
        _.each(results, function(hit) {
          hit.url = linkSrv.getLinkUrl(hit);
        });
        link.searchHits = results;
      });
    };

    updateDashLinks();
    $rootScope.onAppEvent('dash-links-updated', updateDashLinks, $scope);
  }]);

  module.controller('DashLinkEditorCtrl', ["$scope", "$rootScope", function($scope, $rootScope) {

    $scope.iconMap = iconMap;
    $scope.dashboard.links = $scope.dashboard.links || [];

    $scope.addLink = function() {
      $scope.dashboard.links.push({ type: 'dashboards', icon: 'external link' });
      $scope.dashboard.updateSubmenuVisibility();
      $scope.updated();
    };

    $scope.moveLink = function(index, dir) {
      _.move($scope.dashboard.links, index, index+dir);
      $scope.updated();
    };

    $scope.updated = function() {
      $rootScope.appEvent('dash-links-updated');
    };

    $scope.deleteLink = function(index) {
      $scope.dashboard.links.splice(index, 1);
      $scope.dashboard.updateSubmenuVisibility();
      $scope.updated();
    };

  }]);
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(201)(module)))

/***/ }),

/***/ 1543:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
  __webpack_require__(1544),
  __webpack_require__(1545),
  __webpack_require__(1546),
  __webpack_require__(1547),
  __webpack_require__(1548)
], __WEBPACK_AMD_DEFINE_RESULT__ = function () {}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ 1544:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PlaylistsCtrl", function() { return PlaylistsCtrl; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__core_core_module__ = __webpack_require__(2);
///<reference path="../../headers/common.d.ts" />


var PlaylistsCtrl = /** @class */ (function () {
    /** @ngInject */
    PlaylistsCtrl.$inject = ["$scope", "backendSrv", "navModelSrv"];
    function PlaylistsCtrl($scope, backendSrv, navModelSrv) {
        var _this = this;
        this.$scope = $scope;
        this.backendSrv = backendSrv;
        this.navModel = navModelSrv.getPlaylistsNav(0);
        backendSrv.get('/api/playlists').then(function (result) {
            _this.playlists = result;
        });
    }
    PlaylistsCtrl.prototype.removePlaylistConfirmed = function (playlist) {
        var _this = this;
        __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.remove(this.playlists, { id: playlist.id });
        this.backendSrv.delete('/api/playlists/' + playlist.id)
            .then(function () {
            _this.$scope.appEvent('alert-success', ['Playlist deleted', '']);
        }, function () {
            _this.$scope.appEvent('alert-error', ['Unable to delete playlist', '']);
            _this.playlists.push(playlist);
        });
    };
    PlaylistsCtrl.prototype.removePlaylist = function (playlist) {
        var _this = this;
        this.$scope.appEvent('confirm-modal', {
            title: 'Delete',
            text: 'Are you sure you want to delete playlist ' + playlist.name + '?',
            yesText: "Delete",
            icon: "fa-trash",
            onConfirm: function () {
                _this.removePlaylistConfirmed(playlist);
            }
        });
    };
    return PlaylistsCtrl;
}());

__WEBPACK_IMPORTED_MODULE_1__core_core_module__["default"].controller('PlaylistsCtrl', PlaylistsCtrl);


/***/ }),

/***/ 1545:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PlaylistSearchCtrl", function() { return PlaylistSearchCtrl; });
/* harmony export (immutable) */ __webpack_exports__["playlistSearchDirective"] = playlistSearchDirective;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__core_core_module__ = __webpack_require__(2);
///<reference path="../../headers/common.d.ts" />

var PlaylistSearchCtrl = /** @class */ (function () {
    /** @ngInject */
    PlaylistSearchCtrl.$inject = ["$timeout", "backendSrv"];
    function PlaylistSearchCtrl($timeout, backendSrv) {
        var _this = this;
        this.backendSrv = backendSrv;
        this.query = { query: '', tag: [], starred: false, limit: 30 };
        $timeout(function () {
            _this.query.query = '';
            _this.searchDashboards();
        }, 100);
    }
    PlaylistSearchCtrl.prototype.searchDashboards = function () {
        this.tagsMode = false;
        var prom = {};
        prom.promise = this.backendSrv.search(this.query).then(function (result) {
            return {
                dashboardResult: result,
                tagResult: []
            };
        });
        this.searchStarted(prom);
    };
    PlaylistSearchCtrl.prototype.showStarred = function () {
        this.query.starred = !this.query.starred;
        this.searchDashboards();
    };
    PlaylistSearchCtrl.prototype.queryHasNoFilters = function () {
        return this.query.query === '' && this.query.starred === false && this.query.tag.length === 0;
    };
    PlaylistSearchCtrl.prototype.filterByTag = function (tag, evt) {
        this.query.tag.push(tag);
        this.searchDashboards();
        if (evt) {
            evt.stopPropagation();
            evt.preventDefault();
        }
    };
    PlaylistSearchCtrl.prototype.getTags = function () {
        var prom = {};
        prom.promise = this.backendSrv.get('/api/dashboards/tags').then(function (result) {
            return {
                dashboardResult: [],
                tagResult: result
            };
        });
        this.searchStarted(prom);
    };
    return PlaylistSearchCtrl;
}());

function playlistSearchDirective() {
    return {
        restrict: 'E',
        templateUrl: 'public/app/features/playlist/partials/playlist_search.html',
        controller: PlaylistSearchCtrl,
        bindToController: true,
        controllerAs: 'ctrl',
        scope: {
            searchStarted: '&'
        },
    };
}
__WEBPACK_IMPORTED_MODULE_0__core_core_module__["default"].directive('playlistSearch', playlistSearchDirective);


/***/ }),

/***/ 1546:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__core_core_module__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_app_core_utils_kbn__ = __webpack_require__(464);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_app_core_app_events__ = __webpack_require__(53);
///<reference path="../../headers/common.d.ts" />



var PlaylistSrv = /** @class */ (function () {
    /** @ngInject */
    PlaylistSrv.$inject = ["$location", "$timeout", "backendSrv", "$routeParams"];
    function PlaylistSrv($location, $timeout, backendSrv, $routeParams) {
        this.$location = $location;
        this.$timeout = $timeout;
        this.backendSrv = backendSrv;
        this.$routeParams = $routeParams;
    }
    PlaylistSrv.prototype.next = function () {
        var _this = this;
        this.$timeout.cancel(this.cancelPromise);
        var playedAllDashboards = this.index > this.dashboards.length - 1;
        if (playedAllDashboards) {
            window.location.href = this.getUrlWithKioskMode();
            return;
        }
        var dash = this.dashboards[this.index];
        this.$location.url('dashboard/' + dash.uri);
        this.index++;
        this.cancelPromise = this.$timeout(function () { return _this.next(); }, this.interval);
    };
    PlaylistSrv.prototype.getUrlWithKioskMode = function () {
        var inKioskMode = document.body.classList.contains('page-kiosk-mode');
        // check if should add kiosk query param
        if (inKioskMode && this.startUrl.indexOf('kiosk') === -1) {
            return this.startUrl + '?kiosk=true';
        }
        // check if should remove kiosk query param
        if (!inKioskMode) {
            return this.startUrl.split("?")[0];
        }
        // already has kiosk query param, just return startUrl
        return this.startUrl;
    };
    PlaylistSrv.prototype.prev = function () {
        this.index = Math.max(this.index - 2, 0);
        this.next();
    };
    PlaylistSrv.prototype.start = function (playlistId) {
        var _this = this;
        this.stop();
        this.startUrl = window.location.href;
        this.index = 0;
        this.playlistId = playlistId;
        this.isPlaying = true;
        if (this.$routeParams.kiosk) {
            __WEBPACK_IMPORTED_MODULE_2_app_core_app_events__["a" /* default */].emit('toggle-kiosk-mode');
        }
        this.backendSrv.get("/api/playlists/" + playlistId).then(function (playlist) {
            _this.backendSrv.get("/api/playlists/" + playlistId + "/dashboards").then(function (dashboards) {
                _this.dashboards = dashboards;
                _this.interval = __WEBPACK_IMPORTED_MODULE_1_app_core_utils_kbn__["default"].interval_to_ms(playlist.interval);
                _this.next();
            });
        });
    };
    PlaylistSrv.prototype.stop = function () {
        this.index = 0;
        this.isPlaying = false;
        this.playlistId = 0;
        if (this.cancelPromise) {
            this.$timeout.cancel(this.cancelPromise);
        }
    };
    return PlaylistSrv;
}());
__WEBPACK_IMPORTED_MODULE_0__core_core_module__["default"].service('playlistSrv', PlaylistSrv);


/***/ }),

/***/ 1547:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PlaylistEditCtrl", function() { return PlaylistEditCtrl; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__core_core_module__ = __webpack_require__(2);
///<reference path="../../headers/common.d.ts" />


var PlaylistEditCtrl = /** @class */ (function () {
    /** @ngInject */
    PlaylistEditCtrl.$inject = ["$scope", "backendSrv", "$location", "$route", "navModelSrv"];
    function PlaylistEditCtrl($scope, backendSrv, $location, $route, navModelSrv) {
        var _this = this;
        this.$scope = $scope;
        this.backendSrv = backendSrv;
        this.$location = $location;
        this.filteredDashboards = [];
        this.filteredTags = [];
        this.searchQuery = '';
        this.loading = false;
        this.playlist = {
            interval: '5m',
        };
        this.playlistItems = [];
        this.dashboardresult = [];
        this.tagresult = [];
        this.navModel = navModelSrv.getPlaylistsNav(0);
        if ($route.current.params.id) {
            var playlistId = $route.current.params.id;
            backendSrv.get('/api/playlists/' + playlistId).then(function (result) {
                _this.playlist = result;
            });
            backendSrv.get('/api/playlists/' + playlistId + '/items').then(function (result) {
                _this.playlistItems = result;
            });
        }
    }
    PlaylistEditCtrl.prototype.filterFoundPlaylistItems = function () {
        var _this = this;
        this.filteredDashboards = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.reject(this.dashboardresult, function (playlistItem) {
            return __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.find(_this.playlistItems, function (listPlaylistItem) {
                return parseInt(listPlaylistItem.value) === playlistItem.id;
            });
        });
        this.filteredTags = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.reject(this.tagresult, function (tag) {
            return __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.find(_this.playlistItems, function (listPlaylistItem) {
                return listPlaylistItem.value === tag.term;
            });
        });
    };
    PlaylistEditCtrl.prototype.addPlaylistItem = function (playlistItem) {
        playlistItem.value = playlistItem.id.toString();
        playlistItem.type = 'dashboard_by_id';
        playlistItem.order = this.playlistItems.length + 1;
        this.playlistItems.push(playlistItem);
        this.filterFoundPlaylistItems();
    };
    PlaylistEditCtrl.prototype.addTagPlaylistItem = function (tag) {
        var playlistItem = {
            value: tag.term,
            type: 'dashboard_by_tag',
            order: this.playlistItems.length + 1,
            title: tag.term
        };
        this.playlistItems.push(playlistItem);
        this.filterFoundPlaylistItems();
    };
    PlaylistEditCtrl.prototype.removePlaylistItem = function (playlistItem) {
        __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.remove(this.playlistItems, function (listedPlaylistItem) {
            return playlistItem === listedPlaylistItem;
        });
        this.filterFoundPlaylistItems();
    };
    PlaylistEditCtrl.prototype.savePlaylist = function (playlist, playlistItems) {
        var _this = this;
        var savePromise;
        playlist.items = playlistItems;
        savePromise = playlist.id
            ? this.backendSrv.put('/api/playlists/' + playlist.id, playlist)
            : this.backendSrv.post('/api/playlists', playlist);
        savePromise
            .then(function () {
            _this.$scope.appEvent('alert-success', ['Playlist saved', '']);
            _this.$location.path('/playlists');
        }, function () {
            _this.$scope.appEvent('alert-error', ['Unable to save playlist', '']);
        });
    };
    PlaylistEditCtrl.prototype.isNew = function () {
        return !this.playlist.id;
    };
    PlaylistEditCtrl.prototype.isPlaylistEmpty = function () {
        return !this.playlistItems.length;
    };
    PlaylistEditCtrl.prototype.backToList = function () {
        this.$location.path('/playlists');
    };
    PlaylistEditCtrl.prototype.searchStarted = function (promise) {
        var _this = this;
        promise.then(function (data) {
            _this.dashboardresult = data.dashboardResult;
            _this.tagresult = data.tagResult;
            _this.filterFoundPlaylistItems();
        });
    };
    PlaylistEditCtrl.prototype.movePlaylistItem = function (playlistItem, offset) {
        var currentPosition = this.playlistItems.indexOf(playlistItem);
        var newPosition = currentPosition + offset;
        if (newPosition >= 0 && newPosition < this.playlistItems.length) {
            this.playlistItems.splice(currentPosition, 1);
            this.playlistItems.splice(newPosition, 0, playlistItem);
        }
    };
    PlaylistEditCtrl.prototype.movePlaylistItemUp = function (playlistItem) {
        this.movePlaylistItem(playlistItem, -1);
    };
    PlaylistEditCtrl.prototype.movePlaylistItemDown = function (playlistItem) {
        this.movePlaylistItem(playlistItem, 1);
    };
    return PlaylistEditCtrl;
}());

__WEBPACK_IMPORTED_MODULE_1__core_core_module__["default"].controller('PlaylistEditCtrl', PlaylistEditCtrl);


/***/ }),

/***/ 1548:
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
  __webpack_require__(12),
  __webpack_require__(7)
], __WEBPACK_AMD_DEFINE_RESULT__ = function (angular) {
  'use strict';

  var module = angular.module('grafana.routes');

  module.config(["$routeProvider", function($routeProvider) {
    $routeProvider
      .when('/playlists', {
        templateUrl: 'public/app/features/playlist/partials/playlists.html',
        controllerAs: 'ctrl',
        controller : 'PlaylistsCtrl'
      })
      .when('/playlists/create', {
        templateUrl: 'public/app/features/playlist/partials/playlist.html',
        controllerAs: 'ctrl',
        controller : 'PlaylistEditCtrl'
      })
      .when('/playlists/edit/:id', {
        templateUrl: 'public/app/features/playlist/partials/playlist.html',
        controllerAs: 'ctrl',
        controller : 'PlaylistEditCtrl'
      })
      .when('/playlists/play/:id', {
        templateUrl: 'public/app/features/playlist/partials/playlists.html',
        controllerAs: 'ctrl',
        controller : 'PlaylistsCtrl',
        resolve: {
          init: ["playlistSrv", "$route", function(playlistSrv, $route) {
            var playlistId = $route.current.params.id;
            playlistSrv.start(playlistId);
          }]
        }
      });
  }]);
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(201)(module)))

/***/ }),

/***/ 1549:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__snapshot_ctrl__ = __webpack_require__(1550);



/***/ }),

/***/ 1550:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export SnapshotsCtrl */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_angular__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_angular___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_angular__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_lodash__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_lodash__);
///<reference path="../../headers/common.d.ts" />


var SnapshotsCtrl = /** @class */ (function () {
    /** @ngInject */
    SnapshotsCtrl.$inject = ["$rootScope", "backendSrv"];
    function SnapshotsCtrl($rootScope, backendSrv) {
        var _this = this;
        this.$rootScope = $rootScope;
        this.backendSrv = backendSrv;
        this.navModel = {
            section: {
                title: 'Snapshots',
                icon: 'icon-gf icon-gf-snapshot',
                url: 'dashboard/snapshots',
            },
            menu: [],
        };
        this.backendSrv.get('/api/dashboard/snapshots').then(function (result) {
            _this.snapshots = result;
        });
    }
    SnapshotsCtrl.prototype.removeSnapshotConfirmed = function (snapshot) {
        var _this = this;
        __WEBPACK_IMPORTED_MODULE_1_lodash___default.a.remove(this.snapshots, { key: snapshot.key });
        this.backendSrv.get('/api/snapshots-delete/' + snapshot.deleteKey)
            .then(function () {
            _this.$rootScope.appEvent('alert-success', ['Snapshot deleted', '']);
        }, function () {
            _this.$rootScope.appEvent('alert-error', ['Unable to delete snapshot', '']);
            _this.snapshots.push(snapshot);
        });
    };
    SnapshotsCtrl.prototype.removeSnapshot = function (snapshot) {
        var _this = this;
        this.$rootScope.appEvent('confirm-modal', {
            title: 'Delete',
            text: 'Are you sure you want to delete snapshot ' + snapshot.name + '?',
            yesText: "Delete",
            icon: "fa-trash",
            onConfirm: function () {
                _this.removeSnapshotConfirmed(snapshot);
            }
        });
    };
    return SnapshotsCtrl;
}());

__WEBPACK_IMPORTED_MODULE_0_angular___default.a.module('grafana.controllers').controller('SnapshotsCtrl', SnapshotsCtrl);


/***/ }),

/***/ 1551:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
  __webpack_require__(1552),
  __webpack_require__(1553),
  __webpack_require__(1554),
  __webpack_require__(1327),
  __webpack_require__(1555),
  __webpack_require__(1556),
  __webpack_require__(1557),
], __WEBPACK_AMD_DEFINE_RESULT__ = function () {}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ 1552:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
  __webpack_require__(12),
  __webpack_require__(13),
  __webpack_require__(7),
  __webpack_require__(204),
], __WEBPACK_AMD_DEFINE_RESULT__ = function (angular, $, _, Tether) {
  'use strict';

  angular
    .module('grafana.directives')
    .directive('panelMenu', ["$compile", function($compile) {
      var linkTemplate =
          '<span class="panel-title drag-handle pointer">' +
            '<span class="icon-gf panel-alert-icon"></span>' +
            '<span class="panel-title-text drag-handle">{{ctrl.panel.title | interpolateTemplateVars:this}}</span>' +
            '<span class="panel-time-info" ng-show="ctrl.timeInfo"><i class="fa fa-clock-o"></i> {{ctrl.timeInfo}}</span>' +
          '</span>';

      function createMenuTemplate(ctrl) {
        var template = '<div class="panel-menu small">';

        if (ctrl.dashboard.meta.canEdit) {
          template += '<div class="panel-menu-inner">';
          template += '<div class="panel-menu-row">';
          if (!ctrl.dashboard.meta.fullscreen) {
            template += '<a class="panel-menu-icon pull-left" ng-click="ctrl.updateColumnSpan(-1)"><i class="fa fa-minus"></i></a>';
            template += '<a class="panel-menu-icon pull-left" ng-click="ctrl.updateColumnSpan(1)"><i class="fa fa-plus"></i></a>';
          }
          template += '<a class="panel-menu-icon pull-right" ng-click="ctrl.removePanel()"><i class="fa fa-trash"></i></a>';
          template += '<div class="clearfix"></div>';
          template += '</div>';
        }

        template += '<div class="panel-menu-row">';
        template += '<a class="panel-menu-link" gf-dropdown="extendedMenu"><i class="fa fa-bars"></i></a>';

        _.each(ctrl.getMenu(), function(item) {
          // skip edit actions if not editor
          if (item.role === 'Editor' && !ctrl.dashboard.meta.canEdit) {
            return;
          }

          template += '<a class="panel-menu-link" ';
          if (item.click) { template += ' ng-click="' + item.click + '"'; }
          if (item.href) { template += ' href="' + item.href + '"'; }
          template += '>';
          template += item.text + '</a>';
        });

        template += '</div>';
        template += '</div>';
        template += '</div>';
        return template;
      }

      function getExtendedMenu(ctrl) {
        return ctrl.getExtendedMenu();
      }

      return {
        restrict: 'A',
        link: function($scope, elem) {
          var $link = $(linkTemplate);
          var $panelContainer = elem.parents(".panel-container");
          var menuScope = null;
          var ctrl = $scope.ctrl;
          var timeout = null;
          var $menu = null;
          var teather;

          elem.append($link);

          function dismiss(time, force) {
            clearTimeout(timeout);
            timeout = null;

            if (time) {
              timeout = setTimeout(dismiss, time);
              return;
            }

            // if hovering or draging pospone close
            if (force !== true) {
              if ($menu.is(':hover') || $scope.ctrl.dashboard.$$panelDragging) {
                dismiss(2200);
                return;
              }
            }

            if (menuScope) {
              teather.destroy();
              $menu.unbind();
              $menu.remove();
              menuScope.$destroy();
              menuScope = null;
              $menu = null;
              $panelContainer.removeClass('panel-highlight');
            }
          }

          var showMenu = function(e) {
            // if menu item is clicked and menu was just removed from dom ignore this event
            if (!$.contains(document, e.target)) {
              return;
            }

            if ($menu) {
              dismiss();
              return;
            }

            var menuTemplate;
            menuTemplate = createMenuTemplate(ctrl);

            $menu = $(menuTemplate);
            $menu.mouseleave(function() {
              dismiss(1000);
            });

            menuScope = $scope.$new();
            menuScope.extendedMenu = getExtendedMenu(ctrl);
            menuScope.dismiss = function() {
              dismiss(null, true);
            };

            $(".panel-container").removeClass('panel-highlight');
            $panelContainer.toggleClass('panel-highlight');

            $('.panel-menu').remove();

            elem.append($menu);

            $scope.$apply(function() {
              $compile($menu.contents())(menuScope);

              teather = new Tether({
                element: $menu,
                target: $panelContainer,
                attachment: 'bottom center',
                targetAttachment: 'top center',
                constraints: [
                  {
                    to: 'window',
                    attachment: 'together',
                    pin: true
                  }
                ]
              });
            });

            dismiss(2200);
          };

          elem.click(showMenu);
          $compile(elem.contents())($scope);
        }
      };
    }]);
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ 1553:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_angular__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_angular___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_angular__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_jquery__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_jquery___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_jquery__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_tether_drop__ = __webpack_require__(79);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_tether_drop___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_tether_drop__);
///<reference path="../../headers/common.d.ts" />



var module = __WEBPACK_IMPORTED_MODULE_0_angular___default.a.module('grafana.directives');
var panelTemplate = "\n  <div class=\"panel-container\">\n    <div class=\"panel-header\">\n      <span class=\"panel-info-corner\">\n        <i class=\"fa\"></i>\n        <span class=\"panel-info-corner-inner\"></span>\n      </span>\n\n      <span class=\"panel-loading\" ng-show=\"ctrl.loading\">\n        <i class=\"fa fa-spinner fa-spin\"></i>\n      </span>\n\n      <div class=\"panel-title-container drag-handle\" panel-menu></div>\n    </div>\n\n    <div class=\"panel-content\">\n      <ng-transclude></ng-transclude>\n    </div>\n    <panel-resizer></panel-resizer>\n  </div>\n\n  <div class=\"panel-full-edit\" ng-if=\"ctrl.editMode\">\n    <div class=\"tabbed-view tabbed-view--panel-edit\">\n      <div class=\"tabbed-view-header\">\n        <h2 class=\"tabbed-view-title\">\n          {{ctrl.pluginName}}\n        </h2>\n\n        <ul class=\"gf-tabs\">\n          <li class=\"gf-tabs-item\" ng-repeat=\"tab in ::ctrl.editorTabs\">\n            <a class=\"gf-tabs-link\" ng-click=\"ctrl.changeTab($index)\" ng-class=\"{active: ctrl.editorTabIndex === $index}\">\n              {{::tab.title}}\n            </a>\n          </li>\n        </ul>\n\n        <button class=\"tabbed-view-close-btn\" ng-click=\"ctrl.exitFullscreen();\">\n          <i class=\"fa fa-remove\"></i>\n        </button>\n      </div>\n\n      <div class=\"tabbed-view-body\">\n        <div ng-repeat=\"tab in ctrl.editorTabs\" ng-if=\"ctrl.editorTabIndex === $index\">\n          <panel-editor-tab editor-tab=\"tab\" ctrl=\"ctrl\" index=\"$index\"></panel-editor-tab>\n        </div>\n      </div>\n    </div>\n  </div>\n";
module.directive('grafanaPanel', ["$rootScope", "$document", function ($rootScope, $document) {
    return {
        restrict: 'E',
        template: panelTemplate,
        transclude: true,
        scope: { ctrl: "=" },
        link: function (scope, elem) {
            var panelContainer = elem.find('.panel-container');
            var cornerInfoElem = elem.find('.panel-info-corner');
            var ctrl = scope.ctrl;
            var infoDrop;
            // the reason for handling these classes this way is for performance
            // limit the watchers on panels etc
            var transparentLastState = false;
            var lastHasAlertRule = false;
            var lastAlertState;
            var hasAlertRule;
            var lastHeight = 0;
            function mouseEnter() {
                panelContainer.toggleClass('panel-hover-highlight', true);
                ctrl.dashboard.setPanelFocus(ctrl.panel.id);
            }
            function mouseLeave() {
                panelContainer.toggleClass('panel-hover-highlight', false);
                ctrl.dashboard.setPanelFocus(0);
            }
            // set initial height
            if (!ctrl.containerHeight) {
                ctrl.calculatePanelHeight();
                panelContainer.css({ minHeight: ctrl.containerHeight });
                lastHeight = ctrl.containerHeight;
            }
            // set initial transparency
            if (ctrl.panel.transparent) {
                transparentLastState = true;
                panelContainer.addClass('panel-transparent', true);
            }
            ctrl.events.on('render', function () {
                if (lastHeight !== ctrl.containerHeight) {
                    panelContainer.css({ minHeight: ctrl.containerHeight });
                    lastHeight = ctrl.containerHeight;
                }
                if (transparentLastState !== ctrl.panel.transparent) {
                    panelContainer.toggleClass('panel-transparent', ctrl.panel.transparent === true);
                    transparentLastState = ctrl.panel.transparent;
                }
                hasAlertRule = ctrl.panel.alert !== undefined;
                if (lastHasAlertRule !== hasAlertRule) {
                    panelContainer.toggleClass('panel-has-alert', hasAlertRule);
                    lastHasAlertRule = hasAlertRule;
                }
                if (ctrl.alertState) {
                    if (lastAlertState) {
                        panelContainer.removeClass('panel-alert-state--' + lastAlertState);
                    }
                    if (ctrl.alertState.state === 'ok' || ctrl.alertState.state === 'alerting') {
                        panelContainer.addClass('panel-alert-state--' + ctrl.alertState.state);
                    }
                    lastAlertState = ctrl.alertState.state;
                }
                else if (lastAlertState) {
                    panelContainer.removeClass('panel-alert-state--' + lastAlertState);
                    lastAlertState = null;
                }
            });
            var lastFullscreen;
            $rootScope.onAppEvent('panel-change-view', function (evt, payload) {
                if (lastFullscreen !== ctrl.fullscreen) {
                    elem.toggleClass('panel-fullscreen', ctrl.fullscreen ? true : false);
                    lastFullscreen = ctrl.fullscreen;
                }
            }, scope);
            function updatePanelCornerInfo() {
                var cornerMode = ctrl.getInfoMode();
                cornerInfoElem[0].className = 'panel-info-corner panel-info-corner--' + cornerMode;
                if (cornerMode) {
                    if (infoDrop) {
                        infoDrop.destroy();
                    }
                    infoDrop = new __WEBPACK_IMPORTED_MODULE_2_tether_drop___default.a({
                        target: cornerInfoElem[0],
                        content: function () {
                            return ctrl.getInfoContent({ mode: 'tooltip' });
                        },
                        classes: ctrl.error ? 'drop-error' : 'drop-help',
                        openOn: 'hover',
                        hoverOpenDelay: 100,
                        tetherOptions: {
                            attachment: 'bottom left',
                            targetAttachment: 'top left',
                            constraints: [
                                {
                                    to: 'window',
                                    attachment: 'together',
                                    pin: true
                                }
                            ],
                        }
                    });
                }
            }
            scope.$watchGroup(['ctrl.error', 'ctrl.panel.description'], updatePanelCornerInfo);
            scope.$watchCollection('ctrl.panel.links', updatePanelCornerInfo);
            cornerInfoElem.on('click', function () {
                infoDrop.close();
                scope.$apply(ctrl.openInspector.bind(ctrl));
            });
            elem.on('mouseenter', mouseEnter);
            elem.on('mouseleave', mouseLeave);
            scope.$on('$destroy', function () {
                elem.off();
                cornerInfoElem.off();
                if (infoDrop) {
                    infoDrop.destroy();
                }
            });
        }
    };
}]);
module.directive('panelResizer', ["$rootScope", function ($rootScope) {
    return {
        restrict: 'E',
        template: '<span class="resize-panel-handle icon-gf icon-gf-grabber"></span>',
        link: function (scope, elem) {
            var resizing = false;
            var lastPanel;
            var ctrl = scope.ctrl;
            var handleOffset;
            var originalHeight;
            var originalWidth;
            var maxWidth;
            function dragStartHandler(e) {
                e.preventDefault();
                resizing = true;
                handleOffset = __WEBPACK_IMPORTED_MODULE_1_jquery___default()(e.target).offset();
                originalHeight = parseInt(ctrl.row.height);
                originalWidth = ctrl.panel.span;
                maxWidth = __WEBPACK_IMPORTED_MODULE_1_jquery___default()(document).width();
                lastPanel = ctrl.row.panels[ctrl.row.panels.length - 1];
                __WEBPACK_IMPORTED_MODULE_1_jquery___default()('body').on('mousemove', moveHandler);
                __WEBPACK_IMPORTED_MODULE_1_jquery___default()('body').on('mouseup', dragEndHandler);
            }
            function moveHandler(e) {
                ctrl.row.height = Math.round(originalHeight + (e.pageY - handleOffset.top));
                ctrl.panel.span = originalWidth + (((e.pageX - handleOffset.left) / maxWidth) * 12);
                ctrl.panel.span = Math.min(Math.max(ctrl.panel.span, 1), 12);
                ctrl.row.updateRowSpan();
                var rowSpan = ctrl.row.span;
                // auto adjust other panels
                if (Math.floor(rowSpan) < 14) {
                    // last panel should not push row down
                    if (lastPanel === ctrl.panel && rowSpan > 12) {
                        lastPanel.span -= rowSpan - 12;
                    }
                    else if (lastPanel !== ctrl.panel) {
                        // reduce width of last panel so total in row is 12
                        lastPanel.span = lastPanel.span - (rowSpan - 12);
                        lastPanel.span = Math.min(Math.max(lastPanel.span, 1), 12);
                    }
                }
                ctrl.row.panelSpanChanged(true);
                scope.$apply(function () {
                    ctrl.render();
                });
            }
            function dragEndHandler() {
                ctrl.panel.span = Math.round(ctrl.panel.span);
                if (lastPanel) {
                    lastPanel.span = Math.round(lastPanel.span);
                }
                // first digest to propagate panel width change
                // then render
                $rootScope.$apply(function () {
                    ctrl.row.panelSpanChanged();
                    setTimeout(function () {
                        $rootScope.$broadcast('render');
                    });
                });
                __WEBPACK_IMPORTED_MODULE_1_jquery___default()('body').off('mousemove', moveHandler);
                __WEBPACK_IMPORTED_MODULE_1_jquery___default()('body').off('mouseup', dragEndHandler);
            }
            elem.on('mousedown', dragStartHandler);
            var unbind = scope.$on("$destroy", function () {
                elem.off('mousedown', dragStartHandler);
                unbind();
            });
        }
    };
}]);
module.directive('panelHelpCorner', ["$rootScope", function ($rootScope) {
    return {
        restrict: 'E',
        template: "\n      <span class=\"alert-error panel-error small pointer\" ng-if=\"ctrl.error\" ng-click=\"ctrl.openInspector()\">\n        <span data-placement=\"top\" bs-tooltip=\"ctrl.error\">\n          <i class=\"fa fa-exclamation\"></i><span class=\"panel-error-arrow\"></span>\n        </span>\n      </span>\n    ",
        link: function (scope, elem) {
        }
    };
}]);


/***/ }),

/***/ 1554:
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
  __webpack_require__(12),
  __webpack_require__(13),
], __WEBPACK_AMD_DEFINE_RESULT__ = function (angular, $) {
  "use strict";

  var module = angular.module('grafana.routes');

  module.controller('SoloPanelCtrl', ["$scope", "$routeParams", "$location", "dashboardLoaderSrv", "contextSrv", function($scope, $routeParams, $location, dashboardLoaderSrv, contextSrv) {

    var panelId;

    $scope.init = function() {
      contextSrv.sidemenu = false;

      var params = $location.search();
      panelId = parseInt(params.panelId);

      $scope.onAppEvent("dashboard-initialized", $scope.initPanelScope);

      dashboardLoaderSrv.loadDashboard($routeParams.type, $routeParams.slug).then(function(result) {
        result.meta.soloMode = true;
        $scope.initDashboard(result, $scope);
      });
    };

    $scope.initPanelScope = function() {
      var panelInfo = $scope.dashboard.getPanelInfoById(panelId);

      // fake row ctrl scope
      $scope.ctrl = {
        row: panelInfo.row,
        dashboard: $scope.dashboard,
      };

      $scope.ctrl.row.height = $(window).height();
      $scope.panel = panelInfo.panel;
      $scope.$index = 0;

      if (!$scope.panel) {
        $scope.appEvent('alert-error', ['Panel not found', '']);
        return;
      }

      $scope.panel.span = 12;
    };

    $scope.init();
  }]);
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(201)(module)))

/***/ }),

/***/ 1555:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
panelEditorTab.$inject = ["dynamicDirectiveSrv"];
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_angular__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_angular___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_angular__);
///<reference path="../../headers/common.d.ts" />

var directiveModule = __WEBPACK_IMPORTED_MODULE_0_angular___default.a.module('grafana.directives');
/** @ngInject */
function panelEditorTab(dynamicDirectiveSrv) {
    return dynamicDirectiveSrv.create({
        scope: {
            ctrl: "=",
            editorTab: "=",
            index: "=",
        },
        directive: function (scope) {
            var pluginId = scope.ctrl.pluginId;
            var tabIndex = scope.index;
            // create a wrapper for directiveFn
            // required for metrics tab directive
            // that is the same for many panels but
            // given different names in this function
            var fn = function () { return scope.editorTab.directiveFn(); };
            return Promise.resolve({
                name: "panel-editor-tab-" + pluginId + tabIndex,
                fn: fn,
            });
        }
    });
}
directiveModule.directive('panelEditorTab', panelEditorTab);


/***/ }),

/***/ 1556:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "QueryRowCtrl", function() { return QueryRowCtrl; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_angular__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_angular___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_angular__);
///<reference path="../../headers/common.d.ts" />

var module = __WEBPACK_IMPORTED_MODULE_0_angular___default.a.module('grafana.directives');
var QueryRowCtrl = /** @class */ (function () {
    function QueryRowCtrl() {
        this.panelCtrl = this.queryCtrl.panelCtrl;
        this.target = this.queryCtrl.target;
        this.panel = this.panelCtrl.panel;
        if (!this.target.refId) {
            this.target.refId = this.panelCtrl.dashboard.getNextQueryLetter(this.panel);
        }
        this.toggleCollapse(true);
        if (this.target.isNew) {
            delete this.target.isNew;
            this.toggleCollapse(false);
        }
        if (this.panel.targets.length < 4) {
            this.collapsed = false;
        }
    }
    QueryRowCtrl.prototype.toggleHideQuery = function () {
        this.target.hide = !this.target.hide;
        this.panelCtrl.refresh();
    };
    QueryRowCtrl.prototype.toggleCollapse = function (init) {
        if (!this.canCollapse) {
            return;
        }
        if (!this.panelCtrl.__collapsedQueryCache) {
            this.panelCtrl.__collapsedQueryCache = {};
        }
        if (init) {
            this.collapsed = this.panelCtrl.__collapsedQueryCache[this.target.refId] !== false;
        }
        else {
            this.collapsed = !this.collapsed;
            this.panelCtrl.__collapsedQueryCache[this.target.refId] = this.collapsed;
        }
        try {
            this.collapsedText = this.queryCtrl.getCollapsedText();
        }
        catch (e) {
            var err = e.message || e.toString();
            this.collapsedText = 'Error: ' + err;
        }
    };
    QueryRowCtrl.prototype.toggleEditorMode = function () {
        if (this.canCollapse && this.collapsed) {
            this.collapsed = false;
        }
        this.queryCtrl.toggleEditorMode();
    };
    QueryRowCtrl.prototype.removeQuery = function () {
        if (this.panelCtrl.__collapsedQueryCache) {
            delete this.panelCtrl.__collapsedQueryCache[this.target.refId];
        }
        this.panelCtrl.removeQuery(this.target);
    };
    QueryRowCtrl.prototype.duplicateQuery = function () {
        var clone = __WEBPACK_IMPORTED_MODULE_0_angular___default.a.copy(this.target);
        this.panelCtrl.addQuery(clone);
    };
    QueryRowCtrl.prototype.moveQuery = function (direction) {
        this.panelCtrl.moveQuery(this.target, direction);
    };
    return QueryRowCtrl;
}());

/** @ngInject **/
function queryEditorRowDirective() {
    return {
        restrict: 'E',
        controller: QueryRowCtrl,
        bindToController: true,
        controllerAs: "ctrl",
        templateUrl: 'public/app/features/panel/partials/query_editor_row.html',
        transclude: true,
        scope: {
            queryCtrl: "=",
            canCollapse: "=",
            hasTextEditMode: "=",
        },
    };
}
module.directive('queryEditorRow', queryEditorRowDirective);


/***/ }),

/***/ 1557:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "QueryTroubleshooterCtrl", function() { return QueryTroubleshooterCtrl; });
/* harmony export (immutable) */ __webpack_exports__["queryTroubleshooter"] = queryTroubleshooter;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_app_core_app_events__ = __webpack_require__(53);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_app_core_core__ = __webpack_require__(465);
///<reference path="../../headers/common.d.ts" />



var template = "\n<div class=\"query-troubleshooter\" ng-if=\"ctrl.isOpen\">\n  <div class=\"query-troubleshooter__header\">\n    <a class=\"pointer\" ng-click=\"ctrl.toggleMocking()\">Mock Response</a>\n    <a class=\"pointer\" ng-click=\"ctrl.toggleExpand()\" ng-hide=\"ctrl.allNodesExpanded\">\n      <i class=\"fa fa-plus-square-o\"></i> Expand All\n    </a>\n    <a class=\"pointer\" ng-click=\"ctrl.toggleExpand()\" ng-show=\"ctrl.allNodesExpanded\">\n      <i class=\"fa fa-minus-square-o\"></i> Collapse All\n    </a>\n    <a class=\"pointer\" clipboard-button=\"ctrl.getClipboardText()\"><i class=\"fa fa-clipboard\"></i> Copy to Clipboard</a>\n  </div>\n  <div class=\"query-troubleshooter__body\" ng-hide=\"ctrl.isMocking\">\n    <i class=\"fa fa-spinner fa-spin\" ng-show=\"ctrl.isLoading\"></i>\n    <div class=\"query-troubleshooter-json\"></div>\n  </div>\n  <div class=\"query-troubleshooter__body\" ng-show=\"ctrl.isMocking\">\n    <div class=\"gf-form p-l-1 gf-form--v-stretch\">\n\t\t\t<textarea class=\"gf-form-input\" style=\"width: 95%\" rows=\"10\" ng-model=\"ctrl.mockedResponse\"  placeholder=\"JSON\"></textarea>\n    </div>\n  </div>\n</div>\n";
var QueryTroubleshooterCtrl = /** @class */ (function () {
    /** @ngInject **/
    QueryTroubleshooterCtrl.$inject = ["$scope", "$timeout"];
    function QueryTroubleshooterCtrl($scope, $timeout) {
        this.$timeout = $timeout;
        this.onRequestErrorEventListener = this.onRequestError.bind(this);
        this.onRequestResponseEventListener = this.onRequestResponse.bind(this);
        __WEBPACK_IMPORTED_MODULE_1_app_core_app_events__["a" /* default */].on('ds-request-response', this.onRequestResponseEventListener);
        __WEBPACK_IMPORTED_MODULE_1_app_core_app_events__["a" /* default */].on('ds-request-error', this.onRequestErrorEventListener);
        $scope.$on('$destroy', this.removeEventsListeners.bind(this));
        $scope.$watch('ctrl.isOpen', this.stateChanged.bind(this));
    }
    QueryTroubleshooterCtrl.prototype.removeEventsListeners = function () {
        __WEBPACK_IMPORTED_MODULE_1_app_core_app_events__["a" /* default */].off('ds-request-response', this.onRequestResponseEventListener);
        __WEBPACK_IMPORTED_MODULE_1_app_core_app_events__["a" /* default */].off('ds-request-error', this.onRequestErrorEventListener);
    };
    QueryTroubleshooterCtrl.prototype.toggleMocking = function () {
        this.isMocking = !this.isMocking;
    };
    QueryTroubleshooterCtrl.prototype.onRequestError = function (err) {
        // ignore if closed
        if (!this.isOpen) {
            return;
        }
        this.isOpen = true;
        this.hasError = true;
        this.onRequestResponse(err);
    };
    QueryTroubleshooterCtrl.prototype.stateChanged = function () {
        if (this.isOpen) {
            this.panelCtrl.refresh();
            this.isLoading = true;
        }
    };
    QueryTroubleshooterCtrl.prototype.getClipboardText = function () {
        if (this.jsonExplorer) {
            return JSON.stringify(this.jsonExplorer.json, null, 2);
        }
        return '';
    };
    QueryTroubleshooterCtrl.prototype.handleMocking = function (data) {
        var mockedData;
        try {
            mockedData = JSON.parse(this.mockedResponse);
        }
        catch (err) {
            __WEBPACK_IMPORTED_MODULE_1_app_core_app_events__["a" /* default */].emit('alert-error', ['Failed to parse mocked response']);
            return;
        }
        data.data = mockedData;
    };
    QueryTroubleshooterCtrl.prototype.onRequestResponse = function (data) {
        // ignore if closed
        if (!this.isOpen) {
            return;
        }
        if (this.isMocking) {
            this.handleMocking(data);
            return;
        }
        this.isLoading = false;
        data = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.cloneDeep(data);
        if (data.headers) {
            delete data.headers;
        }
        if (data.config) {
            data.request = data.config;
            delete data.config;
            delete data.request.transformRequest;
            delete data.request.transformResponse;
            delete data.request.paramSerializer;
            delete data.request.jsonpCallbackParam;
            delete data.request.headers;
            delete data.request.requestId;
            delete data.request.inspect;
            delete data.request.retry;
            delete data.request.timeout;
        }
        if (data.data) {
            data.response = data.data;
            if (data.status === 200) {
                // if we are in error state, assume we automatically opened
                // and auto close it again
                if (this.hasError) {
                    this.hasError = false;
                    this.isOpen = false;
                }
            }
            delete data.data;
            delete data.status;
            delete data.statusText;
            delete data.$$config;
        }
        this.$timeout(__WEBPACK_IMPORTED_MODULE_0_lodash___default.a.partial(this.renderJsonExplorer, data));
    };
    QueryTroubleshooterCtrl.prototype.toggleExpand = function (depth) {
        if (this.jsonExplorer) {
            this.allNodesExpanded = !this.allNodesExpanded;
            this.jsonExplorer.openAtDepth(this.allNodesExpanded ? 20 : 1);
        }
    };
    return QueryTroubleshooterCtrl;
}());

function queryTroubleshooter() {
    return {
        restrict: 'E',
        template: template,
        controller: QueryTroubleshooterCtrl,
        bindToController: true,
        controllerAs: 'ctrl',
        scope: {
            panelCtrl: "=",
            isOpen: "=",
        },
        link: function (scope, elem, attrs, ctrl) {
            ctrl.renderJsonExplorer = function (data) {
                var jsonElem = elem.find('.query-troubleshooter-json');
                ctrl.jsonExplorer = new __WEBPACK_IMPORTED_MODULE_2_app_core_core__["JsonExplorer"](data, 3, {
                    animateOpen: true,
                });
                var html = ctrl.jsonExplorer.render(true);
                jsonElem.html(html);
            };
        }
    };
}
__WEBPACK_IMPORTED_MODULE_2_app_core_core__["coreModule"].directive('queryTroubleshooter', queryTroubleshooter);


/***/ }),

/***/ 1558:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_app_core_core_module__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_app_core_config__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_lodash__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_lodash__);



var StyleGuideCtrl = /** @class */ (function () {
    /** @ngInject **/
    StyleGuideCtrl.$inject = ["$http", "$routeParams", "backendSrv", "navModelSrv"];
    function StyleGuideCtrl($http, $routeParams, backendSrv, navModelSrv) {
        this.$http = $http;
        this.$routeParams = $routeParams;
        this.backendSrv = backendSrv;
        this.colors = [];
        this.buttonNames = ['primary', 'secondary', 'inverse', 'success', 'warning', 'danger'];
        this.buttonSizes = ['btn-small', '', 'btn-large'];
        this.buttonVariants = ['-', '-outline-'];
        this.icons = [];
        this.pages = ['colors', 'buttons', 'icons', 'plugins'];
        this.navModel = navModelSrv.getAdminNav();
        this.theme = __WEBPACK_IMPORTED_MODULE_1_app_core_config__["default"].bootData.user.lightTheme ? 'light' : 'dark';
        this.page = {};
        if ($routeParams.page) {
            this.page[$routeParams.page] = 1;
        }
        else {
            this.page.colors = true;
        }
        if (this.page.colors) {
            this.loadColors();
        }
        if (this.page.icons) {
            this.loadIcons();
        }
    }
    StyleGuideCtrl.prototype.loadColors = function () {
        var _this = this;
        this.$http.get('public/build/styleguide.json').then(function (res) {
            _this.colors = __WEBPACK_IMPORTED_MODULE_2_lodash___default.a.map(res.data[_this.theme], function (value, key) {
                return { name: key, value: value };
            });
        });
    };
    StyleGuideCtrl.prototype.loadIcons = function () {
        var _this = this;
        this.$http.get('public/sass/icons.json').then(function (res) {
            _this.icons = res.data;
        });
    };
    StyleGuideCtrl.prototype.switchTheme = function () {
        this.$routeParams.theme = this.theme === 'dark' ? 'light' : 'dark';
        var cmd = {
            theme: this.$routeParams.theme
        };
        this.backendSrv.put('/api/user/preferences', cmd).then(function () {
            window.location.href = window.location.href;
        });
    };
    return StyleGuideCtrl;
}());
__WEBPACK_IMPORTED_MODULE_0_app_core_core_module__["default"].controller('StyleGuideCtrl', StyleGuideCtrl);


/***/ })

});
//# sourceMappingURL=0.225936f9cc525791439e.js.map